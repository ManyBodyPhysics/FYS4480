
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7. The Coupled Cluster Method &#8212; Quantum Mechanics for Many-Particle Systems</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Variational Monte Carlo methods" href="vmcdmc.html" />
    <link rel="prev" title="6. Many-body perturbation theory" href="mbpt.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Quantum Mechanics for Many-Particle Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Quantum mechanics for many-particle systems
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Schedule
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Instructor information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basics of Many-Body Physics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="notation.html">
   1. Introduction to many-body physics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="secondquant.html">
   2. Introduction to  second quantization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fci.html">
   3. Full configuration interaction theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hfock.html">
   4. Hartree-Fock theory
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Post Hartree-Fock Methods
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="mbpt.html">
   6. Many-body perturbation theory
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   7. The Coupled Cluster Method
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Stochastic Methods
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vmcdmc.html">
   10. Variational Monte Carlo methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="gradientmethods.html">
   11. Gradient Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="resamplingmethods.html">
   12. Resampling Techniques, Bootstrap and Blocking
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Deep Learning methods
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="boltzmannmachines.html">
   13. Boltzmann Machines
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Computational Aspects
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="vectorization.html">
   14. Optimization and Vectorization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallelization.html">
   15. Parallelization with MPI and OpenMPI
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/cc.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   7. The Coupled Cluster Method
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#introduction">
     7.1. Introduction
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-normal-ordered-hamiltonian">
     7.2. The normal-ordered Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-1-practice-in-normal-ordering">
     7.3. Exercise 1: Practice in normal ordering
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-2-what-does-good-mean">
     7.4. Exercise 2: What does “good” mean?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-3-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields">
     7.5. Exercise 3: How many nuclei are accessible with the coupled cluster method based on spherical mean fields?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-similarity-transformed-hamiltonian">
     7.6. The similarity transformed Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-4-what-t-leads-to-hermitian-overline-h-n">
     7.7. Exercise 4: What
     <span class="math notranslate nohighlight">
      \(T\)
     </span>
     leads to Hermitian
     <span class="math notranslate nohighlight">
      \(\overline{H_N}\)
     </span>
     ?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-5-understanding-non-unitary-similarity-transformations">
     7.8. Exercise 5: Understanding (non-unitary) similarity transformations
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-6-how-many-unknowns">
     7.9. Exercise 6: How many unknowns?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-7-why-is-ccd-not-exact">
     7.10. Exercise 7: Why is CCD not exact?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-the-similarity-transformed-hamiltonian">
     7.11. Computing the similarity-transformed Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-8-when-does-ccsd-truncate">
     7.12. Exercise 8: When does CCSD truncate?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-9-compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle">
     7.13. Exercise 9: Compute the matrix element
     <span class="math notranslate nohighlight">
      \(\overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-the-contribution-of-f-t-2-to-overline-h-n">
     7.14. Example: The contribution of
     <span class="math notranslate nohighlight">
      \([F, T_2]\)
     </span>
     to
     <span class="math notranslate nohighlight">
      \(\overline{H_N}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#diagrams">
       7.14.1. Diagrams
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-10-assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction">
     7.15. Exercise 10: Assign the correct matrix element
     <span class="math notranslate nohighlight">
      \(\langle pq\vert V\vert rs\rangle\)
     </span>
     to each of the following diagrams of the interaction
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-ccsd-correlation-energy">
     7.16. Example: CCSD correlation energy
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ccd-approximation">
     7.17. CCD Approximation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-11-derive-the-ccd-equations">
     7.18. Exercise 11: Derive the CCD equations!
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-12-computational-scaling-of-ccd">
     7.19. Exercise 12: Computational scaling of CCD
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-13-factorize-the-remaining-diagrams-of-the-ccd-equation">
     7.20. Exercise 13: Factorize the remaining diagrams of the CCD equation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#project-14-optional-derive-the-ccsd-equations">
     7.21. Project 14: (Optional) Derive the CCSD equations!
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solving-the-ccd-equations">
     7.22. Solving the CCD equations
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ccd-for-the-pairing-hamiltonian">
     7.23. CCD for the pairing Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#project-15-solve-the-ccd-equations-for-the-pairing-problem">
     7.24. Project 15: Solve the CCD equations for the pairing problem
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nucleonic-matter">
   8. Nucleonic Matter
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-16-which-symmetries-are-relevant-for-nuclear-matter">
     8.1. Exercise 16: Which symmetries are relevant for nuclear matter?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basis-states">
     8.2. Basis states
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-17-determine-the-basis-states">
     8.3. Exercise 17: Determine the basis states
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-18-how-large-should-the-basis-be">
     8.4. Exercise 18: How large should the basis be?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-19-determine-the-lowest-few-magic-numbers-for-a-cubic-lattice">
     8.5. Exercise 19: Determine the lowest few magic numbers for a cubic lattice.
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finite-size-effects">
     8.6. Finite size effects
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#channel-structure-of-hamiltonian-and-cluster-amplitudes">
     8.7. Channel structure of Hamiltonian and cluster amplitudes
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-channel-structure-and-its-usage">
     8.8. Example: Channel structure and its usage
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-20-write-a-ccd-code-for-neutron-matter-focusing-first-on-ladder-approximation-i-e-including-the-first-five-diagrams-in-figure-11">
     8.9. Exercise 20: Write a CCD code for neutron matter, focusing first on ladder approximation, i.e. including the first five diagrams in Figure 11.
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#benchmarks-with-the-minnesota-potential">
     8.10. Benchmarks with the Minnesota potential
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#from-structure-to-reactions">
   9. From Structure to Reactions
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#electroweak-reactions">
     9.1. Electroweak reactions
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-optical-potentials-from-microscopic-input">
     9.2. Computing optical potentials from microscopic input
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>The Coupled Cluster Method</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   7. The Coupled Cluster Method
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#introduction">
     7.1. Introduction
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-normal-ordered-hamiltonian">
     7.2. The normal-ordered Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-1-practice-in-normal-ordering">
     7.3. Exercise 1: Practice in normal ordering
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-2-what-does-good-mean">
     7.4. Exercise 2: What does “good” mean?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-3-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields">
     7.5. Exercise 3: How many nuclei are accessible with the coupled cluster method based on spherical mean fields?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-similarity-transformed-hamiltonian">
     7.6. The similarity transformed Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-4-what-t-leads-to-hermitian-overline-h-n">
     7.7. Exercise 4: What
     <span class="math notranslate nohighlight">
      \(T\)
     </span>
     leads to Hermitian
     <span class="math notranslate nohighlight">
      \(\overline{H_N}\)
     </span>
     ?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-5-understanding-non-unitary-similarity-transformations">
     7.8. Exercise 5: Understanding (non-unitary) similarity transformations
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-6-how-many-unknowns">
     7.9. Exercise 6: How many unknowns?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-7-why-is-ccd-not-exact">
     7.10. Exercise 7: Why is CCD not exact?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-the-similarity-transformed-hamiltonian">
     7.11. Computing the similarity-transformed Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-8-when-does-ccsd-truncate">
     7.12. Exercise 8: When does CCSD truncate?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-9-compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle">
     7.13. Exercise 9: Compute the matrix element
     <span class="math notranslate nohighlight">
      \(\overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-the-contribution-of-f-t-2-to-overline-h-n">
     7.14. Example: The contribution of
     <span class="math notranslate nohighlight">
      \([F, T_2]\)
     </span>
     to
     <span class="math notranslate nohighlight">
      \(\overline{H_N}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#diagrams">
       7.14.1. Diagrams
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-10-assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction">
     7.15. Exercise 10: Assign the correct matrix element
     <span class="math notranslate nohighlight">
      \(\langle pq\vert V\vert rs\rangle\)
     </span>
     to each of the following diagrams of the interaction
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-ccsd-correlation-energy">
     7.16. Example: CCSD correlation energy
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ccd-approximation">
     7.17. CCD Approximation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-11-derive-the-ccd-equations">
     7.18. Exercise 11: Derive the CCD equations!
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-12-computational-scaling-of-ccd">
     7.19. Exercise 12: Computational scaling of CCD
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-13-factorize-the-remaining-diagrams-of-the-ccd-equation">
     7.20. Exercise 13: Factorize the remaining diagrams of the CCD equation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#project-14-optional-derive-the-ccsd-equations">
     7.21. Project 14: (Optional) Derive the CCSD equations!
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solving-the-ccd-equations">
     7.22. Solving the CCD equations
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ccd-for-the-pairing-hamiltonian">
     7.23. CCD for the pairing Hamiltonian
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#project-15-solve-the-ccd-equations-for-the-pairing-problem">
     7.24. Project 15: Solve the CCD equations for the pairing problem
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nucleonic-matter">
   8. Nucleonic Matter
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-16-which-symmetries-are-relevant-for-nuclear-matter">
     8.1. Exercise 16: Which symmetries are relevant for nuclear matter?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basis-states">
     8.2. Basis states
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-17-determine-the-basis-states">
     8.3. Exercise 17: Determine the basis states
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-18-how-large-should-the-basis-be">
     8.4. Exercise 18: How large should the basis be?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-19-determine-the-lowest-few-magic-numbers-for-a-cubic-lattice">
     8.5. Exercise 19: Determine the lowest few magic numbers for a cubic lattice.
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finite-size-effects">
     8.6. Finite size effects
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#channel-structure-of-hamiltonian-and-cluster-amplitudes">
     8.7. Channel structure of Hamiltonian and cluster amplitudes
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-channel-structure-and-its-usage">
     8.8. Example: Channel structure and its usage
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-20-write-a-ccd-code-for-neutron-matter-focusing-first-on-ladder-approximation-i-e-including-the-first-five-diagrams-in-figure-11">
     8.9. Exercise 20: Write a CCD code for neutron matter, focusing first on ladder approximation, i.e. including the first five diagrams in Figure 11.
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#benchmarks-with-the-minnesota-potential">
     8.10. Benchmarks with the Minnesota potential
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#from-structure-to-reactions">
   9. From Structure to Reactions
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#electroweak-reactions">
     9.1. Electroweak reactions
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-optical-potentials-from-microscopic-input">
     9.2. Computing optical potentials from microscopic input
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <!-- HTML file automatically generated from DocOnce source (https://github.com/doconce/doconce/)
doconce format html cc.do.txt  --><div class="tex2jax_ignore mathjax_ignore section" id="the-coupled-cluster-method">
<h1><span class="section-number">7. </span>The Coupled Cluster Method<a class="headerlink" href="#the-coupled-cluster-method" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2><span class="section-number">7.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The coupled-cluster method is an efficient tool to compute atomic
nuclei with an effort that grows polynomial with system size. While
this might still be expensive, it is now possible to compute nuclei
with mass numbers about <span class="math notranslate nohighlight">\(A\approx 100\)</span> with this method. Recall that
full configuration interaction (FCI) such as the no-core shell model
exhibits an exponential cost and is therefore limited to light nuclei.</p>
<!-- dom:FIGURE: [figslides/Explosion.png, width=400 frac=0.8] Realistic computations of atomic nuclei with interactions from chiral EFT. The slow increase prior to 2015 is based on quantum Monte Carlo and the no-core shell model. These methods are exponentially expensive (in mass number $A$) and meet with exponentially increasing computer power (Moore's law), thus leading to a progress that is linear in time. Methods such as coupled clusters and in-medium SRG carry a polynomial cost in mass number are transforming the field. <div id="fig-explosion"></div> -->
<!-- begin figure -->
<div id="fig-explosion"></div>
<p><img src="figslides/Explosion.png" width="400"><p style="font-size: 0.9em"><i>Figure 1: Realistic computations of atomic nuclei with interactions from chiral EFT. The slow increase prior to 2015 is based on quantum Monte Carlo and the no-core shell model. These methods are exponentially expensive (in mass number <span class="math notranslate nohighlight">\(A\)</span>) and meet with exponentially increasing computer power (Moore’s law), thus leading to a progress that is linear in time. Methods such as coupled clusters and in-medium SRG carry a polynomial cost in mass number are transforming the field.</i></p></p>
<!-- end figure --></div>
<div class="section" id="the-normal-ordered-hamiltonian">
<h2><span class="section-number">7.2. </span>The normal-ordered Hamiltonian<a class="headerlink" href="#the-normal-ordered-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>We start from the reference state</p>
<!-- Equation labels as ordinary links -->
<div id="HFref"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{HFref} \tag{1}
\vert\Phi_0\rangle = \prod_{i=1}^A a^\dagger_i \vert 0\rangle 
\end{equation}
\]</div>
<p>for the description of a nucleus with mass number <span class="math notranslate nohighlight">\(A\)</span>.  Usually, this
reference is the Hartree-Fock state, but that is not necessary. In the
shell-model picture, it could also be a product state where the lowest
<span class="math notranslate nohighlight">\(A\)</span> harmonic oscillator states are occupied.  Here and in what
follows, the indices <span class="math notranslate nohighlight">\(i,j,k,\ldots\)</span> run over hole states,
i.e. orbitals occupied in the reference state (<a class="reference external" href="#HFref">1</a>), while
<span class="math notranslate nohighlight">\(a,b,c,\ldots\)</span> run over particle states, i.e. unoccupied
orbitals. Indices <span class="math notranslate nohighlight">\(p,q,r,s\)</span> can identify any orbital.  Let <span class="math notranslate nohighlight">\(n_u\)</span> be
the number of unoccupied states, and <span class="math notranslate nohighlight">\(A\)</span> is of course the number of
occupied states. We consider the Hamiltonian</p>
<!-- Equation labels as ordinary links -->
<div id="Ham"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Ham} \tag{2} H =
\sum_{pq} \varepsilon^p_q a^\dagger_p a_q +
\frac{1}{4}\sum_{pqrs}\langle pq\vert V\vert rs\rangle
a^\dagger_pa^\dagger_q a_sa_r
\end{equation}
\]</div>
<p>The reference state (<a class="reference external" href="#HFref">1</a>) is a non-trivial vacuum of our theory.
We normal order this Hamiltonian with respect to the nontrivial vacuum
state given by the Hartree-Fock reference and obtain the
normal-ordered Hamiltonian</p>
<!-- Equation labels as ordinary links -->
<div id="HN"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{HN} \tag{3}
H_N = \sum_{pq} f_{pq} \left\{a^\dagger_p a_q\right\} + \frac{1}{4}\sum_{pqrs}\langle pq\vert V\vert rs\rangle \left\{a^\dagger_pa^\dagger_q a_sa_r\right\}.
\end{equation}
\]</div>
<p>Here,</p>
<!-- Equation labels as ordinary links -->
<div id="Fock"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Fock} \tag{4}
f^p_q = \varepsilon^p_q + \sum_i \langle pi\vert V\vert qi\rangle
\end{equation}
\]</div>
<p>is the Fock matrix. We note that the Fock matrix is diagonal in the
Hartree-Fock basis. The brackets <span class="math notranslate nohighlight">\(\{\cdots\}\)</span> in Eq. (<a class="reference external" href="#HN">3</a>) denote
normal ordering, i.e. all operators that annihilate the nontrivial
vaccum (<a class="reference external" href="#HFref">1</a>) are to the right of those operators that create
with respect to that vaccum. Normal ordering implies that <span class="math notranslate nohighlight">\(\langle
\Phi_0\vert H_N\vert \Phi_0\rangle = 0\)</span>.</p>
</div>
<div class="section" id="exercise-1-practice-in-normal-ordering">
<h2><span class="section-number">7.3. </span>Exercise 1: Practice in normal ordering<a class="headerlink" href="#exercise-1-practice-in-normal-ordering" title="Permalink to this headline">¶</a></h2>
<div id="ex-1"></div>
<p>Normal order the expression <span class="math notranslate nohighlight">\(\sum\limits_{pq}\varepsilon_q^p a^\dagger_p a_q\)</span>.</p>
<!-- --- begin hint in exercise --- -->
<p><strong>Hint.</strong></p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{pq}\varepsilon_q^p a^\dagger_p a_q
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a   
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\label{_auto1} \tag{5}
\end{equation}
\]</div>
<!-- --- end hint in exercise --- -->
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
We have to move all operators that annihilate the reference state to the right of those that create on the reference state. Thus,</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{pq}\varepsilon_q^p a^\dagger_p a_q
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\label{_auto2} \tag{6}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i \left(-a_ja^\dagger_i +\delta_i^j\right)
\label{_auto3} \tag{7}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
-\sum_{ij}\varepsilon_j^i a_ja^\dagger_i +\sum_i \varepsilon_i^i
\label{_auto4} \tag{8}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
=\sum_{pq}\varepsilon_q^p \left\{a^\dagger_p a_q\right\} +\sum_i \varepsilon_i^i
\label{_auto5} \tag{9}
\end{equation}
\]</div>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>We note that <span class="math notranslate nohighlight">\(H = E_{HF} + H_N\)</span>, where</p>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E_{HF} \equiv \langle\Phi_0\vert H\vert \Phi_0\rangle = \sum_{i} \varepsilon^i_i +\frac{1}{2}\sum_{ij}\langle ij\vert V\vert ij\rangle
\label{_auto6} \tag{10}
\end{equation}
\]</div>
<p>is the Hartree-Fock energy.
The coupled-cluster method is a very efficient tool to compute nuclei
when a “good” reference state is available. Let us assume that the
reference state results from a Hartree-Fock calculation.</p>
</div>
<div class="section" id="exercise-2-what-does-good-mean">
<h2><span class="section-number">7.4. </span>Exercise 2: What does “good” mean?<a class="headerlink" href="#exercise-2-what-does-good-mean" title="Permalink to this headline">¶</a></h2>
<div id="ex-2"></div>
<p>How do you know whether a Hartree-Fock state is a “good” reference?
Which results of the Hartree-Fock computation will inform you?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
Once the Hartree-Fock equations are solved, the Fock matrix
(<a class="reference external" href="#Fock">4</a>) becomes diagonal, and its diagonal elements can be viewed
as single-particle energies. Hopefully, there is a clear gap in the
single-particle spectrum at the Fermi surface, i.e. after <span class="math notranslate nohighlight">\(A\)</span> orbitals
are filled.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>If symmetry-restricted Hartree-Fock is used, one is limited to compute
nuclei with closed subshells for neutrons and for protons. On a first
view, this might seem as a severe limitation. But is it?</p>
</div>
<div class="section" id="exercise-3-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields">
<h2><span class="section-number">7.5. </span>Exercise 3: How many nuclei are accessible with the coupled cluster method based on spherical mean fields?<a class="headerlink" href="#exercise-3-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields" title="Permalink to this headline">¶</a></h2>
<div id="ex-3"></div>
<p>If one limits oneself to nuclei with mass number up to
mass number <span class="math notranslate nohighlight">\(A=60\)</span>, how many nuclei can potentially be described with
the coupled-cluster method? Which of these nuclei are potentially
interesting? Why?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
Nuclear shell closures are at <span class="math notranslate nohighlight">\(N,Z=2,8,20,28,50,82,126\)</span>, and subshell
closures at <span class="math notranslate nohighlight">\(N,Z=2,6,8,14,16,20,28,32,34,40,50,\ldots\)</span>.</p>
<p>In the physics of nuclei, the evolution of nuclear structure as
neutrons are added (or removed) from an isotope is a key</p>
<!-- interest. Examples are the rare isotopes of helium ($^{8,10}$ He) -->
<!-- oxygen ($^{22,24,28}$ O), calcium ($^{52,54,60}$ Ca), nickel ($^{78}$ -->
<!-- Ni) and tin ($^{100,132}$ Sn). The coupled-cluster method has the -->
<p>interest. Examples are the rare isotopes of helium (He-8,10)
oxygen (O-22,24,28), calcium (Ca-52,54,60), nickel (Ni-78) and tin
(Sn-100,132). The coupled-cluster method has the
potential to address questions regarding these nuclei, and in a
several cases was used to make predictions before experimental data
was available. In addition, the method can be used to compute
neighbors of nuclei with closed subshells.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
</div>
<div class="section" id="the-similarity-transformed-hamiltonian">
<h2><span class="section-number">7.6. </span>The similarity transformed Hamiltonian<a class="headerlink" href="#the-similarity-transformed-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>There are several ways to view and understand the coupled-cluster
method. A first simple view of coupled-cluster theory is that the
method induces correlations into the reference state by expressing a
correlated state as</p>
<!-- Equation labels as ordinary links -->
<div id="psi"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{psi} \tag{11}
\vert\Psi\rangle = e^T \vert\Phi_0\rangle ,
\end{equation}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(T\)</span> is an operator that induces correlations. We can now demand
that the correlate state (<a class="reference external" href="#psi">11</a>) becomes and eigenstate of the
Hamiltonian <span class="math notranslate nohighlight">\(H_N\)</span>, i.e.  <span class="math notranslate nohighlight">\(H_N\vert \Psi\rangle = E\vert \Psi\rangle\)</span>. This view,
while correct, is not the most productive one.  Instead, we
left-multiply the Schroedinger equation with <span class="math notranslate nohighlight">\(e^{-T}\)</span> and find</p>
<!-- Equation labels as ordinary links -->
<div id="Schroedinger"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Schroedinger} \tag{12}
\overline{H_N}\vert \Phi_0\rangle = E_c \vert \Phi_0\rangle . 
\end{equation}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(E_c\)</span> is the correlation energy, and the total energy is
<span class="math notranslate nohighlight">\(E=E_c+E_{HF}\)</span>.  The similarity-transformed Hamiltonian is defined as</p>
<!-- Equation labels as ordinary links -->
<div id="Hsim"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Hsim} \tag{13}
\overline{H_N} \equiv e^{-T} H_N e^T .
\end{equation}
\]</div>
<p>A more productive view on coupled-cluster theory thus emerges: This
method seeks a similarity transformation such that the uncorrelated
reference state (<a class="reference external" href="#HFref">1</a>) becomes an exact eigenstate of the
similarity-transformed Hamiltonian (<a class="reference external" href="#Hsim">13</a>).</p>
</div>
<div class="section" id="exercise-4-what-t-leads-to-hermitian-overline-h-n">
<h2><span class="section-number">7.7. </span>Exercise 4: What <span class="math notranslate nohighlight">\(T\)</span> leads to Hermitian <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> ?<a class="headerlink" href="#exercise-4-what-t-leads-to-hermitian-overline-h-n" title="Permalink to this headline">¶</a></h2>
<div id="ex-4"></div>
<p>What are the conditions on <span class="math notranslate nohighlight">\(T\)</span> such that <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> is Hermitian?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
For a Hermitian <span class="math notranslate nohighlight">\(\overline{H_N}\)</span>, we need a unitary <span class="math notranslate nohighlight">\(e^T\)</span>, i.e. an
anti-Hermitian <span class="math notranslate nohighlight">\(T\)</span> with <span class="math notranslate nohighlight">\(T = -T^\dagger\)</span></p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>As we will see below, coupld-cluster theory employs a non-Hermitian Hamiltonian.</p>
</div>
<div class="section" id="exercise-5-understanding-non-unitary-similarity-transformations">
<h2><span class="section-number">7.8. </span>Exercise 5: Understanding (non-unitary) similarity transformations<a class="headerlink" href="#exercise-5-understanding-non-unitary-similarity-transformations" title="Permalink to this headline">¶</a></h2>
<div id="ex-5"></div>
<p>Show that <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> has the same eigenvalues as <span class="math notranslate nohighlight">\(H_N\)</span> for
arbitrary <span class="math notranslate nohighlight">\(T\)</span>. What is the spectral decomposition of a non-Hermitian
<span class="math notranslate nohighlight">\(\overline{H_N}\)</span> ?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
Let <span class="math notranslate nohighlight">\(H_N\vert E\rangle = E\vert E\rangle\)</span>. Thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
H_N e^{T} e^{-T} \vert E\rangle &amp;= E\vert E\rangle , \\
\left(e^{-T} H_N e^T\right) e^{-T} \vert E\rangle &amp;= Ee^{-T} \vert E\rangle , \\
\overline{H_N} e^{-T} \vert E\rangle &amp;= E e^{-T}\vert E\rangle .
\end{align*}
\end{split}\]</div>
<p>Thus, if <span class="math notranslate nohighlight">\(\vert E\rangle\)</span> is an eigenstate of <span class="math notranslate nohighlight">\(H_N\)</span> with eigenvalue <span class="math notranslate nohighlight">\(E\)</span>,
then <span class="math notranslate nohighlight">\(e^{-T}\vert E\rangle\)</span> is eigenstate of <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> with the same
eigenvalue.</p>
<p>A non-Hermitian <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> has eigenvalues <span class="math notranslate nohighlight">\(E_\alpha\)</span>
corresponding to left <span class="math notranslate nohighlight">\(\langle L_\alpha\vert \)</span> and right <span class="math notranslate nohighlight">\(\vert R_\alpha
\rangle\)</span> eigenstates. Thus</p>
<!-- Equation labels as ordinary links -->
<div id="_auto7"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{H_N} = \sum_\alpha \vert R_\alpha\rangle E_\alpha \langle L_\alpha \vert 
\label{_auto7} \tag{14}
\end{equation}
\]</div>
<p>with bi-orthonormal <span class="math notranslate nohighlight">\(\langle L_\alpha\vert R_\beta\rangle = \delta_\alpha^\beta\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>To make progress, we have to specify the cluster operator <span class="math notranslate nohighlight">\(T\)</span>. In
coupled cluster theory, this operator is</p>
<!-- Equation labels as ordinary links -->
<div id="Top"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Top} \tag{15}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i + \cdots
+ \frac{1}{(A!)^2}\sum_{i_1\ldots i_A a_1 \ldots a_A}
t_{i_1\ldots i_A}^{a_1\ldots a_A} a^\dagger_{a_1}\cdots a^\dagger_{a_A} a_{i_A}\cdots a_{i_1} .
\end{equation}
\]</div>
<p>Thus, the operator (<a class="reference external" href="#Top">15</a>) induces particle-hole (p-h)
excitations with respect to the reference. In general, <span class="math notranslate nohighlight">\(T\)</span> generates
up to <span class="math notranslate nohighlight">\(Ap-Ah\)</span> excitations, and the unknown parameters are the cluster amplitides
<span class="math notranslate nohighlight">\(t_i^a\)</span>, <span class="math notranslate nohighlight">\(t_{ij}^{ab}\)</span>, …, <span class="math notranslate nohighlight">\(t_{i_1,\ldots,i_A}^{a_1,\ldots,a_A}\)</span>.</p>
</div>
<div class="section" id="exercise-6-how-many-unknowns">
<h2><span class="section-number">7.9. </span>Exercise 6: How many unknowns?<a class="headerlink" href="#exercise-6-how-many-unknowns" title="Permalink to this headline">¶</a></h2>
<div id="ex-6"></div>
<p>Show that the number of unknowns is as large as the FCI dimension of
the problem, using the numbers <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(n_u\)</span>.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
We have to sum up all <span class="math notranslate nohighlight">\(np-nh\)</span> excitations, and there are
<span class="math notranslate nohighlight">\(\binom{n_u}{n}\)</span> particle states and <span class="math notranslate nohighlight">\(\binom{A}{A-n}\)</span> hole states for
each <span class="math notranslate nohighlight">\(n\)</span>. Thus, we have for the total number</p>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\sum_{n=0}^A \binom{n_u}{n} \binom{A}{A-n}= \binom{A+n_u}{A} .
\label{_auto8} \tag{16}
\end{equation}
\]</div>
<p>The right hand side are obviously all ways to distribute <span class="math notranslate nohighlight">\(A\)</span> fermions over <span class="math notranslate nohighlight">\(n_0+A\)</span> orbitals.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Thus, the coupled-cluster method with the full cluster operator
(<a class="reference external" href="#Top">15</a>) is exponentially expensive, just as FCI. To make progress,
we need to make an approximation by truncating the operator. Here, we
will use the CCSD (coupled clusters singles doubles) approximation,
where</p>
<!-- Equation labels as ordinary links -->
<div id="Tccsd"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Tccsd} \tag{17}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i .
\end{equation}
\]</div>
<p>We need to determine the unknown cluster amplitudes that enter in CCSD. Let</p>
<!-- Equation labels as ordinary links -->
<div id="_auto9"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\vert\Phi_i^a\rangle = a^\dagger_a a_i \vert \Phi_0\rangle , 
\label{_auto9} \tag{18}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto10"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\vert\Phi_{ij}^{ab}\rangle = a^\dagger_a a^\dagger_b a_j a_i \vert \Phi_0\rangle
\label{_auto10} \tag{19}
\end{equation}
\]</div>
<p>be 1p-1h and 2p-2h excitations of the reference. Computing matrix
elements of the Schroedinger Equation (<a class="reference external" href="#Schroedinger">12</a>) yields</p>
<!-- Equation labels as ordinary links -->
<div id="ccsd"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{ccsd} \tag{20}
\langle \Phi_0\vert \overline{H_N}\vert \Phi_0\rangle = E_c , 
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto11"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\langle \Phi_i^a\vert \overline{H_N}\vert \Phi_0\rangle = 0 , 
\label{_auto11} \tag{21}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto12"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\langle \Phi_{ij}^{ab}\vert \overline{H_N}\vert \Phi_0\rangle = 0 .
\label{_auto12} \tag{22}
\end{equation}
\]</div>
<p>The first equation states that the coupled-cluster correlation energy
is an expectation value of the similarity-transformed Hamiltonian. The
second and third equations state that the similarity-transformed
Hamiltonian exhibits no 1p-1h and no 2p-2h excitations. These
equations have to be solved to find the unknown amplitudes <span class="math notranslate nohighlight">\(t_i^a\)</span> and
<span class="math notranslate nohighlight">\(t_{ij}^{ab}\)</span>. Then one can use these amplitudes and compute the
correlation energy from the first line of Eq. (<a class="reference external" href="#ccsd">20</a>).</p>
<p>We note that in the CCSD approximation the reference state is not an
exact eigenstates. Rather, it is decoupled from simple states but
<span class="math notranslate nohighlight">\(\overline{H}\)</span> still connects this state to 3p-3h, and 4p-4h states
etc.</p>
<p>At this point, it is important to recall that we assumed starting from
a “good” reference state. In such a case, we might reasonably expect
that the inclusion of 1p-1h and 2p-2h excitations could result in an
accurate approximation. Indeed, empirically one finds that CCSD
accounts for about 90% of the corelation energy, i.e. of the
difference between the exact energy and the Hartree-Fock energy. The
inclusion of triples (3p-3h excitations) typically yields 99% of the
correlation energy.</p>
<p>We see that the coupled-cluster method in its CCSD approximation
yields a similarity-transformed Hamiltonian that is of a two-body
structure with respect to a non-trivial vacuum. When viewed in this
light, the coupled-cluster method “transforms” an <span class="math notranslate nohighlight">\(A\)</span>-body problem
(in CCSD) into a two-body problem, albeit with respect to a nontrivial
vacuum.</p>
</div>
<div class="section" id="exercise-7-why-is-ccd-not-exact">
<h2><span class="section-number">7.10. </span>Exercise 7: Why is CCD not exact?<a class="headerlink" href="#exercise-7-why-is-ccd-not-exact" title="Permalink to this headline">¶</a></h2>
<div id="ex-6b"></div>
<p>Above we argued that a similarity transformation preserves all eigenvalues. Nevertheless, the CCD correlation energy is not the exact correlation energy. Explain!</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
The CCD approximation does not make <span class="math notranslate nohighlight">\(\vert\Phi_0\rangle\)</span> an exact
eigenstate of <span class="math notranslate nohighlight">\(\overline{H_N}\)</span>; it is only an eigenstate when the
similarity-transformed Hamiltonian is truncated to at most 2p-2h
states. The full <span class="math notranslate nohighlight">\(\overline{H_N}\)</span>, with <span class="math notranslate nohighlight">\(T=T_2\)</span>, would involve
six-body terms (do you understand this?), and this full Hamiltonian
would reproduce the exact correlation energy. Thus CCD is a similarity
transformation plus a truncation, which decouples the ground state only
from 2p-2h states.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
</div>
<div class="section" id="computing-the-similarity-transformed-hamiltonian">
<h2><span class="section-number">7.11. </span>Computing the similarity-transformed Hamiltonian<a class="headerlink" href="#computing-the-similarity-transformed-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>The solution of the CCSD equations, i.e. the second and third line of
Eq. (<a class="reference external" href="#ccsd">20</a>), and the computation of the correlation energy
requires us to compute matrix elements of the similarity-transformed
Hamiltonian (<a class="reference external" href="#Hsim">13</a>). This can be done with the
Baker-Campbell-Hausdorff expansion</p>
<!-- Equation labels as ordinary links -->
<div id="BCH"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{BCH} \tag{23}
\overline{H_N} = e^{-T} H_N e^T 
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto13"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
=H_N + \left[ H_N, T\right]+ \frac{1}{2!}\left[ \left[ H_N, T\right], T\right]
+ \frac{1}{3!}\left[\left[ \left[ H_N, T\right], T\right], T\right] +\ldots .
\label{_auto13} \tag{24}
\end{equation}
\]</div>
<p>We now come to a key element of coupled-cluster theory: the cluster
operator (<a class="reference external" href="#Top">15</a>) consists of sums of terms that consist of particle
creation and hole annihilation operators (but no particle annihilation
or hole creation operators). Thus, all terms that enter <span class="math notranslate nohighlight">\(T\)</span> commute
with each other. This means that the commutators in the
Baker-Campbell-Hausdorff expansion (<a class="reference external" href="#BCH">23</a>) can only be non-zero
because each <span class="math notranslate nohighlight">\(T\)</span> must connect to <span class="math notranslate nohighlight">\(H_N\)</span> (but no <span class="math notranslate nohighlight">\(T\)</span> with another
<span class="math notranslate nohighlight">\(T\)</span>). Thus, the expansion is finite.</p>
</div>
<div class="section" id="exercise-8-when-does-ccsd-truncate">
<h2><span class="section-number">7.12. </span>Exercise 8: When does CCSD truncate?<a class="headerlink" href="#exercise-8-when-does-ccsd-truncate" title="Permalink to this headline">¶</a></h2>
<div id="ex-7"></div>
<p>In CCSD and for two-body Hamiltonians, how many nested
commutators yield nonzero results? Where does the
Baker-Campbell-Hausdorff expansion terminate? What is the (many-body) rank of the resulting <span class="math notranslate nohighlight">\(\overline{H_N}\)</span>?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
CCSD truncates for two-body operators at four-fold nested commutators,
because each of the four annihilation and creation operators in
<span class="math notranslate nohighlight">\(\overline{H_N}\)</span> can be knocked out with one term of <span class="math notranslate nohighlight">\(T\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>We see that the (disadvantage of having a) non-Hermitian Hamiltonian
<span class="math notranslate nohighlight">\(\overline{H_N}\)</span> leads to the advantage that the
Baker-Campbell-Hausdorff expansion is finite, thus leading to the
possibility to compute <span class="math notranslate nohighlight">\(\overline{H_N}\)</span> exactly. In contrast, the
IMSRG deals with a Hermitian Hamiltonian throughout, and the infinite
Baker-Campbell-Hausdorff expansion is truncated at a high order when
terms become very small.</p>
<p>We write the similarity-transformed Hamiltonian as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto14"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{H_N}=\sum_{pq} \overline{H}^p_q a^\dagger_q a_p + {1\over 4} \sum_{pqrs} \overline{H}^{pq}_{rs} a^\dagger_p a^\dagger_q a_s a_r + \ldots
\label{_auto14} \tag{25}
\end{equation}
\]</div>
<p>with</p>
<!-- Equation labels as ordinary links -->
<div id="_auto15"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{H}^p_q \equiv \langle p\vert \overline{H_N}\vert q\rangle , 
\label{_auto15} \tag{26}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto16"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\overline{H}^{pq}_{rs} \equiv \langle pq\vert \overline{H_N}\vert rs\rangle .
\label{_auto16} \tag{27}
\end{equation}
\]</div>
<p>Thus, the CCSD Eqs. (<a class="reference external" href="#ccsd">20</a>) for the amplitudes can be written as
<span class="math notranslate nohighlight">\(\overline{H}_i^a = 0\)</span> and <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}=0\)</span>.</p>
</div>
<div class="section" id="exercise-9-compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle">
<h2><span class="section-number">7.13. </span>Exercise 9: Compute the matrix element <span class="math notranslate nohighlight">\(\overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle\)</span><a class="headerlink" href="#exercise-9-compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle" title="Permalink to this headline">¶</a></h2>
<div id="ex-8"></div>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
This is a simple task. This matrix element is part of the operator
<span class="math notranslate nohighlight">\(\overline{H}_{ab}^{ij}a^\dagger_ia^\dagger_ja_ba_a\)</span>, i.e. particles
are annihilated and holes are created. Thus, no contraction of the
Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> with any cluster operator <span class="math notranslate nohighlight">\(T\)</span> (remember that <span class="math notranslate nohighlight">\(T\)</span>
annihilates holes and creates particles) can happen, and we simply
have <span class="math notranslate nohighlight">\(\overline{H}_{ab}^{ij} = \langle ij\vert V\vert ab\rangle\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>We need to work out the similarity-transformed Hamiltonian of
Eq. (<a class="reference external" href="#BCH">23</a>). To do this, we write <span class="math notranslate nohighlight">\(T=T_1 +T_2\)</span> and <span class="math notranslate nohighlight">\(H_N= F +V\)</span>,
where <span class="math notranslate nohighlight">\(T_1\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are one-body operators, and <span class="math notranslate nohighlight">\(T_2\)</span> and <span class="math notranslate nohighlight">\(V\)</span> are
two-body operators.</p>
</div>
<div class="section" id="example-the-contribution-of-f-t-2-to-overline-h-n">
<h2><span class="section-number">7.14. </span>Example: The contribution of <span class="math notranslate nohighlight">\([F, T_2]\)</span> to <span class="math notranslate nohighlight">\(\overline{H_N}\)</span><a class="headerlink" href="#example-the-contribution-of-f-t-2-to-overline-h-n" title="Permalink to this headline">¶</a></h2>
<div id="ex-9"></div>
<p>The commutator <span class="math notranslate nohighlight">\([F, T_2]\)</span> consists of two-body and one-body terms. Let
us compute first the two-body term, as it results from a single
contraction (i.e. a single application of <span class="math notranslate nohighlight">\([a_p, a^\dagger_q] =
\delta_p^q\)</span>). We denote this as <span class="math notranslate nohighlight">\([F, T_2]_{2b}\)</span> and find</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
[F, T_2]_{2b} &amp;= \frac{1}{4}\sum_{pq}\sum_{rsuv} f_p^q t_{ij}^{ab}\left[a^\dagger_q a_p, a^\dagger_a a^\dagger_b a_j a_i \right]_{2b} \\
&amp;= \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_p^a a^\dagger_q a^\dagger_b a_j a_i  \\
&amp;- \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_p^b a^\dagger_q a^\dagger_a a_j a_i  \\
&amp;- \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_q^j a^\dagger_a a^\dagger_b a_p a_i  \\
&amp;+ \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_q^i a^\dagger_a a^\dagger_b a_p a_j  \\
&amp;= \frac{1}{4}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&amp;- \frac{1}{4}\sum_{qaij}\left(\sum_{b} f_b^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_a a_j a_i  \\
&amp;- \frac{1}{4}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  \\
&amp;+ \frac{1}{4}\sum_{pabj}\left(\sum_{i} f_p^i t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_j  \\
&amp;= \frac{1}{2}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&amp;- \frac{1}{2}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
\end{split}\]</div>
<p>Here we exploited the antisymmetry <span class="math notranslate nohighlight">\(t_{ij}^{ab} = -t_{ji}^{ab} =
-t_{ij}^{ba} = t_{ji}^{ba}\)</span> in the last step. Using <span class="math notranslate nohighlight">\(a^\dagger_q a^\dagger_b a_j a_i = -a^\dagger_b a^\dagger_q a_j a_i \)</span> and <span class="math notranslate nohighlight">\(a^\dagger_a a^\dagger_b a_p a_i = a^\dagger_a a^\dagger_b a_i a_p\)</span>, we can make the expression
manifest antisymmetric, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
[F, T_2]_{2b}
&amp;= \frac{1}{4}\sum_{qbij}\left[\sum_{a} \left(f_a^q t_{ij}^{ab}-f_a^b t_{ij}^{qa}\right)\right]a^\dagger_q a^\dagger_b a_j a_i  \\
&amp;- \frac{1}{4}\sum_{pabi}\left[\sum_{j} \left(f_p^j t_{ij}^{ab}-f_i^j t_{pj}^{ab}\right)\right]a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
\end{split}\]</div>
<p>Thus, the contribution of <span class="math notranslate nohighlight">\([F, T_2]_{2b}\)</span> to the matrix element <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span> is</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
\overline{H}_{ij}^{ab} \leftarrow  \sum_{c} \left(f_c^a t_{ij}^{cb}-f_c^b t_{ij}^{ac}\right) - \sum_{k} \left(f_j^k t_{ik}^{ab}-f_i^k t_{jk}^{ab}\right)
\end{align*}
\]</div>
<p>Here we used an arrow to indicate that this is just one contribution
to this matrix element.  We see that the derivation straight forward,
but somewhat tedious. As no one likes to commute too much (neither in
this example nor when going to and from work), and so we need a better
approach. This is where diagramms come in handy.</p>
<p>===== =====</p>
<div class="section" id="diagrams">
<h3><span class="section-number">7.14.1. </span>Diagrams<a class="headerlink" href="#diagrams" title="Permalink to this headline">¶</a></h3>
<p>The pictures in this Subsection are taken from Crawford and Schaefer.</p>
<p>By convention, hole lines (labels <span class="math notranslate nohighlight">\(i, j, k,\ldots\)</span>) are pointing down.</p>
<!-- dom:FIGURE: [figslides/Diagram-i.png, height=120 frac=0.8] This is a hole line. <div id="fig-i"></div> -->
<!-- begin figure -->
<div id="fig-i"></div>
<p><img src="figslides/Diagram-i.png" height="120"><p style="font-size: 0.9em"><i>Figure 2: This is a hole line.</i></p></p>
<!-- end figure -->
<p>By convention, particle lines (labels <span class="math notranslate nohighlight">\(a, b, c,\ldots\)</span>) are pointing up.</p>
<!-- dom:FIGURE: [figslides/Diagram-a.png, height=120 frac=0.8] This is a particle line. <div id="fig-a"></div> -->
<!-- begin figure -->
<div id="fig-a"></div>
<p><img src="figslides/Diagram-a.png" height="120"><p style="font-size: 0.9em"><i>Figure 3: This is a particle line.</i></p></p>
<!-- end figure -->
<p>Let us look at the one-body operator of the normal-ordered Hamiltonian, i.e. Fock matrix. Its diagrams are as follows.</p>
<!-- dom:FIGURE: [figslides/Diagram-fab.png, height=120 frac=0.8] The diagrams corresponding to $f_a^b$. The dashed line with the 'X' denotes the interaction $F$ between the incoming and outgoing lines. The labels $a$ and $b$ are not denoted, but you should label the outgoing and incoming lines accordingly. <div id="fig-fab"></div> -->
<!-- begin figure -->
<div id="fig-fab"></div>
<p><img src="figslides/Diagram-fab.png" height="120"><p style="font-size: 0.9em"><i>Figure 4: The diagrams corresponding to <span class="math notranslate nohighlight">\(f_a^b\)</span>. The dashed line with the ‘X’ denotes the interaction <span class="math notranslate nohighlight">\(F\)</span> between the incoming and outgoing lines. The labels <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are not denoted, but you should label the outgoing and incoming lines accordingly.</i></p></p>
<!-- end figure -->
<!-- dom:FIGURE: [figslides/Diagram-fij.png, height=120 frac=0.8] The diagrams corresponding to $f_i^j$. The dashed line with the 'X' denotes the interaction $F$ between the incoming and outgoing lines. <div id="fig-fij"></div> -->
<!-- begin figure -->
<div id="fig-fij"></div>
<p><img src="figslides/Diagram-fij.png" height="120"><p style="font-size: 0.9em"><i>Figure 5: The diagrams corresponding to <span class="math notranslate nohighlight">\(f_i^j\)</span>. The dashed line with the ‘X’ denotes the interaction <span class="math notranslate nohighlight">\(F\)</span> between the incoming and outgoing lines.</i></p></p>
<!-- end figure -->
<!-- dom:FIGURE: [figslides/Diagram-fia.png, height=120 frac=0.8] The diagrams corresponding to $f_a^i$. The dashed line with the 'X' denotes the interaction $F$ between the incoming and outgoing lines. <div id="fig-fia"></div> -->
<!-- begin figure -->
<div id="fig-fia"></div>
<p><img src="figslides/Diagram-fia.png" height="120"><p style="font-size: 0.9em"><i>Figure 6: The diagrams corresponding to <span class="math notranslate nohighlight">\(f_a^i\)</span>. The dashed line with the ‘X’ denotes the interaction <span class="math notranslate nohighlight">\(F\)</span> between the incoming and outgoing lines.</i></p></p>
<!-- end figure -->
<!-- dom:FIGURE: [figslides/Diagram-fai.png, height=120 frac=0.8] The diagrams corresponding to $f_i^a$. The dashed line with the 'X' denotes the interaction $F$ between the incoming and outgoing lines. <div id="fig-fai"></div> -->
<!-- begin figure -->
<div id="fig-fai"></div>
<p><img src="figslides/Diagram-fai.png" height="120"><p style="font-size: 0.9em"><i>Figure 7: The diagrams corresponding to <span class="math notranslate nohighlight">\(f_i^a\)</span>. The dashed line with the ‘X’ denotes the interaction <span class="math notranslate nohighlight">\(F\)</span> between the incoming and outgoing lines.</i></p></p>
<!-- end figure -->
<p>We now turn to the two-body interaction. It is denoted as a horizontal
dashed line with incoming and outgoing lines attached to it. We start
by noting that the following diagrams of the interaction are all
related by permutation symmetry.</p>
<!-- dom:FIGURE: [figslides/Diagrams-symmetry.png, width=400 frac=0.8] The diagrams corresponding to $\langle ai\vert V\vert jb \rangle = - \langle ai\vert V\vert bj \rangle = -\langle ia\vert V\vert jb \rangle = \langle ia\vert V\vert bj\rangle$. <div id="fig-symmetry"></div> -->
<!-- begin figure -->
<div id="fig-symmetry"></div>
<p><img src="figslides/Diagrams-symmetry.png" width="400"><p style="font-size: 0.9em"><i>Figure 8: The diagrams corresponding to <span class="math notranslate nohighlight">\(\langle ai\vert V\vert jb \rangle = - \langle ai\vert V\vert bj \rangle = -\langle ia\vert V\vert jb \rangle = \langle ia\vert V\vert bj\rangle\)</span>.</i></p></p>
<!-- end figure --></div>
</div>
<div class="section" id="exercise-10-assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction">
<h2><span class="section-number">7.15. </span>Exercise 10: Assign the correct matrix element <span class="math notranslate nohighlight">\(\langle pq\vert V\vert rs\rangle\)</span> to each of the following diagrams of the interaction<a class="headerlink" href="#exercise-10-assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction" title="Permalink to this headline">¶</a></h2>
<div id="ex-10"></div>
<p>Remember: <span class="math notranslate nohighlight">\(\langle\rm{left-out, right-out}\vert V\vert \rm{left-in, right-in}\rangle\)</span>.</p>
<p><strong>a)</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-V1.png, width=400 frac=0.8] -->
<!-- begin figure -->
<p><img src="figslides/Diagrams-V1.png" width="400"><p style="font-size: 0.9em"><i>Figure 9: </i></p></p>
<!-- end figure -->
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
<span class="math notranslate nohighlight">\(\langle ab\vert V\vert cd\rangle + \langle ij\vert V\vert kl\rangle + \langle ia\vert V\vert bj\rangle\)</span></p>
<!-- --- end answer of exercise --- --><p><strong>b)</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-V2.png, width=400 frac=0.8] -->
<!-- begin figure -->
<p><img src="figslides/Diagrams-V2.png" width="400"><p style="font-size: 0.9em"><i>Figure 9: </i></p></p>
<!-- end figure -->
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
<span class="math notranslate nohighlight">\(\langle ai\vert V\vert bc\rangle + \langle ij\vert V\vert ka\rangle + \langle ab\vert V\vert ci\rangle\)</span></p>
<!-- --- end answer of exercise --- --><p><strong>c)</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-V3.png, width=400 frac=0.8] -->
<!-- begin figure -->
<p><img src="figslides/Diagrams-V3.png" width="400"><p style="font-size: 0.9em"><i>Figure 9: </i></p></p>
<!-- end figure -->
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
<span class="math notranslate nohighlight">\(\langle ia\vert V\vert jk\rangle + \langle ab\vert V\vert ij\rangle + \langle ij\vert V\vert ab\rangle\)</span></p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Finally, we have the following diagrams for the <span class="math notranslate nohighlight">\(T_1\)</span> and <span class="math notranslate nohighlight">\(T_2\)</span> amplitudes.</p>
<!-- dom:FIGURE: [figslides/Diagrams-T.png, width=400 frac=0.8] The horizontal full line is the cluster amplitude with incoming hole lines and outgoing particle lines as indicated. <div id="fig-T"></div> -->
<!-- begin figure -->
<div id="fig-T"></div>
<p><img src="figslides/Diagrams-T.png" width="400"><p style="font-size: 0.9em"><i>Figure 9: The horizontal full line is the cluster amplitude with incoming hole lines and outgoing particle lines as indicated.</i></p></p>
<!-- end figure -->
<p>We are now in the position to construct the diagrams of the
similarity-transformed Hamiltonian, keeping in mind that these
diagrams correspond to matrix elements of <span class="math notranslate nohighlight">\(\overline{H_N}\)</span>. The rules
are as follows.</p>
<ol class="simple">
<li><p>Write down all <em>topologically different</em> diagrams corresponding to the desired matrix element. Topologically different diagrams differ in the number and type of lines (particle or hole) that connect the Fock matrix <span class="math notranslate nohighlight">\(F\)</span> or the interaction <span class="math notranslate nohighlight">\(V\)</span> to the cluster amplitudes <span class="math notranslate nohighlight">\(T\)</span>, but not whether these connections are left or right (as those are related by antisymmetry). As an example, all diagrams in Fig. <a class="reference external" href="#fig-symmetry">fig-symmetry</a> are topologically identical, because they consist of incoming particle and hole lines and of outgoing particle and hole lines.</p></li>
<li><p>Write down the matrix elements that enter the diagram, and sum over all internal lines.</p></li>
<li><p>The overall sign is <span class="math notranslate nohighlight">\((-1)\)</span> to the power of [(number of hole lines) - (number of loops)].</p></li>
<li><p>Symmetry factor: For each pair of equivalent lines (i.e. lines that connect the same two operators) multiply with a factor <span class="math notranslate nohighlight">\(1/2\)</span>. For <span class="math notranslate nohighlight">\(n\)</span> identical vertices, multiply the algebraic expression by the symmery factor <span class="math notranslate nohighlight">\(1/n!\)</span> to account properly for the number of ways the diagram can be constructed.</p></li>
<li><p>Antisymmetrize the outgoing and incoming lines as necessary.</p></li>
</ol>
<p>Please note that this really works. You could derive these rules for
yourself from the commutations and factors that enter the
Baker-Campbell-Hausdorff expansion. The sign comes obviously from the
arrangement of creation and annilhilation operators, while the
symmetry factor stems from all the different ways, one can contract
the cluster operator with the normal-ordered Hamiltonian.</p>
</div>
<div class="section" id="example-ccsd-correlation-energy">
<h2><span class="section-number">7.16. </span>Example: CCSD correlation energy<a class="headerlink" href="#example-ccsd-correlation-energy" title="Permalink to this headline">¶</a></h2>
<div id="ex-11"></div>
The CCSD correlation energy, $E_c= \langle
\Phi_0\vert \overline{H_N}\vert \Phi_0\rangle$, is the first of the CCSD
equations ([20](#ccsd)). It is a vacuum expectation value and thus
consists of all diagrams with no external legs. There are three such diagrams:
<!-- dom:FIGURE: [figslides/Diagrams-E0.png, width=400 frac=0.8] Three diagrams enter for the CCSD correlation energy, i.e. all diagrams that leave no external legs. <div id="fig-E0"></div> -->
<!-- begin figure -->
<div id="fig-E0"></div>
<p><img src="figslides/Diagrams-E0.png" width="400"><p style="font-size: 0.9em"><i>Figure 10: Three diagrams enter for the CCSD correlation energy, i.e. all diagrams that leave no external legs.</i></p></p>
<!-- end figure -->
<p>The correponding algebraic expression is <span class="math notranslate nohighlight">\(E_c=\sum_{ia}f^i_a t_i^a +{1\over 4}\sum_{ijab} \langle ij\vert V\vert ab\rangle t_{ij}^{ab} + {1\over 2} \sum_{ijab} \langle ij\vert V\vert ab\rangle t_i^a t_j^b\)</span>.</p>
<p>The first algebraic expression is clear. We have one hole line and one
loop, giving it a positive sign. There are no equivalent lines or
vertices, giving it no symmetry factor. The second diagram has two
loops and two hole lines, again leading to a positive sign. We have a
pair of equivalent hole lines and a pair of equivalent particle lines,
each giving a symmetry factor of <span class="math notranslate nohighlight">\(1/2\)</span>. The third diagram has two
loops and two hole lines, again leading to a positive sign. We have
two indentical vertices (each connecting to a <span class="math notranslate nohighlight">\(T_1\)</span> in the same way)
and thus a symmetry factor <span class="math notranslate nohighlight">\(1/2\)</span>.</p>
<p>===== =====</p>
</div>
<div class="section" id="ccd-approximation">
<h2><span class="section-number">7.17. </span>CCD Approximation<a class="headerlink" href="#ccd-approximation" title="Permalink to this headline">¶</a></h2>
<p>In what follows, we will consider the coupled cluster doubles (CCD)
approximation. This approximation is valid in cases where the system
cannot exhibit any particle-hole excitations (such as nuclear matter
when formulated on a momentum-space grid) or for the pairing model (as
the pairing interactions only excites pairs of particles). In this
case <span class="math notranslate nohighlight">\(t_i^a=0\)</span> for all <span class="math notranslate nohighlight">\(i, a\)</span>, and <span class="math notranslate nohighlight">\(\overline{H}_i^a=0\)</span>. The CCD
approximation is also of some sort of leading order approximation in
the Hartree-Fock basis (as the Hartree-Fock Hamiltonian exhibits no
particle-hole excitations).</p>
</div>
<div class="section" id="exercise-11-derive-the-ccd-equations">
<h2><span class="section-number">7.18. </span>Exercise 11: Derive the CCD equations!<a class="headerlink" href="#exercise-11-derive-the-ccd-equations" title="Permalink to this headline">¶</a></h2>
<div id="ex-12"></div>
<p>Let us consider the matrix element <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>. Clearly,
it consists of all diagrams (i.e. all combinations of <span class="math notranslate nohighlight">\(T_2\)</span>, and a
single <span class="math notranslate nohighlight">\(F\)</span> or <span class="math notranslate nohighlight">\(V\)</span> that have two incoming hole lines and two outgoing
particle lines. Write down all these diagrams.</p>
<!-- --- begin hint in exercise --- -->
<p><strong>Hint.</strong>
Start systematically! Consider all combinations of <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(V\)</span> diagrams with 0, 1, and 2 cluster amplitudes <span class="math notranslate nohighlight">\(T_2\)</span>.</p>
<!-- --- end hint in exercise --- -->
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-CCD.png, width=400 frac=0.8] The diagrams for the $T_2$ equation, i.e. the matrix elements of $\overline{H}_{ij}^{ab}$. Taken from Baardsen et al (2013). <div id="fig-ccd"></div> -->
<!-- begin figure -->
<div id="fig-ccd"></div>
<p><img src="figslides/Diagrams-CCD.png" width="400"><p style="font-size: 0.9em"><i>Figure 11: The diagrams for the <span class="math notranslate nohighlight">\(T_2\)</span> equation, i.e. the matrix elements of <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>. Taken from Baardsen et al (2013).</i></p></p>
<!-- end figure -->
<p>The corresponding algebraic expression is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\overline{H}_{ij}^{ab} &amp;= \langle ab\vert V\vert ij\rangle + P(ab)\sum_c f_c^bt_{ij}^{ac} - P(ij)\sum_k f_j^k t_{ik}^{ab} \\
&amp;+ {1\over 2} \sum_{cd} \langle ab\vert V\vert cd\rangle t_{ij}^{cd}+ {1\over 2} \sum_{kl} \langle kl\vert V\vert ij\rangle t_{kl}^{ab} + P(ab)P(ij)\sum_{kc} \langle kb\vert V\vert cj \rangle t_{ik}^{ac} \\
&amp;+ {1\over 2} P(ij)P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}t_{lj}^{db} 
+ {1\over 2} P(ij)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}t_{lj}^{ab}\\
&amp;+ {1\over 2} P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}t_{ij}^{db}
+ {1\over 4} \sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}t_{kl}^{ab} . 
\end{align*}
\end{split}\]</div>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Let us now turn to the computational cost of a CCD computation.</p>
</div>
<div class="section" id="exercise-12-computational-scaling-of-ccd">
<h2><span class="section-number">7.19. </span>Exercise 12: Computational scaling of CCD<a class="headerlink" href="#exercise-12-computational-scaling-of-ccd" title="Permalink to this headline">¶</a></h2>
<div id="ex-13"></div>
<p>For each of the diagrams in Fig. <a class="reference external" href="#fig-ccd">fig-ccd</a> write down the
computational cost in terms of the number of occupied <span class="math notranslate nohighlight">\(A\)</span> and the
number of unoccupied <span class="math notranslate nohighlight">\(n_u\)</span> orbitals.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
The cost is <span class="math notranslate nohighlight">\(A^2 n_u^2\)</span>, <span class="math notranslate nohighlight">\(A^2 n_u^3\)</span>, <span class="math notranslate nohighlight">\(A^3 n_u^2\)</span>,
<span class="math notranslate nohighlight">\(A^2 n_u^4\)</span>, <span class="math notranslate nohighlight">\(A^4 n_u^2\)</span>, <span class="math notranslate nohighlight">\(A^3 n_u^3\)</span>,
<span class="math notranslate nohighlight">\(A^4 n_u^4\)</span>, <span class="math notranslate nohighlight">\(A^4 n_u^4\)</span>,
<span class="math notranslate nohighlight">\(A^4 n_u^4\)</span>, and <span class="math notranslate nohighlight">\(A^4 n_u^4\)</span> for the respective diagrams.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Note that <span class="math notranslate nohighlight">\(n_u\gg A\)</span> in general. In textbooks, one reads that CCD (and
CCSD) cost only <span class="math notranslate nohighlight">\(A^2n_u^4\)</span>. Our most expensive diagrams, however are
<span class="math notranslate nohighlight">\(A^4n_u^4\)</span>. What is going on?</p>
<p>To understand this puzzle, let us consider the last diagram of
Fig. <a class="reference external" href="#fig-ccd">fig-ccd</a>. We break up the computation into two steps,
computing first the intermediate</p>
<!-- Equation labels as ordinary links -->
<div id="_auto17"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\chi_{ij}^{kl}\equiv {1\over 2} \sum_{cd} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}
\label{_auto17} \tag{28}
\end{equation}
\]</div>
<p>at a cost of <span class="math notranslate nohighlight">\(A^4n_u^2\)</span>, and then</p>
<!-- Equation labels as ordinary links -->
<div id="_auto18"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
{1\over 2} \sum_{kl} \chi_{ij}^{kl} t_{kl}^{ab}  
\label{_auto18} \tag{29}
\end{equation}
\]</div>
<p>at a cost of <span class="math notranslate nohighlight">\(A^4n_u^2\)</span>. This is affordable. The price to pay is the
storage of the intermediate <span class="math notranslate nohighlight">\(\chi_{ij}^{kl}\)</span>, i.e. we traded
memory for computational cycles. This trick is known as
“factorization.”</p>
</div>
<div class="section" id="exercise-13-factorize-the-remaining-diagrams-of-the-ccd-equation">
<h2><span class="section-number">7.20. </span>Exercise 13: Factorize the remaining diagrams of the CCD equation<a class="headerlink" href="#exercise-13-factorize-the-remaining-diagrams-of-the-ccd-equation" title="Permalink to this headline">¶</a></h2>
<div id="ex-14"></div>
<p>Diagrams 7, 8, and 9 of Fig. <a class="reference external" href="#fig-ccd">fig-ccd</a> also need to be factorized.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
For diagram number 7, we compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto19"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\chi_{id}^{al}\equiv\sum_{kc} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}
\label{_auto19} \tag{30}
\end{equation}
\]</div>
<p>at a cost of <span class="math notranslate nohighlight">\(A^3 n_u^3\)</span> and then compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto20"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
{1\over 2} P(ij)P(ab) \sum_{ld} \chi_{id}^{al} t_{lj}^{db} 
\label{_auto20} \tag{31}
\end{equation}
\]</div>
<p>at the cost of <span class="math notranslate nohighlight">\(A^3 n_u^3\)</span>.</p>
<p>For diagram number 8, we compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto21"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\chi_{i}^{l}\equiv -{1\over 2} \sum_{kcd} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}
\label{_auto21} \tag{32}
\end{equation}
\]</div>
<p>at a cost of <span class="math notranslate nohighlight">\(A^3 n_u^2\)</span>, and then compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto22"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
-P(ij) \sum_l \chi_i^l t_{lj}^{ab}
\label{_auto22} \tag{33}
\end{equation}
\]</div>
<p>at the cost of <span class="math notranslate nohighlight">\(A^3 n_u^2\)</span>.</p>
<p>For diagram number 9, we compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto23"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\chi_d^a\equiv{1\over 2} \sum_{kcl} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}
\label{_auto23} \tag{34}
\end{equation}
\]</div>
<p>at a cost of <span class="math notranslate nohighlight">\(A^2 n_u^3\)</span> and then compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto24"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
P(ab)\sum_d \chi_d^a t_{ij}^{db}
\label{_auto24} \tag{35}
\end{equation}
\]</div>
<p>at the cost of <span class="math notranslate nohighlight">\(A^3 n_u^3\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>We are now ready, to derive the full CCSD equations, i.e. the matrix
elements of <span class="math notranslate nohighlight">\(\overline{H}_i^a\)</span> and <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>.</p>
</div>
<div class="section" id="project-14-optional-derive-the-ccsd-equations">
<h2><span class="section-number">7.21. </span>Project 14: (Optional) Derive the CCSD equations!<a class="headerlink" href="#project-14-optional-derive-the-ccsd-equations" title="Permalink to this headline">¶</a></h2>
<div id="ex-15"></div><p><strong>a)</strong>
Let us consider the matrix element <span class="math notranslate nohighlight">\(\overline{H}_i^a\)</span> first. Clearly, it consists of all diagrams (i.e. all combinations of <span class="math notranslate nohighlight">\(T_1\)</span>, <span class="math notranslate nohighlight">\(T_2\)</span>, and a single <span class="math notranslate nohighlight">\(F\)</span> or <span class="math notranslate nohighlight">\(V\)</span> that have an incoming hole line and an outgoing particle line. Write down all these diagrams.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-CCSD1.png, width=800 frac=0.8] The diagrams for the $T_1$ equation, i.e. the matrix elements of $\overline{H}_i^a$. Taken from Crawford and Schaefer. Here $\langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle$ and $f_{pq}\equiv f^p_q$. <div id="fig-CCSD1"></div> -->
<!-- begin figure -->
<div id="fig-CCSD1"></div>
<p><img src="figslides/Diagrams-CCSD1.png" width="800"><p style="font-size: 0.9em"><i>Figure 12: The diagrams for the <span class="math notranslate nohighlight">\(T_1\)</span> equation, i.e. the matrix elements of <span class="math notranslate nohighlight">\(\overline{H}_i^a\)</span>. Taken from Crawford and Schaefer. Here <span class="math notranslate nohighlight">\(\langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle\)</span> and <span class="math notranslate nohighlight">\(f_{pq}\equiv f^p_q\)</span>.</i></p></p>
<!-- end figure -->
<!-- --- end answer of exercise --- --><p><strong>b)</strong>
Let us now consider the matrix element <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>. Clearly, it consists of all diagrams (i.e. all combinations of <span class="math notranslate nohighlight">\(T_1\)</span>, <span class="math notranslate nohighlight">\(T_2\)</span>, and a single <span class="math notranslate nohighlight">\(F\)</span> or <span class="math notranslate nohighlight">\(V\)</span> that have two incoming hole lines and two outgoing particle lines. Write down all these diagrams and corresponding algebraic expressions.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong></p>
<!-- dom:FIGURE: [figslides/Diagrams-CCSD2.png, width=800 frac=0.8] The diagrams for the $T_2$ equation, i.e. the matrix elements of $\overline{H}_{ij}^{ab}$. Taken from Crawford and Schaefer. Here $\langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle$, $f_{pq}\equiv f^p_q$, and $P(ab) = 1 - (a\leftrightarrow b)$ antisymmetrizes. <div id="fig-CCSD2"></div> -->
<!-- begin figure -->
<div id="fig-CCSD2"></div>
<p><img src="figslides/Diagrams-CCSD2.png" width="800"><p style="font-size: 0.9em"><i>Figure 13: The diagrams for the <span class="math notranslate nohighlight">\(T_2\)</span> equation, i.e. the matrix elements of <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>. Taken from Crawford and Schaefer. Here <span class="math notranslate nohighlight">\(\langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle\)</span>, <span class="math notranslate nohighlight">\(f_{pq}\equiv f^p_q\)</span>, and <span class="math notranslate nohighlight">\(P(ab) = 1 - (a\leftrightarrow b)\)</span> antisymmetrizes.</i></p></p>
<!-- end figure -->
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>We can now turn to the solution of the coupled-cluster equations.</p>
</div>
<div class="section" id="solving-the-ccd-equations">
<h2><span class="section-number">7.22. </span>Solving the CCD equations<a class="headerlink" href="#solving-the-ccd-equations" title="Permalink to this headline">¶</a></h2>
<p>The CCD equations, depicted in Fig. <a class="reference external" href="#fig-ccd">fig-ccd</a>, are nonlinear in the
cluster amplitudes. How do we solve <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}=0\)</span>? We
subtract <span class="math notranslate nohighlight">\((f_a^a +f_b^b -f_i^i -f_j^j)t_{ij}^{ab}\)</span> from both sides of
<span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}=0\)</span> (because this term is contained in
<span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>) and find</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
(f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} &amp;= (f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} +\overline{H}_{ij}^{ab}
\end{align*}
\]</div>
<p>Dividing by <span class="math notranslate nohighlight">\((f_i^i +f_j^j -f_a^a -f_b^b)\)</span> yields</p>
<!-- Equation labels as ordinary links -->
<div id="iter"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
t_{ij}^{ab} = t_{ij}^{ab} + \frac{\overline{H}_{ij}^{ab}}{f_i^i +f_j^j -f_a^a -f_b^b}
\label{iter} \tag{36}
\end{equation}
\]</div>
<p>This equation is of the type <span class="math notranslate nohighlight">\(t=f(t)\)</span>, and we solve it by iteration,
i.e. we start with a guess <span class="math notranslate nohighlight">\(t_0\)</span> and iterate <span class="math notranslate nohighlight">\(t_{n+1}=f(t_n)\)</span>, and
hope that this will converge to a solution. We take the perturbative result</p>
<!-- Equation labels as ordinary links -->
<div id="pert"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{pert} \tag{37}
\left(t_{ij}^{ab}\right)_0 = \frac{\langle ab\vert V\vert ij\rangle}{f_i^i +f_j^j -f_a^a -f_b^b}
\end{equation}
\]</div>
<p>as a starting point, compute <span class="math notranslate nohighlight">\(\overline{H}_{ij}^{ab}\)</span>, and find a new
<span class="math notranslate nohighlight">\(t_{ij}^{ab}\)</span> from the right-hand side of Eq. (<a class="reference external" href="#iter">36</a>). We repeat
this process until the amplitudes (or the CCD energy) converge.</p>
</div>
<div class="section" id="ccd-for-the-pairing-hamiltonian">
<h2><span class="section-number">7.23. </span>CCD for the pairing Hamiltonian<a class="headerlink" href="#ccd-for-the-pairing-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>You learned about the pairing Hamiltonian earlier in this
school. Convince yourself that this Hamiltonian does not induce any
1p-1h excitations. Let us solve the CCD equations for this
problem. This consists of the following steps</p>
<ol class="simple">
<li><p>Write a function that compute the potential, i.e. it returns a four-indexed array (or tensor). We need <span class="math notranslate nohighlight">\(\langle ab\vert V\vert cd\rangle\)</span>, <span class="math notranslate nohighlight">\(\langle ij\vert V\vert kl\rangle\)</span>, and <span class="math notranslate nohighlight">\(\langle ab\vert V\vert ij\rangle\)</span>. Why is there no <span class="math notranslate nohighlight">\(\langle ab\vert V\vert id\rangle\)</span> or <span class="math notranslate nohighlight">\(\langle ai\vert V\vert jb\rangle\)</span> ?</p></li>
<li><p>Write a function that computes the Fock matrix, i.e. a two-indexed array. We only need <span class="math notranslate nohighlight">\(f_a^b\)</span> and <span class="math notranslate nohighlight">\(f_i^j\)</span>. Why?</p></li>
<li><p>Initialize the cluster amplitudes according to Eq. (<a class="reference external" href="#pert">37</a>), and solve Eq. (<a class="reference external" href="#iter">36</a>) by iteration. The cluster amplitudes <span class="math notranslate nohighlight">\(T_1\)</span> and <span class="math notranslate nohighlight">\(T_2\)</span> are two- and four-indexed arrays, respectively.</p></li>
</ol>
<p>Please note that the contraction of tensors (i.e. the summation over
common indices in products of tensors) is very user friendly and
elegant in python when <code class="docutils literal notranslate"><span class="pre">numpy.einsum</span></code> is used.</p>
</div>
<div class="section" id="project-15-solve-the-ccd-equations-for-the-pairing-problem">
<h2><span class="section-number">7.24. </span>Project 15: Solve the CCD equations for the pairing problem<a class="headerlink" href="#project-15-solve-the-ccd-equations-for-the-pairing-problem" title="Permalink to this headline">¶</a></h2>
<div id="ex-16"></div>
<p>The Hamiltonian is</p>
<!-- Equation labels as ordinary links -->
<div id="_auto25"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
H = \delta \sum_{p=1}^\Omega (p-1)\left(a^\dagger_{p+}a_{p+} + a^\dagger_{p-}a_{p-}\right)
-{g \over 2} \sum_{p, q=1}^\Omega a^\dagger_{p+}a^\dagger_{p-} a_{q-} a_{q+} .
\label{_auto25} \tag{38}
\end{equation}
\]</div>
<p>Check your results and reproduce Fig 8.5 and Table 8.12 from Lecture Notes in Physics 936.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
<a class="reference external" href="https://github.com/NuclearTalent/ManyBody2018/tree/master/doc/Programs/Python/PairingModel">Click for IPython notebook for FCI and CCD solutions</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Coupled clusters in CCD approximation</span>
<span class="c1">## Implemented for the pairing model of Lecture Notes in Physics 936, Chapter 8.</span>
<span class="c1">## Thomas Papenbrock, June 2018</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">init_pairing_v</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns potential matrices of the pairing model in three relevant channels</span>
<span class="sd">    </span>
<span class="sd">    param g: strength of the pairing interaction, as in Eq. (8.42)</span>
<span class="sd">    param pnum: number of particle states</span>
<span class="sd">    param hnum: number of hole states</span>
<span class="sd">    </span>
<span class="sd">    return v_pppp, v_pphh, v_hhhh: np.array(pnum,pnum,pnum,pnum), </span>
<span class="sd">                                   np.array(pnum,pnum,hnum,hnum), </span>
<span class="sd">                                   np.array(hnum,hnum,hnum,hnum), </span>
<span class="sd">                                   The interaction as a 4-indexed tensor in three channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_pppp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">))</span>
    <span class="n">v_pphh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">))</span>
    <span class="n">v_hhhh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">))</span>
    
    <span class="n">gval</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">g</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">v_pppp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
            <span class="n">v_pppp</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_pppp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_pppp</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
            
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">v_pphh</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
            <span class="n">v_pphh</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_pphh</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_pphh</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">v_hhhh</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
            <span class="n">v_hhhh</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_hhhh</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=-</span><span class="n">gval</span>
            <span class="n">v_hhhh</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">gval</span>
        
    <span class="k">return</span> <span class="n">v_pppp</span><span class="p">,</span> <span class="n">v_pphh</span><span class="p">,</span> <span class="n">v_hhhh</span>
    
    
<span class="k">def</span> <span class="nf">init_pairing_fock</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    initializes the Fock matrix of the pairing model</span>
<span class="sd">    </span>
<span class="sd">    param delta: Single-particle spacing, as in Eq. (8.41)</span>
<span class="sd">    param g: pairing strength, as in eq. (8.42)</span>
<span class="sd">    param pnum: number of particle states</span>
<span class="sd">    param hnum: number of hole states</span>
<span class="sd">    </span>
<span class="sd">    return f_pp, f_hh: The Fock matrix in two channels as numpy arrays np.array(pnum,pnum), np.array(hnum,hnum). </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1"># the Fock matrix for the pairing model. No f_ph needed, because we are in Hartree-Fock basis </span>
    <span class="n">deltaval</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span>
    <span class="n">gval</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">g</span>
    <span class="n">f_pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">))</span>
    <span class="n">f_hh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">f_hh</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">i</span>  <span class="p">]</span> <span class="o">=</span> <span class="n">deltaval</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">gval</span>
        <span class="n">f_hh</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaval</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">gval</span>
        
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">f_pp</span><span class="p">[</span><span class="n">a</span>  <span class="p">,</span><span class="n">a</span>  <span class="p">]</span> <span class="o">=</span> <span class="n">deltaval</span><span class="o">*</span><span class="p">(</span><span class="n">hnum</span><span class="o">+</span><span class="n">a</span><span class="p">)</span>
        <span class="n">f_pp</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaval</span><span class="o">*</span><span class="p">(</span><span class="n">hnum</span><span class="o">+</span><span class="n">a</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">f_pp</span><span class="p">,</span> <span class="n">f_hh</span>


<span class="k">def</span> <span class="nf">init_t2</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">f_hh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes t2 amlitudes as in MBPT2, see first equation on page 345</span>
<span class="sd">    </span>
<span class="sd">    param v_pphh: pairing tensor in pphh channel</span>
<span class="sd">    param f_pp:   Fock matrix in pp channel</span>
<span class="sd">    param f_hh:   Fock matrix in hh channel</span>
<span class="sd">    </span>
<span class="sd">    return t2: numpy array in pphh format, 4-indices tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_pp</span><span class="p">)</span>
    <span class="n">hnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_hh</span><span class="p">)</span>
    <span class="n">t2_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hnum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hnum</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pnum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pnum</span><span class="p">):</span>
                    <span class="n">t2_new</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_pphh</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_hh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">f_hh</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">f_pp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span><span class="o">-</span><span class="n">f_pp</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">t2_new</span>


<span class="c1"># CCD equations. Note that the &quot;-&gt;abij&quot; assignment is redundant, because indices are ordered alphabetically.</span>
<span class="c1"># Nevertheless, we retain it for transparency.</span>
<span class="k">def</span> <span class="nf">ccd_iter</span><span class="p">(</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">f_hh</span><span class="p">,</span><span class="n">t2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs one iteration of the CCD equations (8.34), using also intermediates for the nonliniar terms</span>
<span class="sd">    </span>
<span class="sd">    param v_pppp: pppp-channel pairing tensor, numpy array</span>
<span class="sd">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span class="sd">    param v_hhhh: hhhh-channel pairing tensor, numpy array</span>
<span class="sd">    param f_pp: Fock matrix in pp channel</span>
<span class="sd">    param f_hh: Fock matrix in hh channel</span>
<span class="sd">    param t2: Initial t2 amplitude, tensor in form of pphh channel</span>
<span class="sd">    </span>
<span class="sd">    return t2_new: new t2 amplitude, tensor in form of pphh channel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_pp</span><span class="p">)</span>
    <span class="n">hnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_hh</span><span class="p">)</span>
    <span class="n">Hbar_pphh</span> <span class="o">=</span> <span class="p">(</span>  <span class="n">v_pphh</span> 
                 <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bc,acij-&gt;abij&#39;</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> 
                 <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ac,bcij-&gt;abij&#39;</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> 
                 <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abik,kj-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">f_hh</span><span class="p">)</span>
                 <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abjk,ki-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">f_hh</span><span class="p">)</span>
                 <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abcd,cdij-&gt;abij&#39;</span><span class="p">,</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> 
                 <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abkl,klij-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="c1"># hh intermediate, see (8.47)</span>
    <span class="n">chi_hh</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;cdkl,cdjl-&gt;kj&#39;</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>

    <span class="n">Hbar_pphh</span> <span class="o">=</span> <span class="n">Hbar_pphh</span> <span class="o">-</span> <span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abik,kj-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">chi_hh</span><span class="p">)</span> 
                             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abik,kj-&gt;abji&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">chi_hh</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># pp intermediate, see (8.46)</span>
    <span class="n">chi_pp</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;cdkl,bdkl-&gt;cb&#39;</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>

    <span class="n">Hbar_pphh</span> <span class="o">=</span> <span class="n">Hbar_pphh</span> <span class="o">+</span> <span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;acij,cb-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">chi_pp</span><span class="p">)</span> 
                             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;acij,cb-&gt;baij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">chi_pp</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># hhhh intermediate, see (8.48)</span>
    <span class="n">chi_hhhh</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;cdkl,cdij-&gt;klij&#39;</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>

    <span class="n">Hbar_pphh</span> <span class="o">=</span> <span class="n">Hbar_pphh</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abkl,klij-&gt;abij&#39;</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">chi_hhhh</span><span class="p">)</span>

    <span class="c1"># phph intermediate, see (8.49)</span>
    <span class="n">chi_phph</span><span class="o">=</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;cdkl,dblj-&gt;bkcj&#39;</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>


    <span class="n">Hbar_pphh</span> <span class="o">=</span> <span class="n">Hbar_pphh</span> <span class="o">+</span> <span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bkcj,acik-&gt;abij&#39;</span><span class="p">,</span><span class="n">chi_phph</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
                             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bkcj,acik-&gt;baij&#39;</span><span class="p">,</span><span class="n">chi_phph</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
                             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bkcj,acik-&gt;abji&#39;</span><span class="p">,</span><span class="n">chi_phph</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
                             <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bkcj,acik-&gt;baji&#39;</span><span class="p">,</span><span class="n">chi_phph</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> <span class="p">)</span>
                 
    <span class="n">t2_new</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pnum</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hnum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hnum</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pnum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pnum</span><span class="p">):</span>
                    <span class="n">t2_new</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>  <span class="n">t2</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> 
                                       <span class="o">+</span> <span class="n">Hbar_pphh</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_hh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">f_hh</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">f_pp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span><span class="o">-</span><span class="n">f_pp</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">])</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">t2_new</span>


<span class="k">def</span> <span class="nf">ccd_energy</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes CCD energy. Call as </span>
<span class="sd">    energy = ccd_energy(v_pphh,t2)</span>
<span class="sd">    </span>
<span class="sd">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span class="sd">    param t2: t2 amplitude, tensor in form of pphh channel</span>
<span class="sd">    </span>
<span class="sd">    return energy: CCD correlation energy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">erg</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abij,abij&#39;</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">erg</span>

<span class="c1">###############################</span>
<span class="c1">######## Main Program</span>

<span class="c1"># set parameters as for model</span>
<span class="n">pnum</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># number of particle states</span>
<span class="n">hnum</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># number of hole states</span>
<span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">g</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;parameters&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;delta =&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="s2">&quot;, g =&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>


<span class="c1"># Initialize pairing matrix elements and Fock matrix</span>
<span class="n">v_pppp</span><span class="p">,</span> <span class="n">v_pphh</span><span class="p">,</span> <span class="n">v_hhhh</span> <span class="o">=</span> <span class="n">init_pairing_v</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">)</span>
<span class="n">f_pp</span><span class="p">,</span> <span class="n">f_hh</span> <span class="o">=</span> <span class="n">init_pairing_fock</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">pnum</span><span class="p">,</span><span class="n">hnum</span><span class="p">)</span>

<span class="c1"># Initialize T2 amplitudes from MBPT2</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">init_t2</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">f_hh</span><span class="p">)</span>
<span class="n">erg</span> <span class="o">=</span> <span class="n">ccd_energy</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># Exact MBPT2 for comparison, see last equation on page 365 </span>
<span class="n">exact_mbpt2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">g</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">+</span><span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">+</span><span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">6.0</span><span class="o">+</span><span class="n">g</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MBPT2 energy =&quot;</span><span class="p">,</span> <span class="n">erg</span><span class="p">,</span> <span class="s2">&quot;, compared to exact:&quot;</span><span class="p">,</span> <span class="n">exact_mbpt2</span><span class="p">)</span>
    
    
<span class="c1"># iterate CCD equations niter times</span>
<span class="n">niter</span><span class="o">=</span><span class="mi">200</span>
<span class="n">mix</span><span class="o">=</span><span class="mf">0.3</span>
<span class="n">erg_old</span><span class="o">=</span><span class="mf">0.0</span>
<span class="n">eps</span><span class="o">=</span><span class="mf">1.e-8</span>
<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
    <span class="n">t2_new</span> <span class="o">=</span> <span class="n">ccd_iter</span><span class="p">(</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">,</span><span class="n">f_pp</span><span class="p">,</span><span class="n">f_hh</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
    <span class="n">erg</span> <span class="o">=</span> <span class="n">ccd_energy</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2_new</span><span class="p">)</span>
    <span class="n">myeps</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">erg</span><span class="o">-</span><span class="n">erg_old</span><span class="p">)</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">erg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">myeps</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">erg_old</span><span class="o">=</span><span class="n">erg</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;iter=&quot;</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="s2">&quot;erg=&quot;</span><span class="p">,</span> <span class="n">erg</span><span class="p">,</span> <span class="s2">&quot;myeps=&quot;</span><span class="p">,</span> <span class="n">myeps</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">mix</span><span class="o">*</span><span class="n">t2_new</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mix</span><span class="p">)</span><span class="o">*</span><span class="n">t2</span> 
    
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy = &quot;</span><span class="p">,</span> <span class="n">erg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>parameters
delta = 1.0 , g = 0.5
MBPT2 energy = -0.2640986494237767 , compared to exact: -0.062393162393162394
iter= 0 erg= -0.36354426495308473 myeps= 1.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 1 erg= -0.37575624444298944 myeps= 0.03249973798308371
iter= 2 erg= -0.38585587217916006 myeps= 0.02617461198434523
iter= 3 erg= -0.3942075030185592 myeps= 0.021185874889362435
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 4 erg= -0.4011132425677644 myeps= 0.0172164337058469
iter= 5 erg= -0.40682329513318677 myeps= 0.014035706985640954
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 6 erg= -0.41154472066379555 myeps= 0.011472448299162774
iter= 7 erg= -0.415448787715655 myeps= 0.00939722817179461
iter= 8 erg= -0.41867711472018154 myeps= 0.007710779717883887
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 9 erg= -0.4213467805437514 myeps= 0.006336029956428388
iter= 10 erg= -0.4235545667262582 myeps= 0.005212518895903349
iter= 11 erg= -0.4253804729664931 myeps= 0.004292407283064816
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 12 erg= -0.42689062703898156 myeps= 0.003537566713430196
iter= 13 erg= -0.4281396916442187 myeps= 0.002917423050500827
iter= 14 erg= -0.4291728542011779 myeps= 0.0024073343568810036
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 15 erg= -0.4300274713630842 myeps= 0.0019873548059555165
iter= 16 erg= -0.4307344279442794 myeps= 0.0016412818092326651
iter= 17 erg= -0.4313192597672807 myeps= 0.0013559140004942823
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 18 erg= -0.43180308142773266 myeps= 0.001120468290435161
iter= 19 erg= -0.4322033528891356 myeps= 0.00092611836240335
iter= 20 erg= -0.43253451293787193 myeps= 0.0007656268779271082
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 21 erg= -0.43280850265722925 myeps= 0.0006330506856384872
iter= 22 erg= -0.4330351980489746 myeps= 0.0005235033844055304
iter= 23 erg= -0.4332227676000893 myeps= 0.00043296328157862334
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 24 erg= -0.4333779678407642 myeps= 0.0003581175144831452
iter= 25 erg= -0.4335063876676202 myeps= 0.00029623514326258533
iter= 26 erg= -0.4336126503302039 myeps= 0.0002450635665329708
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 27 erg= -0.43370058043009574 myeps= 0.00020274379113034994
iter= 28 erg= -0.4337733420034005 myeps= 0.0001677409980261048
iter= 29 erg= -0.43383355270178803 myeps= 0.00013878755576313752
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 30 erg= -0.4338833782156424 myeps= 0.00011483618952922357
iter= 31 erg= -0.43392461036313534 myeps= 9.50214542071232e-05
iter= 32 erg= -0.4339587316746199 myeps= 7.862800997893603e-05
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 33 erg= -0.43398696881076043 myeps= 6.506447928127211e-05
iter= 34 erg= -0.43401033674723327 myeps= 5.384188922313506e-05
iter= 35 erg= -0.4340296753237455 myeps= 4.455588548820297e-05
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 36 erg= -0.43404567947824346 myeps= 3.6872051156509844e-05
iter= 37 erg= -0.4340589242583793 myeps= 3.0513783718287337e-05
iter= 38 erg= -0.434069885513208 myeps= 2.525228124449486e-05
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 39 erg= -0.43407895701178667 myeps= 2.08982684650241e-05
iter= 40 erg= -0.43408646460614353 myeps= 1.729515884276886e-05
iter= 41 erg= -0.4340926779492775 myeps= 1.4313402297628368e-05
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 42 erg= -0.4340978201905307 myeps= 1.1845812197343312e-05
iter= 43 erg= -0.43410207599766415 myeps= 9.803701407424543e-06
iter= 44 erg= -0.4341055981945805 myeps= 8.113686925482528e-06
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 45 erg= -0.43410851325371014 myeps= 6.715047138304284e-06
iter= 46 erg= -0.43411092584077954 myeps= 5.557535933304656e-06
iter= 47 erg= -0.4341129225755269 myeps= 4.5995745427982914e-06
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 48 erg= -0.43411457514368107 myeps= 3.8067557478495853e-06
iter= 49 erg= -0.43411594287215505 myeps= 3.150606413873383e-06
iter= 50 erg= -0.4341170748600758 myeps= 2.607563687969726e-06
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 51 erg= -0.4341180117422817 myeps= 2.158127929698868e-06
iter= 52 erg= -0.4341187871486943 myeps= 1.7861618421804902e-06
iter= 53 erg= -0.4341194289120248 myeps= 1.478310547265082e-06
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 54 erg= -0.4341199600672291 myeps= 1.2235217292978426e-06
iter= 55 erg= -0.4341203996786241 myeps= 1.012648554028702e-06
iter= 56 erg= -0.43412076352439366 myeps= 8.381210947268386e-07
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 57 erg= -0.4341210646630742 myeps= 6.936744264669387e-07
iter= 58 erg= -0.43412131390237374 myeps= 5.741236183312693e-07
iter= 59 erg= -0.43412152018716577 myeps= 4.75177530791271e-07
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 60 erg= -0.43412169092059416 myeps= 3.9328472169422255e-07
iter= 61 erg= -0.43412183222982187 myeps= 3.2550592303140516e-07
iter= 62 erg= -0.43412194918596947 myeps= 2.6940851025684355e-07
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 63 erg= -0.43412204598613835 myeps= 2.2297915937601343e-07
iter= 64 erg= -0.43412212610405826 myeps= 1.8455156991990885e-07
iter= 65 erg= -0.43412219241476757 myeps= 1.5274664707545314e-07
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 66 erg= -0.4341222472978008 myeps= 1.2642299161312937e-07
iter= 67 erg= -0.4341222927225912 myeps= 1.0463593124585968e-07
iter= 68 erg= -0.43412233031915237 myeps= 8.660361048457761e-08
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 69 erg= -0.4341223614365778 myeps= 7.16789278285526e-08
iter= 70 erg= -0.43412238719145646 myeps= 5.9326308511289724e-08
iter= 71 erg= -0.4341224085079444 myeps= 4.910248249319024e-08
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 72 erg= -0.4341224261509296 myeps= 4.064057537950126e-08
iter= 73 erg= -0.43412244075348105 myeps= 3.3636942196453457e-08
iter= 74 erg= -0.4341224528395664 myeps= 2.7840267822341936e-08
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 75 erg= -0.43412246284285466 myeps= 2.304254930229631e-08
iter= 76 erg= -0.43412247112227875 myeps= 1.9071632181026577e-08
iter= 77 erg= -0.4341224779749146 myeps= 1.578502886931811e-08
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iter= 78 erg= -0.43412248364664213 myeps= 1.306480946214148e-08
iter= 79 erg= -0.434122488340968 myeps= 1.0813367191382213e-08
Energy =  -0.4341224922263279
</pre></div>
</div>
</div>
</div>
<!-- --- end answer of exercise --- --></div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="nucleonic-matter">
<h1><span class="section-number">8. </span>Nucleonic Matter<a class="headerlink" href="#nucleonic-matter" title="Permalink to this headline">¶</a></h1>
<p>We want to compute nucleonic matter using coupled cluster or IMSRG
methods, and start with considering the relevant symmetries.</p>
<div class="section" id="exercise-16-which-symmetries-are-relevant-for-nuclear-matter">
<h2><span class="section-number">8.1. </span>Exercise 16: Which symmetries are relevant for nuclear matter?<a class="headerlink" href="#exercise-16-which-symmetries-are-relevant-for-nuclear-matter" title="Permalink to this headline">¶</a></h2>
<div id="ex-17"></div><p><strong>a)</strong>
Enumerate continuous and discrete symmetries of nuclear matter.</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
The symmetries are the same as for nuclei.  Continuous symmetries:
translational and rotational invariance. Discrete symmetries: Parity
and time reversal invariance.</p>
<!-- --- end answer of exercise --- --><p><strong>b)</strong>
What basis should we use to implement these symmetries? Why do we have to make a choice between the two continuous symmetries? Which basis is most convenient and why?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
Angular momentum and momentum do not commute. Thus, there is no basis
that respects both symmetries simultaneously. If we choose the
spherical basis, we are computing a spherical blob of nuclear matter
and have to contend with surface effects, i.e. with finite size
effects. We also need a partial-wave decomposition of the nuclear
interaction. This approach has been done followed in
[“Coupled-cluster studies of infinite nuclear matter, ” G. Baardsen,
A. Ekström, G. Hagen, M. Hjorth-Jensen, arXiv:1306.5681, Phys. Rev. C
88, 054312 (2013)]. If we choose a basis of discrete momentum states,
translational invariance can be respected. This also facilitates the
implementetation of modern nuclear interactions (which are often
formulated in momentum space in effective field theories). However, we
have to think about the finite size effects imposed by periodic
boundary conditions (or generalized Bloch waves). This approch was
implemented in [“Coupled-cluster calculations of nucleonic matter,”
G. Hagen, T. Papenbrock, A. Ekström, K. A. Wendt, G. Baardsen,
S. Gandolfi, M. Hjorth-Jensen, C. J. Horowitz, arXiv:1311.2925,
Phys. Rev. C 89, 014319 (2014)].</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
</div>
<div class="section" id="basis-states">
<h2><span class="section-number">8.2. </span>Basis states<a class="headerlink" href="#basis-states" title="Permalink to this headline">¶</a></h2>
<p>In what follows, we employ a basis made from discrete momentum states,
i.e. those states <span class="math notranslate nohighlight">\(\vert k_x, k_y, k_z\rangle\)</span> in a cubic box of size <span class="math notranslate nohighlight">\(L\)</span> that
exhibit periodic boundary conditions, i.e. <span class="math notranslate nohighlight">\(\psi_k(x+L) =\psi_k(x)\)</span>.</p>
</div>
<div class="section" id="exercise-17-determine-the-basis-states">
<h2><span class="section-number">8.3. </span>Exercise 17: Determine the basis states<a class="headerlink" href="#exercise-17-determine-the-basis-states" title="Permalink to this headline">¶</a></h2>
<div id="ex-18"></div>
<p>What are the discrete values of momenta admissable in <span class="math notranslate nohighlight">\((k_x, k_y, k_z)\)</span>?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
In 1D position space <span class="math notranslate nohighlight">\(\psi_k(x) \propto e^{i k x}\)</span> with <span class="math notranslate nohighlight">\(k =
{2\pi n\over L}\)</span> and <span class="math notranslate nohighlight">\(n=0, \pm 1, \pm 2, \ldots\)</span> fulfill <span class="math notranslate nohighlight">\(\psi_k(x+L)
= \psi_k(x)\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Thus, we use a cubic lattice in momentum space.  Note that the
momentum states <span class="math notranslate nohighlight">\(e^{i k x}\)</span> are not invariant under time reversal
(i.e. under <span class="math notranslate nohighlight">\(k\to -k\)</span>), and also do not exhibit good parity (<span class="math notranslate nohighlight">\(x\to
-x\)</span>). The former implies that the Hamiltonian matrix will in general
be complex Hermitian and that the cluster amplitudes will in general
be complex.</p>
</div>
<div class="section" id="exercise-18-how-large-should-the-basis-be">
<h2><span class="section-number">8.4. </span>Exercise 18: How large should the basis be?<a class="headerlink" href="#exercise-18-how-large-should-the-basis-be" title="Permalink to this headline">¶</a></h2>
<div id="ex-19"></div>
<p>What values should be chosen for the box size <span class="math notranslate nohighlight">\(L\)</span> and for the maximum number <span class="math notranslate nohighlight">\(n_{\rm max}\)</span> , i.e.
for the discrete momenta <span class="math notranslate nohighlight">\(k = {2\pi n\over L}\)</span> and <span class="math notranslate nohighlight">\(n=0, \pm 1,\
 \pm 2, \ldots, \pm n_{\rm max}\)</span>?</p>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
Usually <span class="math notranslate nohighlight">\(n_{\rm max}\)</span> is fixed by computational cost, because we have
<span class="math notranslate nohighlight">\((2n_{\rm max}+1)^3\)</span> basis states. We have used <span class="math notranslate nohighlight">\(n_{\rm max}=4\)</span> or up
to <span class="math notranslate nohighlight">\(n_{\rm max}=6\)</span> in actual calculations to get converged results.</p>
<p>The maximum momentum must fulfill <span class="math notranslate nohighlight">\(k_{n_{\rm max}}&gt; \Lambda\)</span>, where
<span class="math notranslate nohighlight">\(\Lambda\)</span> is the momemtum cutoff of the interaction. This then fixes
<span class="math notranslate nohighlight">\(L\)</span> for a given <span class="math notranslate nohighlight">\(n_{\rm max}\)</span>.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Coupled cluster and IMSRG start from a Hartree-Fock reference state,
and we need to think about this next. What are the magic numbers of a
cubic lattice for neutron matter?</p>
</div>
<div class="section" id="exercise-19-determine-the-lowest-few-magic-numbers-for-a-cubic-lattice">
<h2><span class="section-number">8.5. </span>Exercise 19: Determine the lowest few magic numbers for a cubic lattice.<a class="headerlink" href="#exercise-19-determine-the-lowest-few-magic-numbers-for-a-cubic-lattice" title="Permalink to this headline">¶</a></h2>
<div id="ex-20"></div>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
As the spin-degeneracy is <span class="math notranslate nohighlight">\(g_s=2\)</span>, we have the magic numbers <span class="math notranslate nohighlight">\(g_s N\)</span>
with <span class="math notranslate nohighlight">\(N=1, 7, 19, 27, 33, 57, 66, \ldots\)</span> for neutrons.</p>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
<p>Given <span class="math notranslate nohighlight">\(n_{\rm max}\)</span> and <span class="math notranslate nohighlight">\(L\)</span> for the basis parameters, we can choose a
magic neutron number <span class="math notranslate nohighlight">\(N\)</span>. Clearly, the density of the system is then
<span class="math notranslate nohighlight">\(\rho=N/L^3\)</span>. This summarizes the requirements for the basis. We
choose <span class="math notranslate nohighlight">\(n_{\rm max}\)</span> as large as possible, i.e. as large as
computationally feasible. Then <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(N\)</span> are constrained by the UV
cutoff and density of the system.</p>
</div>
<div class="section" id="finite-size-effects">
<h2><span class="section-number">8.6. </span>Finite size effects<a class="headerlink" href="#finite-size-effects" title="Permalink to this headline">¶</a></h2>
<p>We could also have considered the case of a more generalized boundary
condition, i.e.  <span class="math notranslate nohighlight">\(\psi_k(x+L) =e^{i\theta}\psi_k(x)\)</span>.  Admissable
momenta that fulfill such a boundary condition are <span class="math notranslate nohighlight">\(k_n(\theta) = {2\pi n
+\theta \over L}\)</span>. Avering over the “twist” angle <span class="math notranslate nohighlight">\(\theta\)</span> removes
finite size effects, because the discrete momenta are really drawn
form a continuum.  In three dimensions, there are three possible twist
angles, and averaging over twist angles implies summing over many
results corresponding to different angles. Thus, the removal of
finite-size effects significantly increases the numerical expense.
An example
is shown in <a class="reference external" href="#fig-finite">Figure 14</a>, where we compute the kinetic
energy per particle</p>
<!-- Equation labels as ordinary links -->
<div id="_auto26"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
T_N(\theta_x,\theta_y,\theta_z)=g_s\sum_{n_x, n_y, n_z \in N} {\hbar^2 \left( k_{n_x}^2(\theta_x) +k_{n_y}^2(\theta_y) +k_{n_z}^2(\theta_z)\right)\over 2m}
\label{_auto26} \tag{39}
\end{equation}
\]</div>
<p>and compare with the infinite result <span class="math notranslate nohighlight">\(T_{\rm inf} = {3\over 10} 
{\hbar^2 k_F^2\over m} N\)</span> valid for the free Fermi gas. We clearly see
strong shell effects (blue dashed line) and that averaging over the twist angles
(red full line) very much reduces the shell oscillations. We also note that
the neutron number 66 is quite attractive as it exhibits smaller
finite size effects than other of the accessible magic numbers.</p>
<!-- dom:FIGURE: [figslides/fig-finite.png, width=600 frac=0.8] Relative finite-size corrections for the kinetic energy in pure neutron matter at the Fermi momentum $k_F = 1.6795 {\rm fm}^{-1}$ versus the neutron number A. TABC10 are twist-averaged boundary conditions with 10 Gauss-Legendre points in each spatial direction. <div id="fig-finite"></div> -->
<!-- begin figure -->
<div id="fig-finite"></div>
<p><img src="figslides/fig-finite.png" width="600"><p style="font-size: 0.9em"><i>Figure 14: Relative finite-size corrections for the kinetic energy in pure neutron matter at the Fermi momentum <span class="math notranslate nohighlight">\(k_F = 1.6795 {\rm fm}^{-1}\)</span> versus the neutron number A. TABC10 are twist-averaged boundary conditions with 10 Gauss-Legendre points in each spatial direction.</i></p></p>
<!-- end figure --></div>
<div class="section" id="channel-structure-of-hamiltonian-and-cluster-amplitudes">
<h2><span class="section-number">8.7. </span>Channel structure of Hamiltonian and cluster amplitudes<a class="headerlink" href="#channel-structure-of-hamiltonian-and-cluster-amplitudes" title="Permalink to this headline">¶</a></h2>
<p>Good quantum numbers for the nuclear interaction (i.e. operators that
commute with the Hamiltonian and with each other) are total momentum,
and the number of neutrons and protons, and - for simple interactions</p>
<p>:<br />
also the spin (this is really spin, not orbital anular momentum or</p>
<p>total angular momentum, as the latter two do not commute with
momentum). Thus the Hamiltonian (and the cluster amplitudes) will
consist of blocks, one for each set of quantum numbers. We call the
set of quantum numbers that label each such block as a “channel.”
As the interaction is block diagonal, a numerically efficient
implementation of nuclear matter has to take advantage of this channel
structure. In fact, neutron matter cannot be computed in a numerically
converged way (i.e. for large enough <span class="math notranslate nohighlight">\(n_{\rm max}\)</span>) if one does not
exploit the channel structure.</p>
<p>The Hamiltonian is of the structure</p>
<!-- Equation labels as ordinary links -->
<div id="HQ"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{HQ} \tag{40}
H = \sum_{\vec{k}, \sigma} \varepsilon_{\vec{k}, \sigma}^{\vec{k}, \sigma} a^\dagger_{\vec{k}, \sigma}a_{\vec{k}, \sigma}
+ \sum_{\vec{Q},\vec{p},\vec{k},\sigma_s} V_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(\vec{p},\vec{k}) a^\dagger_{\vec{Q/2}+\vec{p}, \sigma_3}a^\dagger_{\vec{Q/2}-\vec{p}, \sigma_4} a_{\vec{Q/2}-\vec{k}, \sigma_2}a_{\vec{Q/2}+\vec{k}, \sigma_1}
\end{equation}
\]</div>
<p>with <span class="math notranslate nohighlight">\(\varepsilon_{\vec{k}, \sigma}^{\vec{k}, \sigma} = {k^2\over
2m}\)</span>.  In Eq. (<a class="reference external" href="#HQ">40</a>) we expressed the single-particle momenta in
terms of center-of-mass momentum <span class="math notranslate nohighlight">\(\vec{Q}\)</span> and relative momenta
<span class="math notranslate nohighlight">\((\vec{k},\vec{p})\)</span>, i.e. the incoming momenta <span class="math notranslate nohighlight">\((\vec{k}_1,
\vec{k}_2)\)</span> and outgoing momenta <span class="math notranslate nohighlight">\((\vec{k}_3, \vec{k}_3)\)</span> are</p>
<!-- Equation labels as ordinary links -->
<div id="CoM"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{CoM} \tag{41}
\vec{k}_1 = \vec{Q}/2 +\vec{k} ,
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto27"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\vec{k}_2 = \vec{Q}/2 -\vec{k} ,
\label{_auto27} \tag{42}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto28"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\vec{k}_3 = \vec{Q}/2 +\vec{p} ,
\label{_auto28} \tag{43}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto29"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\vec{k}_4 = \vec{Q}/2 -\vec{p} .
\label{_auto29} \tag{44}
\end{equation}
\]</div>
<p>The conservation of momentum is obvious in the two-body interaction as
both the annihilation operators and the creation operators depend on
the same center-of-mass momentum <span class="math notranslate nohighlight">\(\vec{Q}\)</span>. We note that the two-body
interaction <span class="math notranslate nohighlight">\(V\)</span> depends only on the relative momenta
<span class="math notranslate nohighlight">\((\vec{k},\vec{p})\)</span> but not on the center-of-mass momentum. We also
note that a local interaction (i.e. an interaction that is
multiplicative in position space) depends only on the momentum
transfer <span class="math notranslate nohighlight">\(\vec{k}-\vec{p}\)</span>. The spin projections <span class="math notranslate nohighlight">\(\pm 1/2\)</span> are denoted
as <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Thus, the <span class="math notranslate nohighlight">\(T_2\)</span> operator is</p>
<!-- Equation labels as ordinary links -->
<div id="t2Q"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{t2Q} \tag{45}
T_2 = {1\over 4} \sum_{\vec{Q},\vec{p},\vec{k},\sigma_s} t_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(Q; \vec{p},\vec{k}) a^\dagger_{\vec{Q/2}+\vec{p}, \sigma_3}a^\dagger_{\vec{Q/2}-\vec{p}, \sigma_4} a_{\vec{Q/2}-\vec{k}, \sigma_2}a_{\vec{Q/2}+\vec{k}, \sigma_1} . 
\end{equation}
\]</div>
<p>We note that the amplitude <span class="math notranslate nohighlight">\(t_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(Q;
\vec{p},\vec{k})\)</span> depends on the center-of-mass momentum <span class="math notranslate nohighlight">\(\vec{Q}\)</span>, in
contrast to the potential matrix element
<span class="math notranslate nohighlight">\(V_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(\vec{p},\vec{k})\)</span>.</p>
<p>In the expressions (<a class="reference external" href="#HQ">40</a>) and (<a class="reference external" href="#t2Q">45</a>) we supressed that
<span class="math notranslate nohighlight">\(\sigma_1+\sigma_2 = \sigma_3+\sigma_4\)</span>. So, a channel is defined by
<span class="math notranslate nohighlight">\(\vec{Q}\)</span> and total spin projection <span class="math notranslate nohighlight">\(\sigma_1+\sigma_2\)</span>.</p>
<p>Because of this channel structure, the simple solution we implemented
for the pairing problem cannot be really re-used when computing
neutron matter.  Let us take a look at the Minnesota potential</p>
<!-- Equation labels as ordinary links -->
<div id="_auto30"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V(r) = \left( V_R(r)  + {1\over 2}(1+P_{12}^\sigma)V_T(r) + {1\over 2}(1-P_{12}^\sigma)V_S(r)\right) {1\over 2}(1-P_{12}^\sigma P_{12}^\tau). 
\label{_auto30} \tag{46}
\end{equation}
\]</div>
<p>Here,</p>
<div class="math notranslate nohighlight">
\[
P^\sigma_{12}= {1\over 2}(1+\vec{\sigma}_1\cdot\vec{\sigma}_2) , \nonumber
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto31"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
P^\tau_{12} = {1\over 2}(1+\vec{\tau}_1\cdot\vec{\tau}_2) 
\label{_auto31} \tag{47}
\end{equation}
\]</div>
<p>are spin and isospin exchange operators, respectively, and
<span class="math notranslate nohighlight">\(\vec{\sigma}\)</span> and <span class="math notranslate nohighlight">\(\vec{\tau}\)</span> are vectors of Pauli matrices in spin
and isospin space, respectively. Thus,</p>
<!-- Equation labels as ordinary links -->
<div id="_auto32"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
{1\over 2}(1-P_{12}^\sigma P_{12}^\tau)  = \vert
S_{12}=0, T_{12}=1\rangle\langle S_{12}=0,T_{12}=1\vert + \vert
S_{12}=1, T_{12}=0\rangle\langle S_{12}=1,T_{12}=0\vert
\label{_auto32} \tag{48}
\end{equation}
\]</div>
<p>projects onto two-particle spin-isospin states as indicated, while</p>
<!-- Equation labels as ordinary links -->
<div id="_auto33"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
{1\over 2}(1-P_{12}^\sigma)  = \vert
S_{12}=0\rangle\langle S_{12}=0\vert , 
\label{_auto33} \tag{49}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto34"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  {1\over 2}(1+P_{12}^\sigma)
 = \vert S_{12}=1\rangle\langle S_{12}=1\vert
\label{_auto34} \tag{50}
\end{equation}
\]</div>
<p>project onto spin singlet and spin triplet combinations,
respectively. For neutron matter, two-neutron states have isospin
<span class="math notranslate nohighlight">\(T_{12}=1\)</span>, and the Minnesota potential has no triplet term <span class="math notranslate nohighlight">\(V_T\)</span>.
For the spin-exchange operator (and spins <span class="math notranslate nohighlight">\(s_1, s_2=\pm 1/2\)</span>), we have
<span class="math notranslate nohighlight">\(P_{12}^\sigma\vert s_1s_2\rangle= \vert s_2s_1\rangle\)</span>.  For neutron
matter, <span class="math notranslate nohighlight">\(P_{12}^\tau=1\)</span>, because the states are symmetric under exchange of
isospin. Thus, the Minnesota potential simplifies significantly for
neutron matter as <span class="math notranslate nohighlight">\(V_T\)</span> does not contribute.</p>
<p>We note that the spin operator has matrix elements</p>
<!-- Equation labels as ordinary links -->
<div id="_auto35"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\langle s_1' s_2'\vert {1\over 2}(1-P_{12}^{\sigma})\vert s_1 s_2\rangle
= {1\over 2} \left(
 \delta_{s_1}^{s_1'}\delta_{s_2}^{s_2'}
-\delta_{s_1}^{s_2'}\delta_{s_2}^{s_1'}\right) . 
\label{_auto35} \tag{51}
\end{equation}
\]</div>
<p>The radial functions are</p>
<!-- Equation labels as ordinary links -->
<div id="_auto36"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V_R(r) =V_R e^{-\kappa_R r^2} , 
\label{_auto36} \tag{52}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto37"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
V_S(r) =V_S e^{-\kappa_S r^2} , 
\label{_auto37} \tag{53}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto38"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
V_T(r) =V_T e^{-\kappa_T r^2} , 
\label{_auto38} \tag{54}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto39"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\label{_auto39} \tag{55}
\end{equation}
\]</div>
<p>and the parameters are as follows</p>
<table class="dotable" border="1">
<thead>
<tr><th align="center">$\alpha$</th> <th align="center">$V_\alpha$</th> <th align="center">$\kappa_\alpha$ </th> </tr>
</thead>
<tbody>
<tr><td align="center">   $R$         </td> <td align="right">   +200 MeV      </td> <td align="center">   1.487 fm $^{-2}$    </td> </tr>
<tr><td align="center">   $S$         </td> <td align="right">   -91.85 MeV    </td> <td align="center">   0.465 fm $^{-2}$    </td> </tr>
<tr><td align="center">   $T$         </td> <td align="right">   -178 MeV      </td> <td align="center">   0.639 fm $^{-2}$    </td> </tr>
</tbody>
</table>
<p>Note that <span class="math notranslate nohighlight">\(\kappa_\alpha^{1/2}\)</span> sets the momentum scale of the
Minnesota potential. We see that we deal with a short-ranged repulsive
core (the <span class="math notranslate nohighlight">\(V_R\)</span> term) and longer ranged attractive terms in the
singlet (the term <span class="math notranslate nohighlight">\(V_S\)</span>) and triplet (the term <span class="math notranslate nohighlight">\(V_T\)</span>) channels.</p>
<p>A Fourier transform (in the finite cube of length <span class="math notranslate nohighlight">\(L\)</span>) yields the momentum-space form of the potential</p>
<!-- Equation labels as ordinary links -->
<div id="_auto40"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\langle k_p k_q \vert V_\alpha\vert k_r k_s \rangle = {V_\alpha\over L^3} \left({\pi\over\kappa_\alpha}\right)^{3/2}
e^{- {q^2 \over 4\kappa_\alpha}} \delta_{k_p+k_q}^{k_r+k_s} . 
\label{_auto40} \tag{56}
\end{equation}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(q\equiv {1\over 2}(k_p-k_q-k_r+k_s)\)</span> is the momentum transfer,
and the momentum conservation <span class="math notranslate nohighlight">\(k_p+k_q=k_r+k_s\)</span> is explicit.</p>
<p>As we are dealing only with neutrons, the potential matrix elements
(including spin) are for <span class="math notranslate nohighlight">\(\alpha = R, S\)</span></p>
<!-- Equation labels as ordinary links -->
<div id="ME_of_V"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{ME_of_V} \tag{57}
\langle	k_p s_p k_q s_q\vert V_\alpha\vert k_r s_r k_s s_s\rangle = \langle	k_p k_q \vert V_\alpha\vert k_r k_s \rangle
{1\over 2}\left(\delta_{s_p}^{s_r}\delta_{s_q}^{s_s} - \delta_{s_p}^{s_s}\delta_{s_q}^{s_r}\right) , 
\end{equation}
\]</div>
<p>and it is understood that there is no contribution from <span class="math notranslate nohighlight">\(V_T\)</span>. Please note that the matrix elements (<a class="reference external" href="#ME_of_V">57</a>) are not yet antisymmetric under exchange, but <span class="math notranslate nohighlight">\(\langle k_p s_p k_q s_q\vert V_\alpha\vert k_r s_r k_s s_s\rangle -
\langle k_p s_p k_q s_q\vert V_\alpha\vert k_s s_s k_r s_r\rangle\)</span> is.</p>
</div>
<div class="section" id="example-channel-structure-and-its-usage">
<h2><span class="section-number">8.8. </span>Example: Channel structure and its usage<a class="headerlink" href="#example-channel-structure-and-its-usage" title="Permalink to this headline">¶</a></h2>
<div id="ex-21"></div>
<p>We have single-particle states with momentum and spin, namely</p>
<!-- Equation labels as ordinary links -->
<div id="_auto41"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\vert r\rangle \equiv \vert k_r s_r\rangle .
\label{_auto41} \tag{58}
\end{equation}
\]</div>
<p>Naively, two-body states are then</p>
<!-- Equation labels as ordinary links -->
<div id="_auto42"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\vert r s \rangle \equiv \vert k_r s_r k_s s_s\rangle ,
\label{_auto42} \tag{59}
\end{equation}
\]</div>
<p>but using the center-of-mass transformation (<a class="reference external" href="#CoM">41</a>) we can rewrite</p>
<!-- Equation labels as ordinary links -->
<div id="_auto43"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\vert r s \rangle \equiv \vert P_{rs} k_{rs} s_r s_s\rangle ,
\label{_auto43} \tag{60}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(P_{rs} = k_r +k_s\)</span> is the total momentum and
<span class="math notranslate nohighlight">\(k_{rs}=(k_r-k_s)/2\)</span> is the relative momentum. This representation of
two-body states is well adapated to our problem, because the
interaction and the <span class="math notranslate nohighlight">\(T_2\)</span> amplitudes preserve the total momentum.
Thus, we store the cluster amplitudes <span class="math notranslate nohighlight">\(t_{ij}^{ab}\)</span> as matrices</p>
<!-- Equation labels as ordinary links -->
<div id="_auto44"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
t_{ij}^{ab} \to \left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv t_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\label{_auto44} \tag{61}
\end{equation}
\]</div>
<p>and the conservation of total momentum is explicit.</p>
<p>Likewise, the pppp, pphh, and hhhh parts of the interaction can be written in this form, namely</p>
<!-- Equation labels as ordinary links -->
<div id="_auto45"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V_{cd}^{ab} \to \left[V(P_{ab})\right]_{\vert k_{cd} s_c s_d\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv V_{\vert P_{ab} k_{cd} s_c s_d\rangle}^{\vert P_{ab} k_{ab} s_a s_b\rangle} , 
\label{_auto45} \tag{62}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto46"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
V_{ij}^{ab} \to \left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv V_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\label{_auto46} \tag{63}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto47"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
V_{ij}^{kl} \to \left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{kl} s_k s_l\rangle}
\equiv V_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{kl} s_k s_l\rangle} , 
\label{_auto47} \tag{64}
\end{equation}
\]</div>
<p>and we also have</p>
<!-- Equation labels as ordinary links -->
<div id="_auto48"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{H}_{ij}^{ab} \to \left[\overline{H}(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv \overline{H}_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\label{_auto48} \tag{65}
\end{equation}
\]</div>
<p>Using these objects, diagrams (1), (4), and (5) of <a class="reference external" href="#fig-ccd">Figure 11</a> can be done for each block of momentum <span class="math notranslate nohighlight">\(P_{ij}\)</span> as a
copy and matrix-matrix multiplications, respectively</p>
<!-- Equation labels as ordinary links -->
<div id="_auto49"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\left[\overline{H}(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle} =
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle} 
\label{_auto49} \tag{66}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto50"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
+ {1\over 2} \sum_{\vert k_{kl} s_k s_l\rangle}
\left[t(P_{ij})\right]_{\vert k_{kl} s_k s_l\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{kl} s_k s_l\rangle} 
\label{_auto50} \tag{67}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto51"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
+ {1\over 2} \sum_{\vert k_{cd} s_c s_d\rangle}
\left[V(P_{ij})\right]_{\vert k_{cd} s_c s_d\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{cd} s_c s_d\rangle} .
\label{_auto51} \tag{68}
\end{equation}
\]</div>
<p>Similarly, the CCD correlation energy results from</p>
<!-- Equation labels as ordinary links -->
<div id="_auto52"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E_c = {1\over 4} \sum_{P_{ij}} \sum_{\vert k_{ij} s_i s_j\rangle}\sum_{\vert k_{ab} s_a s_b\rangle }
\left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\label{_auto52} \tag{69}
\end{equation}
\]</div>
<p>These efficiences cannot be used for the sixth diagram of <a class="reference external" href="#fig-ccd">Figure 11</a>. One could either change to a ph formulation, noting that
<span class="math notranslate nohighlight">\(k_a-k_i = k_k -k_c\)</span> is also a preserved quantity in <span class="math notranslate nohighlight">\(t_{ik}^{ac}\)</span> and
that <span class="math notranslate nohighlight">\(k_k-k_c = k_j-k_b\)</span> is preserved in <span class="math notranslate nohighlight">\(V_{cj}^{kb}\)</span>. Thus
<span class="math notranslate nohighlight">\(\sum_{kc} t_{ik}^{ac}V_{cj}^{kb}\)</span> has a conserved quantity <span class="math notranslate nohighlight">\(k_k-k_c\)</span>
in the loop, and we can again use matrix-matrix multiplications for
this diagram. This requires us to store the <span class="math notranslate nohighlight">\(T_2\)</span> amplitude in a phhp
and in the usual pphh formulation. Alternatively, we could simply code
this diagram with the loops over single-particle states. If this seems
too tedious, one can also limit CCD to the first five diagrams in
<a class="reference external" href="#fig-ccd">Figure 11</a> (these are the pp and hh ladders), which gives a
good description for neutron matter, see the comparison between this
and full CCD in [“Coupled-cluster calculations of nucleonic matter,”
G. Hagen, T. Papenbrock, A. Ekström, K. A. Wendt, G. Baardsen,
S. Gandolfi, M. Hjorth-Jensen, C. J. Horowitz, arXiv:1311.2925,
Phys. Rev. C 89, 014319 (2014)].</p>
<p>===== =====</p>
<p>The steps towards the solution of the CCD equations for neutron matter are as follows</p>
<ol class="simple">
<li><p>For a given density and UV cutoff, set up the lattice, i.e. determine the single-particle basis.</p></li>
<li><p>Determine the channels allowed by the (Minnesota) interaction, i.e. sets of two-body states that are connected by the interaction.</p></li>
<li><p>Exploit this channel structure when computing the diagrams.</p></li>
<li><p>Solve the coupled-cluster equations. Here we start first with the pp and hh ladders, i.e. using only  the first five diagrams of <a class="reference external" href="#fig-ccd">Figure 11</a>.</p></li>
</ol>
</div>
<div class="section" id="exercise-20-write-a-ccd-code-for-neutron-matter-focusing-first-on-ladder-approximation-i-e-including-the-first-five-diagrams-in-figure-11">
<h2><span class="section-number">8.9. </span>Exercise 20: Write a CCD code for neutron matter, focusing first on ladder approximation, i.e. including the first five diagrams in <a class="reference external" href="#fig-ccd">Figure 11</a>.<a class="headerlink" href="#exercise-20-write-a-ccd-code-for-neutron-matter-focusing-first-on-ladder-approximation-i-e-including-the-first-five-diagrams-in-figure-11" title="Permalink to this headline">¶</a></h2>
<div id="ex-30"></div>
<!-- --- begin answer of exercise --- -->
<p><strong>Answer.</strong>
<a class="reference external" href="https://github.com/NuclearTalent/ManyBody2018/tree/master/doc/Programs/Python/NeutronMatter">Click for IPython notebook</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1">##############################################################</span>
<span class="c1"># CCD Program for neutron matter with the Minnesota potential.</span>
<span class="c1">#</span>
<span class="c1"># Thomas Papenbrock, July/August 2018</span>
<span class="c1">#</span>
<span class="c1"># License: Free Software following Version 3 of GNU General Public License, </span>
<span class="c1"># see https://www.gnu.org/licenses/gpl.html</span>
<span class="c1">#######</span>


<span class="c1">##########################</span>
<span class="c1"># Class for neutron matter </span>
<span class="c1">#######</span>

<span class="k">class</span> <span class="nc">MomSpaceBasis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    momentum-space basis class</span>
<span class="sd">    The constructor has the form</span>
<span class="sd">    </span>
<span class="sd">    MomSpaceBasis(Nmax,kmax)</span>
<span class="sd">    </span>
<span class="sd">    param Nmax: Number of lattice points in positive kx-direction</span>
<span class="sd">    param kmax: Highest lattice momentum (in 1/fm)</span>
<span class="sd">    </span>
<span class="sd">    return: MomSpaceBasis as a single-partcle basis. </span>
<span class="sd">    attributes of MomSpaceBasis are</span>
<span class="sd">    </span>
<span class="sd">    dk : lattice spacing in 1/fm</span>
<span class="sd">    Lbox : linear dimension (in fm) of cubic box</span>
<span class="sd">    nvec : lattice vectors (integers)</span>
<span class="sd">    kvec : lattice momentum vectors (floats, in 1/fm)</span>
<span class="sd">    ngrid : total number of lattice points </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Nmax</span><span class="p">,</span><span class="n">kmax</span><span class="p">,</span><span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the constructor</span>
<span class="sd">        </span>
<span class="sd">        Generates a cubic lattice in momentum space</span>
<span class="sd">        param Nmax: Number of lattice points in positive kx-direction</span>
<span class="sd">        param kmax: Highest lattice momentum (in 1/fm)</span>
<span class="sd">        param ordered: Optional parameter, True by default, will order lattice points by kinetic energy</span>
<span class="sd">        </span>
<span class="sd">        return MomSpaceBasis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nmax</span> <span class="o">=</span> <span class="n">Nmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kvec</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">dk</span> <span class="o">=</span> <span class="n">kmax</span> <span class="o">/</span> <span class="n">Nmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dk</span> <span class="o">=</span> <span class="n">dk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lbox</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">dk</span>
        
        <span class="n">nx</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">nvec</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1">#print(&#39;nx=&#39;,nx)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nx</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="p">:</span>
                    <span class="n">nvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
                    
        <span class="c1">#print(&#39;nvec=&#39;,nvec)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nvec</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">ordered</span><span class="p">:</span>
            <span class="c1">#print(&quot;ordered&quot;)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nvec</span><span class="p">):</span>
                <span class="n">npvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">npvec</span><span class="p">,</span><span class="n">npvec</span><span class="p">)</span>
               <span class="c1"># print(i, vec, norm[i])</span>
        
            <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="c1">#print(index)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                <span class="c1">#print(i, ind, nvec[ind])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nvec</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                
        <span class="k">else</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="o">=</span><span class="n">nvec</span>  <span class="c1"># a list</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_kvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="p">)</span><span class="o">*</span><span class="n">dk</span> <span class="c1"># a numpy array</span>

    
    <span class="k">def</span> <span class="nf">kvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indx</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MomSpaceBasis.kvec(i) returns ith momentum vector</span>
<span class="sd">        MomSpaceBasis.kvec() returns all momentum vectors</span>
<span class="sd">        </span>
<span class="sd">        param indx: index of k-vector to be returned, optional</span>
<span class="sd">        return 3-vector (if index non-negative), or all vectors if no index specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kvec</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">nvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indx</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MomSpaceBasis.nvec(i) returns ith lattice vector</span>
<span class="sd">        MomSpaceBasis.nvec() returns all lattice vectors</span>
<span class="sd">        </span>
<span class="sd">        param indx: index of lattice vector to be returned, optional</span>
<span class="sd">        return 3-vector (if index non-negative), or all lattice vectors if no index specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">dens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns density of system if num particles are present</span>
<span class="sd">        param num: int, number of particles</span>
<span class="sd">        return dens: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lbox</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
    
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dk</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses dk as new lattice spacing and rescales existing lattice</span>
<span class="sd">        param dk: in 1/fm lattice spacing in momentum space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lbox</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">dk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nvec</span><span class="p">)</span><span class="o">*</span><span class="n">dk</span>
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        overloading of the &#39;len&#39; function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span>
    
    
<span class="c1">############</span>
<span class="c1"># useful functions</span>

<span class="k">def</span> <span class="nf">magic_numbers</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param basis: MomSpaceBasis object</span>
<span class="sd">    return magic: array of magic numbers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nvecs</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">nvec</span><span class="p">()</span>
    <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nvecs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">vec</span><span class="p">)</span>
    <span class="n">magic</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nvecs</span><span class="p">)):</span>
        <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">norm2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm2</span> <span class="o">&gt;</span> <span class="n">norm</span><span class="p">:</span> 
            <span class="n">magic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm2</span>
    <span class="k">return</span> <span class="n">magic</span>


<span class="k">def</span> <span class="nf">get_dk</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">Num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param rho: desired density</span>
<span class="sd">    param Num: magic number of particles</span>
<span class="sd">    return dk: grid spacing in momentum space (in 1/fm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Lbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">Num</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">dk</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">Lbox</span>
    <span class="k">return</span> <span class="n">dk</span>

<span class="k">def</span> <span class="nf">spbasis_from_MomSpaceBasis</span><span class="p">(</span><span class="n">lattice_vecs</span><span class="p">,</span><span class="n">st_degen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    converts a lattice to a single particle basis for spin-isospin degeneracy st_degen</span>
<span class="sd">    param lattice_vecs: list of lattice vectors for 1st particle</span>
<span class="sd">    param st_degen: spin-isospin degeneracy</span>
<span class="sd">    return: basis as a list of momenta</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">st_degen</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># for now only neutron matter</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unexpected parameter st_degen&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lattice_vecs</span>
    
    <span class="n">basis</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">lattice_vecs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">st_degen</span><span class="p">):</span>
            <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            
    <span class="k">return</span> <span class="n">basis</span>



<span class="c1">#########################################################</span>
<span class="c1"># Functions for comparisons with infinite free Fermi gas</span>
                         
<span class="k">def</span> <span class="nf">kF_from_density</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">st_degen</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Fermi momentum for given density and spin/isospin degeneracy.</span>
<span class="sd">    </span>
<span class="sd">    param rho: density in inverse fm cubed</span>
<span class="sd">    param st_degen: spin-isospin degeneracy; default 2</span>
<span class="sd">    return: Fermi momentum in inverse fm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mf">6.0</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="o">/</span><span class="n">st_degen</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">EnergyDensity_FermiGas</span><span class="p">(</span><span class="n">kF</span><span class="p">,</span><span class="n">st_degen</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes energy density of free Fermi gas at Fermi momentum and spin/isospin degeneracy</span>
<span class="sd">    param kF: Fermi momentum in inverse fm</span>
<span class="sd">    param st_degen: spin-isospin degeneracy; default 2</span>
<span class="sd">    return: Energy density in MeV/fm**3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kF</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
    <span class="n">erg</span> <span class="o">=</span> <span class="p">(</span><span class="n">st_degen</span><span class="o">*</span><span class="n">kF</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mf">10.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Tkin</span><span class="p">(</span><span class="n">pvec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">erg</span>


<span class="c1">########################################################################################</span>
<span class="c1"># Functions for CCD of neutron matter</span>
<span class="c1"># Implementation uses only pp and hh ladders</span>
<span class="c1"># </span>
<span class="c1">########################################################################################</span>


<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>  
<span class="c1"># compile a few functions to gain speed; should probably done in Fortran or C++, </span>
<span class="c1"># and called from Python</span>

<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">minnesota_nn</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">s1_out</span><span class="p">,</span><span class="n">s2_out</span><span class="p">,</span><span class="n">p_in</span><span class="p">,</span><span class="n">s1_in</span><span class="p">,</span><span class="n">s2_in</span><span class="p">,</span><span class="n">Lbox</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Minnesota potential between two neutrons, not yet anti-symmetrized </span>
<span class="sd">    param p_out: relative out momentum</span>
<span class="sd">    param p_in : relative in momentum</span>
<span class="sd">    param s1_out, s2_out: spin projections of out particles 1 and 2</span>
<span class="sd">    param s1_in, s2_in  : spin projections of in particles 1 and 2</span>
<span class="sd">    Lbox : size of momentum box</span>
<span class="sd">    return: value of potential in MeV; not anti-symmetrized!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># parameters. VT is not active between two neutrons (no triplet)</span>
    <span class="n">VR</span> <span class="o">=</span> <span class="mf">200.0</span>
    <span class="n">VS</span> <span class="o">=</span> <span class="o">-</span><span class="mf">91.85</span>  <span class="c1"># sign typo in Lecture Notes Physics 936, Chap. 8</span>
    <span class="n">kappaR</span> <span class="o">=</span> <span class="mf">1.487</span>
    <span class="n">kappaS</span> <span class="o">=</span> <span class="mf">0.465</span>
    
    <span class="n">qvec</span><span class="o">=</span><span class="n">p_out</span><span class="o">-</span><span class="n">p_in</span>
    <span class="n">q2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">qvec</span><span class="p">,</span><span class="n">qvec</span><span class="p">)</span>
    
    <span class="n">s1_i</span> <span class="o">=</span><span class="n">spin2spinor</span><span class="p">(</span><span class="n">s1_in</span><span class="p">)</span>
    <span class="n">s2_i</span> <span class="o">=</span><span class="n">spin2spinor</span><span class="p">(</span><span class="n">s2_in</span><span class="p">)</span>
    <span class="n">s1_o</span> <span class="o">=</span><span class="n">spin2spinor</span><span class="p">(</span><span class="n">s1_out</span><span class="p">)</span>
    <span class="n">s2_o</span> <span class="o">=</span><span class="n">spin2spinor</span><span class="p">(</span><span class="n">s2_out</span><span class="p">)</span>
    
    <span class="n">spin_part</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s1_i</span><span class="p">,</span><span class="n">s1_o</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s2_i</span><span class="p">,</span><span class="n">s2_o</span><span class="p">)</span>
                       <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s1_i</span><span class="p">,</span><span class="n">s2_o</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s2_i</span><span class="p">,</span><span class="n">s1_o</span><span class="p">)</span> <span class="p">)</span>
    
    
    <span class="n">pot</span> <span class="o">=</span> <span class="n">spin_part</span> <span class="o">*</span> <span class="p">(</span>  <span class="n">VR</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">q2</span><span class="o">/</span><span class="n">kappaR</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Lbox</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappaR</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span> 
                       <span class="o">+</span> <span class="n">VS</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">q2</span><span class="o">/</span><span class="n">kappaS</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Lbox</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappaS</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span> <span class="p">)</span>
    
    <span class="n">pot</span> <span class="o">=</span> <span class="n">pot</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span> 

    
    <span class="k">return</span> <span class="n">pot</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">spin_of_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Even indices of the lattive have spin up, odds have spin down</span>
<span class="sd">    param i: index of sp_basis</span>
<span class="sd">    return: spin as +/- 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spin</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spin</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">spin2spinor</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a two-component spinor of an integer s</span>
<span class="sd">    param s: spin = +/- 1</span>
<span class="sd">    return: two-component numpy array [1,0] for up and [0,1] for down</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">up</span>  <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
    <span class="n">down</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">up</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">down</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Tkin</span><span class="p">(</span><span class="n">pvec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kinetic energy for a momentum vector</span>
<span class="sd">    param pvec: 3-component numpy array in inverse fm</span>
<span class="sd">    return: kinetic energy of that momentum in MeV</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nucleon_mass</span> <span class="o">=</span> <span class="mf">938.92</span>
    <span class="n">hbarc</span> <span class="o">=</span> <span class="mf">197.33</span>
<span class="c1"># More precise numbers for neutron mass and hbar follow.</span>
<span class="c1"># For N=14, this yields E_HF = 10.3337 MeV per nucleon in HF. Benchmarked with Ragnar Stroberg.</span>
<span class="c1">#     nucleon_mass = 939.56563</span>
<span class="c1">#     hbarc = 197.3269718</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span><span class="n">pvec</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">hbarc</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">p2</span><span class="o">/</span><span class="n">nucleon_mass</span>
    <span class="k">return</span> <span class="n">res</span>
    
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">compute_total_Tkin</span><span class="p">(</span><span class="n">Nocc</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">dk</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total kinetic energy of reference state</span>
<span class="sd">    param Nocc, sp_basis, dk: particle number, integer s.p. lattice, delta k </span>
<span class="sd">    return: total kinetic energy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">erg</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nocc</span><span class="p">):</span>
        <span class="n">mom_vec</span> <span class="o">=</span> <span class="n">sp_basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mom_vec</span><span class="p">)</span><span class="o">*</span><span class="n">dk</span>
        <span class="n">erg</span><span class="o">=</span><span class="n">erg</span><span class="o">+</span><span class="n">Tkin</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">erg</span>



<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Fock</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">Nocc</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fock matrix of momentum pvec in hh space</span>
<span class="sd">    param pvec: 3-component numpy array in inverse fm</span>
<span class="sd">    param s: spin as +/- 1 of state</span>
<span class="sd">    param_sp_basis, Nocc, dk, Lbox : parameters of s.p. basis and system</span>
<span class="sd">    </span>
<span class="sd">    return: Fock matrix element = kinetic energy of that momentum in MeV</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Tkin</span><span class="p">(</span><span class="n">pvec</span><span class="p">)</span>
    
    <span class="n">dum</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nocc</span><span class="p">):</span>
        <span class="n">vec</span><span class="o">=</span><span class="n">sp_basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dk</span>
        <span class="n">si</span><span class="o">=</span><span class="n">spin_of_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">p_in</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">vec</span><span class="o">-</span><span class="n">pvec</span><span class="p">)</span>
        <span class="n">p_out</span><span class="o">=</span> <span class="n">p_in</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">dum</span> <span class="o">+</span> <span class="p">(</span> <span class="n">minnesota_nn</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">si</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span> 
                     <span class="o">-</span><span class="n">minnesota_nn</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="o">-</span><span class="n">p_in</span><span class="p">,</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">#antisymmetrized Minnesota</span>
        
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">+</span><span class="n">dum</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">compute_E_HF_simple</span><span class="p">(</span><span class="n">Nocc</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">dk</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes HF energy of reference state</span>
<span class="sd">    param Nocc, sp_basis, dk: particle number, integer s.p. lattice, delta k </span>
<span class="sd">    return: total HF energy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">erg</span><span class="o">=</span><span class="n">compute_total_Tkin</span><span class="p">(</span><span class="n">Nocc</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">dk</span><span class="p">)</span>

    <span class="n">pot</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nocc</span><span class="p">):</span>
        <span class="n">momi</span><span class="o">=</span><span class="n">sp_basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dk</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">spin_of_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nocc</span><span class="p">):</span>
            <span class="n">momj</span><span class="o">=</span><span class="n">sp_basis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">dk</span>
            <span class="n">sj</span> <span class="o">=</span> <span class="n">spin_of_index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">p_rel</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">momi</span><span class="o">-</span><span class="n">momj</span><span class="p">)</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="n">pot</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span> <span class="p">(</span>  <span class="n">minnesota_nn</span><span class="p">(</span><span class="n">p_rel</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">sj</span><span class="p">,</span> <span class="n">p_rel</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">sj</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span>
                                <span class="o">-</span> <span class="n">minnesota_nn</span><span class="p">(</span><span class="n">p_rel</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">sj</span><span class="p">,</span><span class="o">-</span><span class="n">p_rel</span><span class="p">,</span><span class="n">sj</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span> <span class="p">)</span>
            
    <span class="n">erg</span> <span class="o">=</span> <span class="n">erg</span><span class="o">+</span><span class="n">pot</span>
    <span class="k">return</span> <span class="n">erg</span>


<span class="k">def</span> <span class="nf">get_channels</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">start1</span><span class="p">,</span><span class="n">end1</span><span class="p">,</span><span class="n">start2</span><span class="p">,</span><span class="n">end2</span><span class="p">,</span><span class="n">identical</span><span class="p">,</span><span class="n">other_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns channels for coupled cluster based on Minnesota potential</span>
<span class="sd">    param sp_Basis: A single-particle basis</span>
<span class="sd">    param start1: index to start for particle 1</span>
<span class="sd">    param end1: index to end for particle 1</span>
<span class="sd">    param start2: index to start for particle 2</span>
<span class="sd">    param end2: index to end for particle 2</span>
<span class="sd">    param identical: True for hh or pp, False for hp</span>
<span class="sd">    param other_channels: list of other channels to compare with</span>
<span class="sd">    return: channels, p_rel, t2amp. channels is a list of p12, where p12 is a momentum vector; </span>
<span class="sd">            p_rel is a nested list with relative momenta and spins for each channel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">channel</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">p_rel</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mom_vecs1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">[</span><span class="n">start1</span><span class="p">:</span><span class="n">end1</span><span class="p">]):</span>
        <span class="c1">#vec1=np.array(mom_vecs1,dtype=int)</span>
        <span class="n">vec1</span><span class="o">=</span><span class="n">mom_vecs1</span>
        <span class="n">spin1</span><span class="o">=</span><span class="n">spin_of_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">mom_vecs2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">[</span><span class="n">start2</span><span class="p">:</span><span class="n">end2</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">identical</span> <span class="ow">and</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span> <span class="k">continue</span>  <span class="c1">#Fortran cycle</span>
            <span class="c1">#vec2=np.array(mom_vecs2,dtype=int)</span>
            <span class="n">vec2</span><span class="o">=</span><span class="n">mom_vecs2</span>
            <span class="n">spin2</span><span class="o">=</span><span class="n">spin_of_index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                
            <span class="n">p12</span> <span class="o">=</span> <span class="n">vec1</span><span class="o">+</span><span class="n">vec2</span>
            <span class="n">prel</span><span class="o">=</span> <span class="n">vec1</span><span class="o">-</span><span class="n">vec2</span>
            <span class="n">spins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spin1</span><span class="p">,</span><span class="n">spin2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ps</span><span class="o">=</span><span class="p">[</span><span class="n">prel</span><span class="p">,</span><span class="n">spins</span><span class="p">]</span>

            <span class="n">new</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">needed</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">if</span> <span class="n">other_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#check whether we need this channel</span>
                <span class="n">needed</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">for</span> <span class="n">chan_o</span> <span class="ow">in</span> <span class="n">other_channels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">chan_o</span><span class="o">==</span><span class="n">p12</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> 
                        <span class="n">needed</span><span class="o">=</span><span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">needed</span><span class="p">:</span> <span class="c1">#check whether this channel exists already</span>
                <span class="k">for</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">==</span><span class="n">p12</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> 
                        <span class="n">new</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">break</span>
                    
            <span class="k">if</span> <span class="n">needed</span> <span class="ow">and</span> <span class="n">new</span><span class="p">:</span> 
                <span class="n">channel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p12</span><span class="p">)</span>
                <span class="n">p_rel</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ps</span><span class="p">])</span>
                
            <span class="k">if</span> <span class="n">needed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">p_rel</span><span class="p">[</span><span class="n">ipos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">channel</span><span class="p">,</span> <span class="n">p_rel</span> 
    

    
<span class="k">def</span> <span class="nf">setup_T2_amplitudes</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">st_degen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns the t2 amplitudes and t2 channels</span>
<span class="sd">    param sp_basis: a sp_basis</span>
<span class="sd">    param NN: neutron number</span>
<span class="sd">    param st_degen: 2 for the moment, spin-isospin degeneracy</span>
<span class="sd">    return: hh_channels, pp_channels, p_rel_hh, p_rel_pp, t2amp</span>
<span class="sd">            these are the hh and pp channels of T2, lists of the relative momenta, </span>
<span class="sd">            and t2amps as a list of numpy arrays set to zero </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">)</span>
    
    <span class="n">hh_channels</span><span class="p">,</span> <span class="n">p_rel_hh</span> <span class="o">=</span> <span class="n">get_channels</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hh channels=&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hh_channels</span><span class="p">))</span>

    <span class="n">pp_channels</span><span class="p">,</span> <span class="n">p_rel_pp</span> <span class="o">=</span> <span class="n">get_channels</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">num_states</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">num_states</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="n">hh_channels</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pp channels=&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp_channels</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp_channels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hh_channels</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pp and hh channels do not match&#39;</span><span class="p">)</span>
     

    <span class="n">ordered_pp_channel</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ordered_p_rel_pp</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chanhh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hh_channels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">chanpp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pp_channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">chanpp</span><span class="o">==</span><span class="n">chanhh</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">ordered_pp_channel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chanpp</span><span class="p">)</span>
                <span class="n">ordered_p_rel_pp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_rel_pp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>    
                <span class="k">break</span>
                
    <span class="n">pp_channels</span> <span class="o">=</span> <span class="n">ordered_pp_channel</span>
    <span class="n">p_rel_pp</span> <span class="o">=</span> <span class="n">ordered_p_rel_pp</span>
            
    <span class="c1"># set t2 amplitudes to zero in each channel</span>
    <span class="n">t2amp</span> <span class="o">=</span> <span class="n">fill_pot</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">pp_channels</span><span class="p">,</span> <span class="n">hh_channels</span><span class="p">,</span> <span class="n">p_rel_pp</span><span class="p">,</span> <span class="n">p_rel_hh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">hh_channels</span><span class="p">,</span> <span class="n">pp_channels</span><span class="p">,</span> <span class="n">p_rel_hh</span><span class="p">,</span> <span class="n">p_rel_pp</span><span class="p">,</span> <span class="n">t2amp</span>

<span class="k">def</span> <span class="nf">fill_pot</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">channels_out</span><span class="p">,</span> <span class="n">channels_in</span><span class="p">,</span> <span class="n">p_rel_out</span><span class="p">,</span> <span class="n">p_rel_in</span><span class="p">,</span> <span class="n">T2amp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fills lists of matrices such as Vhhhh, Vpphh, Vpppp, t2_pphh</span>
<span class="sd">    param Lbox: Lbox</span>
<span class="sd">    param dk: dk</span>
<span class="sd">    param channels_out, channels_in: the channels we have</span>
<span class="sd">    param p_rel_out, p_rel_in: the list of [prel, [s1,s2]]</span>
<span class="sd">    param T2amp=False: Set to True if t2_pphh needs to be computed</span>
<span class="sd">    return: The object of desire as a list of numpy matrices. </span>
<span class="sd">            Contain matrix elements for potentials, zeros if T2amp=True is requested. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Vpot</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan_in</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels_in</span><span class="p">):</span>
        <span class="n">dim_in</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_rel_in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">dim_out</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_rel_out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">Vpot_chan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_out</span><span class="p">,</span><span class="n">dim_in</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">T2amp</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ps_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_in</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="p">[</span><span class="n">pii</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ps_i</span>
                <span class="n">pii</span> <span class="o">=</span> <span class="n">pii</span><span class="o">*</span><span class="n">dk</span><span class="o">*</span><span class="mf">0.5</span>
                <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">ps_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_out</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">dim_in</span> <span class="o">==</span> <span class="n">dim_out</span> <span class="ow">and</span> <span class="n">jj</span> <span class="o">&gt;</span> <span class="n">ii</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="p">[</span><span class="n">pjj</span><span class="p">,</span> <span class="p">[</span><span class="n">ss1</span><span class="p">,</span> <span class="n">ss2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ps_j</span>
                    <span class="n">pjj</span> <span class="o">=</span> <span class="n">pjj</span><span class="o">*</span><span class="n">dk</span><span class="o">*</span><span class="mf">0.5</span>
                    <span class="n">Vpot_chan</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">minnesota_nn</span><span class="p">(</span> <span class="n">pjj</span><span class="p">,</span><span class="n">ss1</span><span class="p">,</span><span class="n">ss2</span><span class="p">,</span> <span class="n">pii</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span>
                                        <span class="o">-</span><span class="n">minnesota_nn</span><span class="p">(</span><span class="o">-</span><span class="n">pjj</span><span class="p">,</span><span class="n">ss2</span><span class="p">,</span><span class="n">ss1</span><span class="p">,</span> <span class="n">pii</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">dim_in</span> <span class="o">==</span> <span class="n">dim_out</span> <span class="p">:</span> <span class="n">Vpot_chan</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vpot_chan</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span>
        
        <span class="n">Vpot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Vpot_chan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Vpot</span>


<span class="k">def</span> <span class="nf">init_V</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">hhchannels</span><span class="p">,</span> <span class="n">ppchannels</span><span class="p">,</span> <span class="n">p_relhh</span><span class="p">,</span> <span class="n">p_relpp</span><span class="p">,</span><span class="n">zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets up Vhhhh, Vpphh, and Vpppp. </span>
<span class="sd">    </span>
<span class="sd">    return: Vhhhh, Vpphh, Vpppp as a lists of numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Vhhhh</span> <span class="o">=</span> <span class="n">fill_pot</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">hhchannels</span><span class="p">,</span> <span class="n">hhchannels</span><span class="p">,</span> <span class="n">p_relhh</span><span class="p">,</span> <span class="n">p_relhh</span><span class="p">,</span><span class="n">zeros</span><span class="p">)</span>
    <span class="n">Vpphh</span> <span class="o">=</span> <span class="n">fill_pot</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">ppchannels</span><span class="p">,</span> <span class="n">hhchannels</span><span class="p">,</span> <span class="n">p_relpp</span><span class="p">,</span> <span class="n">p_relhh</span><span class="p">,</span><span class="n">zeros</span><span class="p">)</span>
    <span class="n">Vpppp</span> <span class="o">=</span> <span class="n">fill_pot</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">ppchannels</span><span class="p">,</span> <span class="n">ppchannels</span><span class="p">,</span> <span class="n">p_relpp</span><span class="p">,</span> <span class="n">p_relpp</span><span class="p">,</span><span class="n">zeros</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Vhhhh</span><span class="p">,</span> <span class="n">Vpphh</span><span class="p">,</span> <span class="n">Vpppp</span>  
            
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">make_diagram</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span><span class="n">obj2</span><span class="p">,</span><span class="n">fac</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes diagrams for pp or hh ladders as matrix-matrix multiplications</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hbar_pphh</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">dim1</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim1</span><span class="p">):</span>
        <span class="n">mat1</span> <span class="o">=</span> <span class="n">obj1</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span>
        <span class="n">mat2</span> <span class="o">=</span> <span class="n">obj2</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span>
        <span class="n">hbar_pphh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">fac</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span><span class="n">mat2</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">hbar_pphh</span>


<span class="k">def</span> <span class="nf">make_diagrams2_3</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">,</span><span class="n">fabij</span><span class="p">):</span>
    <span class="n">hbar_pphh</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t2_mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">):</span>
        <span class="n">f_mat</span> <span class="o">=</span> <span class="n">fabij</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">hbar_mat</span> <span class="o">=</span> <span class="n">t2_mat</span><span class="o">*</span><span class="n">f_mat</span>
        <span class="n">hbar_pphh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hbar_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hbar_pphh</span>


<span class="k">def</span> <span class="nf">compute_hbar</span><span class="p">(</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">,</span><span class="n">t2_pphh</span><span class="p">,</span><span class="n">fabij</span><span class="p">):</span>
    <span class="n">diagram1</span> <span class="o">=</span> <span class="n">v_pphh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">diagram23</span> <span class="o">=</span> <span class="n">make_diagrams2_3</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">,</span> <span class="n">fabij</span><span class="p">)</span>
    <span class="n">diagram4</span> <span class="o">=</span> <span class="n">make_diagram</span><span class="p">(</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">t2_pphh</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">diagram5</span> <span class="o">=</span> <span class="n">make_diagram</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
    
    <span class="n">hbar_pphh</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">)):</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">(</span>  <span class="n">diagram1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">diagram23</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">diagram4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">diagram5</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="p">)</span>
        <span class="n">hbar_pphh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">hbar_pphh</span>
    
<span class="k">def</span> <span class="nf">get_energy_denominator</span><span class="p">(</span><span class="n">hh_channels</span><span class="p">,</span><span class="n">p_rel_pp</span><span class="p">,</span><span class="n">p_rel_hh</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">Nocc</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">):</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">fabij</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Ptot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hh_channels</span><span class="p">):</span>
        <span class="n">dimhh</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">p_rel_hh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">dimpp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">p_rel_pp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">res_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dimpp</span><span class="p">,</span><span class="n">dimhh</span><span class="p">))</span>
        <span class="n">f_mat</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dimpp</span><span class="p">,</span><span class="n">dimhh</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">psh_rel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_hh</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="p">[</span><span class="n">pij</span><span class="p">,</span> <span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">]]</span> <span class="o">=</span> <span class="n">psh_rel</span>  
            <span class="n">p_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ptot</span><span class="o">+</span><span class="n">pij</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">p_i</span> <span class="o">=</span> <span class="n">p_i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">p_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ptot</span><span class="o">-</span><span class="n">pij</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">p_j</span> <span class="o">=</span> <span class="n">p_j</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ssi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">si</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">ssj</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sj</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">fii</span> <span class="o">=</span> <span class="n">fock_mtx4</span><span class="p">[</span><span class="n">p_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p_i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ssi</span><span class="p">]</span>
            <span class="n">fjj</span> <span class="o">=</span> <span class="n">fock_mtx4</span><span class="p">[</span><span class="n">p_j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_j</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p_j</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ssj</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">psp_rel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="p">[</span><span class="n">pab</span><span class="p">,</span> <span class="p">[</span><span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">]]</span> <span class="o">=</span> <span class="n">psp_rel</span>
                <span class="n">p_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ptot</span><span class="o">+</span><span class="n">pab</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">p_a</span> <span class="o">=</span> <span class="n">p_a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">p_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ptot</span><span class="o">-</span><span class="n">pab</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">p_b</span> <span class="o">=</span> <span class="n">p_b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">,</span><span class="n">Nmax</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">ssa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sa</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">ssb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sb</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">faa</span> <span class="o">=</span> <span class="n">fock_mtx4</span><span class="p">[</span><span class="n">p_a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p_a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ssa</span><span class="p">]</span>
                <span class="n">fbb</span> <span class="o">=</span> <span class="n">fock_mtx4</span><span class="p">[</span><span class="n">p_b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p_b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ssb</span><span class="p">]</span>
                
                <span class="n">res_mat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">fii</span> <span class="o">+</span> <span class="n">fjj</span> <span class="o">-</span> <span class="n">faa</span> <span class="o">-</span> <span class="n">fbb</span><span class="p">)</span> 
                <span class="n">f_mat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">faa</span> <span class="o">+</span> <span class="n">fbb</span> <span class="o">-</span> <span class="n">fii</span> <span class="o">-</span> <span class="n">fjj</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_mat</span><span class="p">)</span>
        <span class="n">fabij</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">fabij</span>


<span class="k">def</span> <span class="nf">get_t2_from_mbpt</span><span class="p">(</span><span class="n">Vpphh</span><span class="p">,</span><span class="n">denom</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param Vpphh: Vpphh</span>
<span class="sd">    param denom: energy denominator in pphh format</span>
<span class="sd">    return t2: quotient of both, element for element </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Vpphh</span><span class="p">):</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">denom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">res_mat</span> <span class="o">=</span> <span class="n">vv</span><span class="o">*</span><span class="n">dd</span>  <span class="c1">#how simple in python; element by element multiply</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">compute_E_CCD</span><span class="p">(</span><span class="n">Vpphh</span><span class="p">,</span><span class="n">T2pphh</span><span class="p">):</span>
    <span class="n">erg</span><span class="o">=</span><span class="mf">0.0</span>
<span class="c1">#     erg2=0.0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t2mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">T2pphh</span><span class="p">):</span>
        <span class="n">vmat</span>  <span class="o">=</span> <span class="n">Vpphh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">erg</span> <span class="o">=</span> <span class="n">erg</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vmat</span><span class="o">*</span><span class="n">t2mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">erg</span>


<span class="k">def</span> <span class="nf">compute_Fock_4</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">Nocc</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">,</span><span class="n">Nmax</span><span class="p">):</span>
    <span class="n">fock_mtx4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">Nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">Nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">):</span>
        <span class="n">pvec</span><span class="o">=</span><span class="n">vec</span><span class="o">*</span><span class="n">dk</span>
        <span class="n">spin</span><span class="o">=</span><span class="n">spin_of_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">si</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">spin</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">px</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Nmax</span>
        <span class="n">py</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">Nmax</span>
        <span class="n">pz</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">Nmax</span>
        <span class="n">fock_mtx4</span><span class="p">[</span><span class="n">px</span><span class="p">,</span><span class="n">py</span><span class="p">,</span><span class="n">pz</span><span class="p">,</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fock</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span><span class="n">spin</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">Nocc</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fock_mtx4</span>

<span class="c1">#####################################</span>
<span class="c1">########### Main Program starts here    </span>

<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
<span class="c1"># for timing purposes</span>

<span class="n">progstart</span><span class="o">=</span><span class="n">timer</span><span class="p">()</span>

<span class="n">Nmax</span><span class="o">=</span><span class="mi">1</span>
<span class="n">kmax</span><span class="o">=</span><span class="mf">1.0</span>
<span class="n">mbase</span> <span class="o">=</span> <span class="n">MomSpaceBasis</span><span class="p">(</span><span class="n">Nmax</span><span class="p">,</span><span class="n">kmax</span><span class="p">)</span>
<span class="n">lattice</span><span class="o">=</span><span class="n">mbase</span><span class="o">.</span><span class="n">nvec</span><span class="p">()</span>

<span class="c1">## set particle number</span>
<span class="n">NN</span><span class="o">=</span><span class="mi">14</span>
<span class="n">st_degen</span><span class="o">=</span><span class="mi">2</span>  <span class="c1"># spin up and down</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chosen N =&quot;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;magic numbers&quot;</span><span class="p">,</span> <span class="n">magic_numbers</span><span class="p">(</span><span class="n">mbase</span><span class="p">))</span>

<span class="c1">## set density</span>
<span class="n">rho</span><span class="o">=</span><span class="mf">0.08</span>

<span class="n">dk</span> <span class="o">=</span> <span class="n">get_dk</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">NN</span><span class="p">)</span>

<span class="n">mbase</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span>
<span class="n">Lbox</span> <span class="o">=</span> <span class="n">mbase</span><span class="o">.</span><span class="n">Lbox</span>


<span class="c1">## get single particle basis</span>

<span class="n">sp_basis</span> <span class="o">=</span> <span class="n">spbasis_from_MomSpaceBasis</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span><span class="n">st_degen</span><span class="p">)</span>
<span class="n">num_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of s.p. states:&#39;</span><span class="p">,</span> <span class="n">num_states</span><span class="p">)</span>

<span class="c1"># print out a few facts of the reference state</span>
<span class="n">total_Tkin</span> <span class="o">=</span> <span class="n">compute_total_Tkin</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">dk</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total Tkin per particle =&#39;</span><span class="p">,</span> <span class="n">total_Tkin</span><span class="o">/</span><span class="n">NN</span> <span class="p">)</span>

<span class="n">k_fermi</span> <span class="o">=</span> <span class="n">kF_from_density</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fermi momentum =&quot;</span><span class="p">,</span> <span class="n">k_fermi</span><span class="p">)</span>

<span class="n">E_gas</span> <span class="o">=</span> <span class="n">EnergyDensity_FermiGas</span><span class="p">(</span><span class="n">k_fermi</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy per neutron of infinite free Fermi gas&quot;</span><span class="p">,</span> <span class="n">E_gas</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>

<span class="n">E_HF</span> <span class="o">=</span> <span class="n">compute_E_HF_simple</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">dk</span><span class="p">)</span>
<span class="n">E_HF</span> <span class="o">=</span> <span class="n">E_HF</span><span class="o">/</span><span class="n">NN</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HF energy per neutron =&quot;</span><span class="p">,</span> <span class="n">E_HF</span><span class="p">)</span>

<span class="c1">## now we start our business ...</span>
<span class="c1">## get all channels and two-body states within those channels; set T2 to zero</span>
<span class="n">hh_channels</span><span class="p">,</span> <span class="n">pp_channels</span><span class="p">,</span> <span class="n">p_rel_hh</span><span class="p">,</span> <span class="n">p_rel_pp</span><span class="p">,</span> <span class="n">t2_pphh</span> <span class="o">=</span> <span class="n">setup_T2_amplitudes</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">st_degen</span><span class="p">)</span>

<span class="c1"># get some insight in how big this all is</span>
<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_hh</span><span class="p">):</span>
    <span class="n">dim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">p_rel_hh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="o">+</span><span class="n">dim</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hh number of total combinations&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_rel_pp</span><span class="p">):</span>
    <span class="n">dim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">p_rel_pp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="o">+</span><span class="n">dim</span>
    
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pp number of total combinations&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;get v_hhhh, v_pphh, v_pppp&quot;</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
<span class="n">v_hhhh</span><span class="p">,</span> <span class="n">v_pphh</span><span class="p">,</span> <span class="n">v_pppp</span> <span class="o">=</span> <span class="n">init_V</span><span class="p">(</span><span class="n">Lbox</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">hh_channels</span><span class="p">,</span> <span class="n">pp_channels</span><span class="p">,</span> <span class="n">p_rel_hh</span><span class="p">,</span> <span class="n">p_rel_pp</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;what a hog!&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;seconds&#39;</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compute energy denominator&quot;</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
<span class="n">fock_mtx4</span> <span class="o">=</span> <span class="n">compute_Fock_4</span><span class="p">(</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">,</span><span class="n">Nmax</span><span class="p">)</span>
<span class="n">denom_pphh</span><span class="p">,</span> <span class="n">f_abij</span> <span class="o">=</span> <span class="n">get_energy_denominator</span><span class="p">(</span><span class="n">pp_channels</span><span class="p">,</span><span class="n">p_rel_pp</span><span class="p">,</span><span class="n">p_rel_hh</span><span class="p">,</span><span class="n">sp_basis</span><span class="p">,</span><span class="n">NN</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">Lbox</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;that&#39;s faster&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;seconds&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initialize T2 from MBPT2&quot;</span><span class="p">)</span>
<span class="n">t2_pphh</span> <span class="o">=</span> <span class="n">get_t2_from_mbpt</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">denom_pphh</span><span class="p">)</span>

<span class="n">erg</span> <span class="o">=</span> <span class="n">compute_E_CCD</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2_pphh</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;MBPT2 correlation energy per neutron =&#39;</span><span class="p">,</span> <span class="n">erg</span><span class="o">/</span><span class="n">NN</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start CCD iterations ...&quot;</span><span class="p">)</span>

<span class="n">niter</span><span class="o">=</span><span class="mi">200</span>
<span class="n">mix</span><span class="o">=</span><span class="mf">0.99</span>
<span class="n">erg_old</span><span class="o">=</span><span class="mf">0.0</span>
<span class="n">eps</span><span class="o">=</span><span class="mf">1.e-8</span>
<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
    
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">hbar_pphh</span> <span class="o">=</span> <span class="n">compute_hbar</span><span class="p">(</span><span class="n">v_pppp</span><span class="p">,</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">v_hhhh</span><span class="p">,</span><span class="n">t2_pphh</span><span class="p">,</span><span class="n">f_abij</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time of making Hbar:&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;seconds&#39;</span><span class="p">)</span>
    
    <span class="n">t2_new</span> <span class="o">=</span> <span class="n">get_t2_from_mbpt</span><span class="p">(</span><span class="n">hbar_pphh</span><span class="p">,</span><span class="n">denom_pphh</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t2_new</span><span class="p">)):</span>
        <span class="n">t2_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2_pphh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">t2_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="n">erg</span> <span class="o">=</span> <span class="n">compute_E_CCD</span><span class="p">(</span><span class="n">v_pphh</span><span class="p">,</span><span class="n">t2_new</span><span class="p">)</span>
    
    <span class="n">myeps</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">erg</span><span class="o">-</span><span class="n">erg_old</span><span class="p">)</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">erg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">myeps</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">erg_old</span><span class="o">=</span><span class="n">erg</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;iter=&quot;</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="s2">&quot;Correlation energy per neutron=&quot;</span><span class="p">,</span> <span class="n">erg</span><span class="o">/</span><span class="n">NN</span><span class="p">,</span> <span class="s2">&quot;, epsilon=&quot;</span><span class="p">,</span> <span class="n">myeps</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t2_pphh</span><span class="p">)):</span>
        <span class="n">t2_pphh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix</span><span class="o">*</span><span class="n">t2_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mix</span><span class="p">)</span><span class="o">*</span><span class="n">t2_pphh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correlation energy per neutron= &quot;</span><span class="p">,</span> <span class="n">erg</span><span class="o">/</span><span class="n">NN</span><span class="p">)</span>

<span class="n">progend</span><span class="o">=</span><span class="n">timer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total time in seconds&#39;</span><span class="p">,</span> <span class="n">progend</span><span class="o">-</span><span class="n">progstart</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>chosen N = 14
magic numbers [2, 14, 38]
number of s.p. states: 54
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:309: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITH looplifting enabled because Function &quot;compute_total_Tkin&quot; failed type inference due to: No implementation of function Function(&lt;built-in function array&gt;) found for signature:</span>
<span class=" -Color -Color-Bold"> </span>
<span class=" -Color -Color-Bold"> &gt;&gt;&gt; array(array(int64, 1d, C))</span>
<span class=" -Color -Color-Bold"> </span>
<span class=" -Color -Color-Bold">There are 4 candidate implementations:</span>
<span class=" -Color -Color-Bold">  - Of which 4 did not match due to:</span>
<span class=" -Color -Color-Bold">  Overload in function &#39;_OverloadWrapper._build.&lt;locals&gt;.ol_generated&#39;: File: numba/core/overload_glue.py: Line 129.</span>
<span class=" -Color -Color-Bold">    With argument(s): &#39;(array(int64, 1d, C))&#39;:</span>
<span class=" -Color -Color-Bold">   Rejected as the implementation raised a specific error:</span>
<span class=" -Color -Color-Bold">     TypingError: array(int64, 1d, C) not allowed in a homogeneous sequence</span>
  raised from /Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/typing/npydecl.py:488

<span class=" -Color -Color-Bold">During: resolving callee type: Function(&lt;built-in function array&gt;)</span>
<span class=" -Color -Color-Bold">During: typing of call at /var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py (319)</span>


<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 319:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:309: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITHOUT looplifting enabled because Function &quot;compute_total_Tkin&quot; failed type inference due to: Cannot determine Numba type of &lt;class &#39;numba.core.dispatcher.LiftedLoop&#39;&gt;</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 317:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:151: NumbaWarning: <span class=" -Color -Color-Bold">Function &quot;compute_total_Tkin&quot; was compiled in object mode without forceobj=True, but has lifted loops.</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 316:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaWarning(warn_msg,
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:161: NumbaDeprecationWarning: 
<span class=" -Color -Color-Bold">Fall-back from the nopython compilation path to the object mode compilation path has been detected, this is deprecated behaviour.</span>

<span class=" -Color -Color-Bold">For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 316:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaDeprecationWarning(msg,
/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:309: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITHOUT looplifting enabled because Function &quot;compute_total_Tkin&quot; failed type inference due to: No implementation of function Function(&lt;built-in function array&gt;) found for signature:</span>
<span class=" -Color -Color-Bold"> </span>
<span class=" -Color -Color-Bold"> &gt;&gt;&gt; array(array(int64, 1d, C))</span>
<span class=" -Color -Color-Bold"> </span>
<span class=" -Color -Color-Bold">There are 4 candidate implementations:</span>
<span class=" -Color -Color-Bold">    - Of which 4 did not match due to:</span>
<span class=" -Color -Color-Bold">    Overload in function &#39;_OverloadWrapper._build.&lt;locals&gt;.ol_generated&#39;: File: numba/core/overload_glue.py: Line 129.</span>
<span class=" -Color -Color-Bold">      With argument(s): &#39;(array(int64, 1d, C))&#39;:</span>
<span class=" -Color -Color-Bold">     Rejected as the implementation raised a specific error:</span>
<span class=" -Color -Color-Bold">       TypingError: array(int64, 1d, C) not allowed in a homogeneous sequence</span>
  raised from /Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/typing/npydecl.py:488

<span class=" -Color -Color-Bold">During: resolving callee type: Function(&lt;built-in function array&gt;)</span>
<span class=" -Color -Color-Bold">During: typing of call at /var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py (319)</span>


<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 319:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:151: NumbaWarning: <span class=" -Color -Color-Bold">Function &quot;compute_total_Tkin&quot; was compiled in object mode without forceobj=True.</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 317:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaWarning(warn_msg,
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:161: NumbaDeprecationWarning: 
<span class=" -Color -Color-Bold">Fall-back from the nopython compilation path to the object mode compilation path has been detected, this is deprecated behaviour.</span>

<span class=" -Color -Color-Bold">For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 317:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaDeprecationWarning(msg,
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>total Tkin per particle = 22.42755311959275
Fermi momentum = 1.3330210137859975
Energy per neutron of infinite free Fermi gas 22.10817470276664
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>HF energy per neutron = 10.349801450196432
hh channels= 25
pp channels= 25
hh number of total combinations 182
pp number of total combinations 656
get v_hhhh, v_pphh, v_pppp
what a hog! 0.05801991599999923 seconds
compute energy denominator
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/ir_utils.py:2147: NumbaPendingDeprecationWarning: 
<span class=" -Color -Color-Bold">Encountered the use of a type that is scheduled for deprecation: type &#39;reflected list&#39; found for argument &#39;sp_basis&#39; of function &#39;Fock&#39;.</span>

<span class=" -Color -Color-Bold">For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-reflection-for-list-and-set-types</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 326:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(NumbaPendingDeprecationWarning(msg, loc=loc))
/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:511: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITH looplifting enabled because Function &quot;make_diagram&quot; failed type inference due to: Use of unsupported NumPy function &#39;numpy.matmul&#39; or unsupported use of the function.</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 521:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

<span class=" -Color -Color-Bold">During: typing of get attribute at /var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py (521)</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 521:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:511: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITHOUT looplifting enabled because Function &quot;make_diagram&quot; failed type inference due to: Cannot determine Numba type of &lt;class &#39;numba.core.dispatcher.LiftedLoop&#39;&gt;</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 518:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>that&#39;s faster 0.1893236250000001 seconds
Initialize T2 from MBPT2
MBPT2 correlation energy per neutron = -0.17553785744804082
start CCD iterations ...
time of making Hbar: 0.17841224999999916 seconds
iter= 0 Correlation energy per neutron= -0.20550292085394894 , epsilon= 1.0
time of making Hbar: 0.0002564580000008476 seconds
iter= 1 Correlation energy per neutron= -0.2107009003533346 , epsilon= 0.024669944412524628
time of making Hbar: 0.00023595900000117354 seconds
iter= 2 Correlation energy per neutron= -0.2116672343138936 , epsilon= 0.004565345050646539
time of making Hbar: 0.00022775000000052614 seconds
iter= 3 Correlation energy per neutron= -0.21184820867906343 , epsilon= 0.0008542643164097731
time of making Hbar: 0.00022474999999921863 seconds
iter= 4 Correlation energy per neutron= -0.21188227228364806 , epsilon= 0.00016076665696240967
time of making Hbar: 0.000225874999999931 seconds
iter= 5 Correlation energy per neutron= -0.21188870821702438 , epsilon= 3.0374121539822725e-05
time of making Hbar: 0.00023183299999907092 seconds
iter= 6 Correlation energy per neutron= -0.21188992798649683 , epsilon= 5.756618467265144e-06
time of making Hbar: 0.0002274159999995362 seconds
iter= 7 Correlation energy per neutron= -0.211890159780636 , epsilon= 1.093935364400894e-06
time of making Hbar: 0.00022137500000063426 seconds
iter= 8 Correlation energy per neutron= -0.21189020393325292 , epsilon= 2.0837497962657972e-07
time of making Hbar: 0.00022020900000008226 seconds
iter= 9 Correlation energy per neutron= -0.21189021236156144 , epsilon= 3.9776771344709894e-08
time of making Hbar: 0.0002222910000000411 seconds
Correlation energy per neutron=  -0.2118902139735854
total time in seconds 1.2425067080000005
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:151: NumbaWarning: <span class=" -Color -Color-Bold">Function &quot;make_diagram&quot; was compiled in object mode without forceobj=True, but has lifted loops.</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 516:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaWarning(warn_msg,
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:161: NumbaDeprecationWarning: 
<span class=" -Color -Color-Bold">Fall-back from the nopython compilation path to the object mode compilation path has been detected, this is deprecated behaviour.</span>

<span class=" -Color -Color-Bold">For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 516:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaDeprecationWarning(msg,
/var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py:511: NumbaWarning: 
<span class=" -Color -Color-Bold">Compilation is falling back to object mode WITHOUT looplifting enabled because Function &quot;make_diagram&quot; failed type inference due to: non-precise type pyobject</span>
<span class=" -Color -Color-Bold">During: typing of argument at /var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py (518)</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 518:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  @jit
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:151: NumbaWarning: <span class=" -Color -Color-Bold">Function &quot;make_diagram&quot; was compiled in object mode without forceobj=True.</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 518:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaWarning(warn_msg,
/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numba/core/object_mode_passes.py:161: NumbaDeprecationWarning: 
<span class=" -Color -Color-Bold">Fall-back from the nopython compilation path to the object mode compilation path has been detected, this is deprecated behaviour.</span>

<span class=" -Color -Color-Bold">For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit</span>

<span class=" -Color -Color-Bold">File &quot;../../../../../../var/folders/td/3yk470mj5p931p9dtkk0y6jw0000gn/T/ipykernel_5273/2479038418.py&quot;, line 518:</span>
<span class=" -Color -Color-Bold">&lt;source missing, REPL/exec in use?&gt;</span>

  warnings.warn(errors.NumbaDeprecationWarning(msg,
</pre></div>
</div>
</div>
</div>
<!-- --- end answer of exercise --- -->
<p>===== =====</p>
</div>
<div class="section" id="benchmarks-with-the-minnesota-potential">
<h2><span class="section-number">8.10. </span>Benchmarks with the Minnesota potential<a class="headerlink" href="#benchmarks-with-the-minnesota-potential" title="Permalink to this headline">¶</a></h2>
<p>For the benchmarks, let us use a nucleon mass <span class="math notranslate nohighlight">\(m=938.92\)</span> MeV, <span class="math notranslate nohighlight">\(\hbar =
197.33\)</span> MeV fm, and <span class="math notranslate nohighlight">\(c=1\)</span>. For <span class="math notranslate nohighlight">\(N=14\)</span> neutrons at a density <span class="math notranslate nohighlight">\(\rho=0.08
{\rm fm}^{-3}\)</span> one finds <span class="math notranslate nohighlight">\(T_{\rm kin}(\vert\phi_0\rangle)/N =
22.427553\)</span> MeV, and <span class="math notranslate nohighlight">\(E_{HF}/N = 10.3498\)</span> MeV. In model spaces with
<span class="math notranslate nohighlight">\(N_{\rm max}=1\)</span> and <span class="math notranslate nohighlight">\(N_{\rm max}=2\)</span>, and using only the first five diagrams
of <a class="reference external" href="#fig-ccd">Figure 11</a> for the CCD calculation, yields the correlation
energies per particle of <span class="math notranslate nohighlight">\(E_{c}/N =-0.2118\)</span> MeV and <span class="math notranslate nohighlight">\(E_{c}/N =-0.6923\)</span>
MeV, respectively.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="from-structure-to-reactions">
<h1><span class="section-number">9. </span>From Structure to Reactions<a class="headerlink" href="#from-structure-to-reactions" title="Permalink to this headline">¶</a></h1>
<p>Nuclear coupled-cluster theory has also been used to describe aspects
of nuclear reactions, namely photo reactions and computations of
optical potentials. In what follows, we want to discuss these approaches.</p>
<div class="section" id="electroweak-reactions">
<h2><span class="section-number">9.1. </span>Electroweak reactions<a class="headerlink" href="#electroweak-reactions" title="Permalink to this headline">¶</a></h2>
<p>Let us assume we probe a nucleus with an electroweak probe (e.g. via
photon or <span class="math notranslate nohighlight">\(Z\)</span>-boson exchange). The corresponding operator
<span class="math notranslate nohighlight">\(\hat{\Theta}\)</span> introduces transitions in the nucleus. For photo
reactions, the relevant operator is the dipole operator</p>
<!-- Equation labels as ordinary links -->
<div id="_auto53"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\hat{\Theta} = \sum_{1=1}^A q_i (\vec{r}_i - \vec{R}_{CoM}) .
\label{_auto53} \tag{70}
\end{equation}
\]</div>
<p>Here <span class="math notranslate nohighlight">\(q_i\)</span> is the charge of nucleon <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(\vec{R}_{CoM}\)</span> is the
position of the center of mass. The structure function or response
function describing the reaction is</p>
<!-- Equation labels as ordinary links -->
<div id="_auto54"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
S(\omega) \equiv \sum_f \langle\psi_0|\hat{\Theta}^\dagger|\psi_f\rangle\langle \psi_f |\hat{\Theta}|\psi_0\rangle \delta(E_f-E_0-\omega).
\label{_auto54} \tag{71}
\end{equation}
\]</div>
<p>Here, the sum is over all final states. The structure function is
difficult to compute because the sum is over (infinitely many)
continuum states, and we seek a simpler formulation. The key idea is
that the Lorentz integral transform (LIT) of the structure function</p>
<!-- Equation labels as ordinary links -->
<div id="LIT"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{LIT} \tag{72}
L(\omega_0,\Gamma) \equiv {\Gamma\over\pi} \int d\omega \frac{S(\omega)}{(\omega-\omega_0)^2+\Gamma^2} 
\end{equation}
\]</div>
<div class="math notranslate nohighlight">
\[
= {\Gamma\over\pi}\langle\psi_0|\hat{\Theta}^\dagger {1\over H-E_0-\omega_0+i\Gamma} {1\over H-E_0-\omega_0-i\Gamma}\hat{\Theta}|\psi_0\rangle \nonumber.
\]</div>
<p>We note that the LIT <span class="math notranslate nohighlight">\(L(\omega_0,\Gamma)\)</span> of the structure function is
a ground-state expectation value and thus much easier to compute than
the structure function itself. We also note that the LIT is not
invertible (mathematically speaking), but making some assumptions
about the structure function, and imposing a finite resolution
<span class="math notranslate nohighlight">\(\Gamma\)</span> alleviates this problem in practical computation.</p>
<p>We next rewrite the LIT for coupled cluster using the shorthand
<span class="math notranslate nohighlight">\(z\equiv E_0+\omega_0+i\Gamma\)</span> as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto55"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
L(\omega_0,\Gamma) \equiv {\Gamma\over\pi} \langle\tilde{\psi}_L(z^*) \vert \tilde{\psi}_R(z)\rangle , 
\label{_auto55} \tag{73}
\end{equation}
\]</div>
<p>with <span class="math notranslate nohighlight">\(\vert\tilde{\psi}_R(z)\rangle\)</span> and <span class="math notranslate nohighlight">\(\langle\tilde{\psi}_L(z^*)\vert\)</span> fulfilling</p>
<!-- Equation labels as ordinary links -->
<div id="keyLR"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{keyLR} \tag{74}
\left(\overline{H}-z\right) \vert\tilde{\psi}_R(z)\rangle = \overline{\Theta} \vert\phi_0\rangle , 
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto56"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\langle\tilde{\psi}_L(z^*)\vert \left(\overline{H}-z^*\right) = \langle \phi_L\vert .
\label{_auto56} \tag{75}
\end{equation}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\langle \phi_L\vert\)</span> is the left ground state, i.e. the left
eigenstate of the similarity-transformed Hamiltonian. Note that in the
coupled-cluster formulation we have distinguished between left and
right states (as these are not adjoints of each other), and replaced
all operators by their similarity transformations. Making the ansatz</p>
<!-- Equation labels as ordinary links -->
<div id="ansatzR"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{ansatzR} \tag{76}
\vert\tilde{\psi}_R(z)\rangle = \hat{R}\vert\phi_0\rangle 
\end{equation}
\]</div>
<div class="math notranslate nohighlight">
\[
= \left( r_0(z) + \sum_{ia} r_i^a(z) a_a^\dagger a_i + {1\over 4} \sum_{ijab} r_{ij}^{ab}(z) a_a^\dagger a^\dagger_b a_j a_i +\cdots\right)\vert\phi_0\rangle  \nonumber
\]</div>
<p>for the right state, and</p>
<!-- Equation labels as ordinary links -->
<div id="ansatzL"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{ansatzL} \tag{77}
\langle\tilde{\psi}_L(z^*)\vert= \langle\phi_L\vert \hat{L} 
\end{equation}
\]</div>
<div class="math notranslate nohighlight">
\[
= \langle \phi_L\vert \left( l_0(z) +  \sum_{ia} l^i_a(z) a_i^\dagger a_a + {1\over 4} \sum_{ijab} l^{ij}_{ab}(z) a_i^\dagger a^\dagger_j a_b a_a +\cdots\right)  \nonumber
\]</div>
<p>for the left state, make the Eq. (<a class="reference external" href="#keyLR">74</a>) linear systems of
equations that can be solved for the parameters <span class="math notranslate nohighlight">\(r_0, r_i^a,
r_{ij}^{ab}\)</span> and <span class="math notranslate nohighlight">\(l_0, l_a^i, l_{ab}^{ij}\)</span> for each value of <span class="math notranslate nohighlight">\(z\)</span>. The LIT then becomes</p>
<!-- Equation labels as ordinary links -->
<div id="_auto57"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
L(z) = l_0(z) r_0(z) + \sum_{ia} l_a^i(z) r_i^a(z) +{1\over 4} l_{ab}^{ij}(z) r_{ij}^{ab}(z) 
\label{_auto57} \tag{78}
\end{equation}
\]</div>
<p>in the CCSD approximation. For details, please see [“Giant and pigmy dipole resonances in 4He, 16,22O, and 40Ca from chiral nucleon-nucleon interactions,” S. Bacca, N. Barnea, G. Hagen, M. Miorelli, G. Orlandini, and T. Papenbrock,
Phys. Rev. C 90, 064619 (2014)].</p>
</div>
<div class="section" id="computing-optical-potentials-from-microscopic-input">
<h2><span class="section-number">9.2. </span>Computing optical potentials from microscopic input<a class="headerlink" href="#computing-optical-potentials-from-microscopic-input" title="Permalink to this headline">¶</a></h2>
<p>The single-particle Green’s function</p>
<!-- Equation labels as ordinary links -->
<div id="Green"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Green} \tag{79}
G(\alpha, \beta, E) \equiv \langle\psi_0\vert a_\alpha {1\over E-(H-E_0)+i\eta}a^\dagger_\beta\vert\psi_0\rangle
+ \langle\psi_0\vert a_\beta^\dagger {1\over E-(H-E_0)-i\eta}a_\alpha\vert\psi_0\rangle  
\end{equation}
\]</div>
<p>describes the propagation of particles and holes in the nucleus with a
ground state <span class="math notranslate nohighlight">\(\vert\psi_0\rangle\)</span> and energy <span class="math notranslate nohighlight">\(E_0\)</span>. The Green’s function fulfills the Dyson equation</p>
<!-- Equation labels as ordinary links -->
<div id="Dyson"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{Dyson} \tag{80}
G = G^{(0)} +G^{(0)} \Sigma^* G , 
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sigma^*\)</span> is the self energy and <span class="math notranslate nohighlight">\(G^{(0)}\)</span> is the Hartree-Fock Green’s function</p>
<!-- Equation labels as ordinary links -->
<div id="HFGreen"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\label{HFGreen} \tag{81}
G^{(0)}(\alpha, \beta, E) \equiv \langle\phi_0\vert a_\alpha {1\over E-(H_{HF}-E_{HF})+i\eta}a^\dagger_\beta\vert\phi_0\rangle
+ \langle\phi_0\vert a_\beta^\dagger {1\over E-(H_{HF}-E_{HF})-i\eta}a_\alpha\vert\phi_0\rangle 
\end{equation}
\]</div>
<div class="math notranslate nohighlight">
\[
= \delta_\alpha^\beta \left({\Theta(\alpha-F) \over E-\varepsilon_\alpha +i\eta} + {\Theta(F-\alpha) \over E-\varepsilon_\alpha -i\eta} \right) \nonumber.
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\Theta()\)</span> denotes the unit step function and <span class="math notranslate nohighlight">\(F\)</span> labels the
index of the Fermi surface. The key point is now that the optical
potential <span class="math notranslate nohighlight">\(\Sigma'\)</span> (which describes the reaction of a single nucleon with the
nucleus) is related to the self energy and the Hartree-Fock potential
<span class="math notranslate nohighlight">\(U_{HF}\)</span> by [F. Capuzzi and C. Mahaux, “Projection operator approach to the
self-energy,” Ann. Phys. (NY) 245, 147 (1996)]</p>
<!-- Equation labels as ordinary links -->
<div id="_auto58"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\Sigma' \equiv \Sigma^* +U_{HF} .
\label{_auto58} \tag{82}
\end{equation}
\]</div>
<p>The idea is thus as follows. Starting from a Hartree-Fock calculations
enables us to compute the Hartree-Fock potential <span class="math notranslate nohighlight">\(U_{HF}\)</span> and the
Hartree-Fock Green’s function (<a class="reference external" href="#HFGreen">81</a>). Computing the Green’s
function (<a class="reference external" href="#Green">79</a>) in coupled clusters, and inverting the Dyson
equation (<a class="reference external" href="#Dyson">80</a>) using</p>
<!-- Equation labels as ordinary links -->
<div id="_auto59"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\Sigma^* = \left(G^{(0)}\right)^{-1} - G^{-1}
\label{_auto59} \tag{83}
\end{equation}
\]</div>
<p>thus allows us to compute the optical potential. We note that the
Green’s function (<a class="reference external" href="#Green">79</a>) resembles in its structure the LIT
(<a class="reference external" href="#LIT">72</a>), and we will indeed use a similar approach to compute this
object with the coupled-cluster method. Indeed, we compute</p>
<!-- Equation labels as ordinary links -->
<div id="_auto60"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\left(E-(\overline{H}-E_0)+ i\eta\right) \vert\tilde{\psi}_R\rangle = \overline{a^\dagger_\beta} \vert\phi_0\rangle , 
\label{_auto60} \tag{84}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto61"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} 
\langle\tilde{\psi}_L\vert \left(E-(E_0-\overline{H})-i\eta\right) = \langle \phi_L\vert \overline{a_\beta^\dagger} , 
\label{_auto61} \tag{85}
\end{equation}
\]</div>
<p>by making the ansatz (<a class="reference external" href="#ansatzR">76</a>) and (<a class="reference external" href="#ansatzL">77</a>) for the right
and left states, respectively, solve the resulting linear systems, and
then compute <span class="math notranslate nohighlight">\(G(\alpha,\beta,E) = \langle\phi_L\vert
\overline{a_\alpha} \vert\tilde{\psi}_R\rangle + \langle
\tilde{\psi}_L\vert \overline{a_\alpha}\vert\phi_0\rangle\)</span>.</p>
<p>We note that a high quality optical potential can only be obtained if
the structure of the nucleus is computed with a good accuracy, i.e. in
good agreement to data on binding and separation energies, and charge
and matter radii. For details, please see [“Optical potential from
first principles,” J. Rotureau, P. Danielewicz, G. Hagen, F. Nunes,
and T. Papenbrock, Phys. Rev. C 95, 024315 (2017); arXiv:1611.04554].
We also note that this procedure must be repeated for any nucleus of
interest, because the optical potential depends on the nucleus under
consideration. Once the optical potential <span class="math notranslate nohighlight">\(\Sigma'\)</span> is computed, the
single-particle Schroedinger equation</p>
<!-- Equation labels as ordinary links -->
<div id="_auto62"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\left( -{\hbar^2\Delta\over 2m} +\Sigma'\right)\xi = E\xi 
\label{_auto62} \tag{86}
\end{equation}
\]</div>
<p>describes the interaction of a single nucleon (and wave function
<span class="math notranslate nohighlight">\(\xi\)</span>) with the nucleus.</p>
<p>Finally, we note that this approach does not depend on solving the
nucleus <span class="math notranslate nohighlight">\(A\)</span> with the coupled-cluster method. Alternatives, such as the
IMSRG or Self-Consistent Green’s Function methods could also be used.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="mbpt.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">6. </span>Many-body perturbation theory</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="vmcdmc.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Variational Monte Carlo methods</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Morten Hjorth-Jensen<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>