<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week47.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week47-bs --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Week 47, Coupled-Cluster theory">
<title>Week 47, Coupled-Cluster theory</title>
<!-- Bootstrap style: bootstrap -->
<!-- doconce format html week47.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week47-bs --no_mako -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Week 47, November 18-22, 2024',
               2,
               None,
               'week-47-november-18-22-2024'),
              ('Introduction', 2, None, 'introduction'),
              ('The normal-ordered Hamiltonian',
               2,
               None,
               'the-normal-ordered-hamiltonian'),
              ('Notations again', 2, None, 'notations-again'),
              ('Hamiltonian', 2, None, 'hamiltonian'),
              ('The reference state', 2, None, 'the-reference-state'),
              ('Hartree-Fock basis', 2, None, 'hartree-fock-basis'),
              ('Short repetition: Practice in normal ordering',
               2,
               None,
               'short-repetition-practice-in-normal-ordering'),
              ('Answer', 2, None, 'answer'),
              ('', 2, None, ''),
              ('Hartree-Fock again', 2, None, 'hartree-fock-again'),
              ("What does ``good'' mean?", 2, None, 'what-does-good-mean'),
              ('Answer', 2, None, 'answer'),
              ('To nuclear physics aficionadoss: How many nuclei are '
               'accessible with the coupled cluster method based on spherical '
               'mean fields?',
               2,
               None,
               'to-nuclear-physics-aficionadoss-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields'),
              ('Answer', 2, None, 'answer'),
              ('The similarity transformed Hamiltonian',
               2,
               None,
               'the-similarity-transformed-hamiltonian'),
              ('Clusters of excited states',
               2,
               None,
               'clusters-of-excited-states'),
              ('Similarity transformation',
               2,
               None,
               'similarity-transformation'),
              ('What $T$ leads to Hermitian $\\overline{H_N}$ ?',
               2,
               None,
               'what-t-leads-to-hermitian-overline-h-n'),
              ('Answer', 2, None, 'answer'),
              ('Understanding (non-unitary) similarity transformations',
               2,
               None,
               'understanding-non-unitary-similarity-transformations'),
              ('Answer', 2, None, 'answer'),
              ('Non-hermitian operator', 2, None, 'non-hermitian-operator'),
              ('More formalism', 2, None, 'more-formalism'),
              ('Particle-hole excitations',
               2,
               None,
               'particle-hole-excitations'),
              ('How many unknowns?', 2, None, 'how-many-unknowns'),
              ('Answer', 2, None, 'answer'),
              ('Full clutser operator', 2, None, 'full-clutser-operator'),
              ('Unknown aplitudes', 2, None, 'unknown-aplitudes'),
              ('Correlation energy', 2, None, 'correlation-energy'),
              ('Good reference state', 2, None, 'good-reference-state'),
              ('Exercise 1: Why is CCD not exact?',
               2,
               None,
               'exercise-1-why-is-ccd-not-exact'),
              ('Computing the similarity-transformed Hamiltonian',
               2,
               None,
               'computing-the-similarity-transformed-hamiltonian'),
              ('The cluster operator', 2, None, 'the-cluster-operator'),
              ('When does CCSD truncate?', 2, None, 'when-does-ccsd-truncate'),
              ('Non-hermitian Hamiltonian',
               2,
               None,
               'non-hermitian-hamiltonian'),
              ('Similarity transformed Hamiltonian',
               2,
               None,
               'similarity-transformed-hamiltonian'),
              ('Compute the matrix element $\\overline{H}_{ab}^{ij}\\equiv '
               '\\langle ij\\vert \\overline{H_N}\\vert ab\\rangle$',
               2,
               None,
               'compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle'),
              ('Algebraic manipulations', 2, None, 'algebraic-manipulations'),
              ('Example: The contribution of $[F, T_2]$ to $\\overline{H_N}$',
               2,
               None,
               'example-the-contribution-of-f-t-2-to-overline-h-n'),
              ('Antisymmetry', 2, None, 'antisymmetry'),
              ('Final contribution', 2, None, 'final-contribution'),
              ('Assign the correct matrix element $\\langle pq\\vert V\\vert '
               'rs\\rangle$ to each of the following diagrams of the '
               'interaction',
               2,
               None,
               'assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction'),
              ('CCD Approximation', 2, None, 'ccd-approximation'),
              ('Deriving the CCD equations',
               2,
               None,
               'deriving-the-ccd-equations'),
              ('The algebraic expression', 2, None, 'the-algebraic-expression'),
              ('Computational cost of a CCD computation',
               2,
               None,
               'computational-cost-of-a-ccd-computation'),
              ('Additional details', 2, None, 'additional-details'),
              ('Factorizing the remaining diagrams of the CCD equation',
               2,
               None,
               'factorizing-the-remaining-diagrams-of-the-ccd-equation'),
              ('Diagram 8', 2, None, 'diagram-8'),
              ('Diagram 9', 2, None, 'diagram-9'),
              ('Solving the CCD equations',
               2,
               None,
               'solving-the-ccd-equations'),
              ('More manipulations', 2, None, 'more-manipulations'),
              ('CCD for the pairing Hamiltonian',
               2,
               None,
               'ccd-for-the-pairing-hamiltonian'),
              ('Solving the CCD equations for the pairing problem',
               2,
               None,
               'solving-the-ccd-equations-for-the-pairing-problem'),
              ('Python code', 2, None, 'python-code')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="week47-bs.html">Week 47, Coupled-Cluster theory</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#week-47-november-18-22-2024" style="font-size: 80%;">Week 47, November 18-22, 2024</a></li>
     <!-- navigation toc: --> <li><a href="#introduction" style="font-size: 80%;">Introduction</a></li>
     <!-- navigation toc: --> <li><a href="#the-normal-ordered-hamiltonian" style="font-size: 80%;">The normal-ordered Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#notations-again" style="font-size: 80%;">Notations again</a></li>
     <!-- navigation toc: --> <li><a href="#hamiltonian" style="font-size: 80%;">Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#the-reference-state" style="font-size: 80%;">The reference state</a></li>
     <!-- navigation toc: --> <li><a href="#hartree-fock-basis" style="font-size: 80%;">Hartree-Fock basis</a></li>
     <!-- navigation toc: --> <li><a href="#short-repetition-practice-in-normal-ordering" style="font-size: 80%;">Short repetition: Practice in normal ordering</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#" style="font-size: 80%;"></a></li>
     <!-- navigation toc: --> <li><a href="#hartree-fock-again" style="font-size: 80%;">Hartree-Fock again</a></li>
     <!-- navigation toc: --> <li><a href="#what-does-good-mean" style="font-size: 80%;">What does ``good'' mean?</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#to-nuclear-physics-aficionadoss-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields" style="font-size: 80%;">To nuclear physics aficionadoss: How many nuclei are accessible with the coupled cluster method based on spherical mean fields?</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#the-similarity-transformed-hamiltonian" style="font-size: 80%;">The similarity transformed Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#clusters-of-excited-states" style="font-size: 80%;">Clusters of excited states</a></li>
     <!-- navigation toc: --> <li><a href="#similarity-transformation" style="font-size: 80%;">Similarity transformation</a></li>
     <!-- navigation toc: --> <li><a href="#what-t-leads-to-hermitian-overline-h-n" style="font-size: 80%;">What \( T \) leads to Hermitian \( \overline{H_N} \) ?</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#understanding-non-unitary-similarity-transformations" style="font-size: 80%;">Understanding (non-unitary) similarity transformations</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#non-hermitian-operator" style="font-size: 80%;">Non-hermitian operator</a></li>
     <!-- navigation toc: --> <li><a href="#more-formalism" style="font-size: 80%;">More formalism</a></li>
     <!-- navigation toc: --> <li><a href="#particle-hole-excitations" style="font-size: 80%;">Particle-hole excitations</a></li>
     <!-- navigation toc: --> <li><a href="#how-many-unknowns" style="font-size: 80%;">How many unknowns?</a></li>
     <!-- navigation toc: --> <li><a href="#answer" style="font-size: 80%;">Answer</a></li>
     <!-- navigation toc: --> <li><a href="#full-clutser-operator" style="font-size: 80%;">Full clutser operator</a></li>
     <!-- navigation toc: --> <li><a href="#unknown-aplitudes" style="font-size: 80%;">Unknown aplitudes</a></li>
     <!-- navigation toc: --> <li><a href="#correlation-energy" style="font-size: 80%;">Correlation energy</a></li>
     <!-- navigation toc: --> <li><a href="#good-reference-state" style="font-size: 80%;">Good reference state</a></li>
     <!-- navigation toc: --> <li><a href="#exercise-1-why-is-ccd-not-exact" style="font-size: 80%;">Exercise 1: Why is CCD not exact?</a></li>
     <!-- navigation toc: --> <li><a href="#computing-the-similarity-transformed-hamiltonian" style="font-size: 80%;">Computing the similarity-transformed Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#the-cluster-operator" style="font-size: 80%;">The cluster operator</a></li>
     <!-- navigation toc: --> <li><a href="#when-does-ccsd-truncate" style="font-size: 80%;">When does CCSD truncate?</a></li>
     <!-- navigation toc: --> <li><a href="#non-hermitian-hamiltonian" style="font-size: 80%;">Non-hermitian Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#similarity-transformed-hamiltonian" style="font-size: 80%;">Similarity transformed Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle" style="font-size: 80%;">Compute the matrix element \( \overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle \)</a></li>
     <!-- navigation toc: --> <li><a href="#algebraic-manipulations" style="font-size: 80%;">Algebraic manipulations</a></li>
     <!-- navigation toc: --> <li><a href="#example-the-contribution-of-f-t-2-to-overline-h-n" style="font-size: 80%;">Example: The contribution of \( [F, T_2] \) to \( \overline{H_N} \)</a></li>
     <!-- navigation toc: --> <li><a href="#antisymmetry" style="font-size: 80%;">Antisymmetry</a></li>
     <!-- navigation toc: --> <li><a href="#final-contribution" style="font-size: 80%;">Final contribution</a></li>
     <!-- navigation toc: --> <li><a href="#assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction" style="font-size: 80%;">Assign the correct matrix element \( \langle pq\vert V\vert rs\rangle \) to each of the following diagrams of the interaction</a></li>
     <!-- navigation toc: --> <li><a href="#ccd-approximation" style="font-size: 80%;">CCD Approximation</a></li>
     <!-- navigation toc: --> <li><a href="#deriving-the-ccd-equations" style="font-size: 80%;">Deriving the CCD equations</a></li>
     <!-- navigation toc: --> <li><a href="#the-algebraic-expression" style="font-size: 80%;">The algebraic expression</a></li>
     <!-- navigation toc: --> <li><a href="#computational-cost-of-a-ccd-computation" style="font-size: 80%;">Computational cost of a CCD computation</a></li>
     <!-- navigation toc: --> <li><a href="#additional-details" style="font-size: 80%;">Additional details</a></li>
     <!-- navigation toc: --> <li><a href="#factorizing-the-remaining-diagrams-of-the-ccd-equation" style="font-size: 80%;">Factorizing the remaining diagrams of the CCD equation</a></li>
     <!-- navigation toc: --> <li><a href="#diagram-8" style="font-size: 80%;">Diagram 8</a></li>
     <!-- navigation toc: --> <li><a href="#diagram-9" style="font-size: 80%;">Diagram 9</a></li>
     <!-- navigation toc: --> <li><a href="#solving-the-ccd-equations" style="font-size: 80%;">Solving the CCD equations</a></li>
     <!-- navigation toc: --> <li><a href="#more-manipulations" style="font-size: 80%;">More manipulations</a></li>
     <!-- navigation toc: --> <li><a href="#ccd-for-the-pairing-hamiltonian" style="font-size: 80%;">CCD for the pairing Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#solving-the-ccd-equations-for-the-pairing-problem" style="font-size: 80%;">Solving the CCD equations for the pairing problem</a></li>
     <!-- navigation toc: --> <li><a href="#python-code" style="font-size: 80%;">Python code</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>Week 47, Coupled-Cluster theory</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>November 18-22, 2024</h4>
</center> <!-- date -->
<br>

<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->
<h2 id="week-47-november-18-22-2024" class="anchor">Week 47, November 18-22, 2024 </h2>
<ol>
<li> Thursday:
<ol type="a"></li>
 <li> Introduction to coupled-cluster theory  and basic equations</li>
</ol>
<li> Friday:
<ol type="a"></li>
 <li> Derivation of doubles excitation equation</li> 
 <li> Applications to the pairing model from the second midterm</li>
</ol>
<li> Lecture material: Lecture notes (these notes) and chapter 9 of Shavitt and Bartlett, in particular sections 9-1-9.3</li>
</ol>
<!-- !split -->
<h2 id="introduction" class="anchor">Introduction </h2>

<p>The coupled-cluster method is an efficient tool to compute properties of many-body systems
with an effort that grows polynomial with system size. While
this might still be expensive, it is now possible to compute for example atomic nuclei
with mass numbers about \( A\approx 208 \) (which corresponds to lead) with this method. Recall that
full configuration interaction (FCI)
exhibits an exponential cost and is therefore limited to systems with few degrees of freedom.
</p>

<p>For some  recent applications see</p>
<ol>
<li> <b>Nuclear Physics</b>: see <a href="https://www.nature.com/articles/s41567-022-01715-8" target="_self"><tt>https://www.nature.com/articles/s41567-022-01715-8</tt></a></li>
<li> <b>Quantum chemistry</b>: see <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.79.291" target="_self"><tt>https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.79.291</tt></a></li>
</ol>
<!-- !split -->
<h2 id="the-normal-ordered-hamiltonian" class="anchor">The normal-ordered Hamiltonian </h2>

<p>We start from the reference state</p>

$$
\begin{equation}
\label{HFref}
\vert\Phi_0\rangle = \prod_{i=1}^H a^\dagger_i \vert 0\rangle 
\end{equation}
$$

<p>for the description of a system  with \( N \) particles.  Usually, this
reference is the Hartree-Fock state, but that is not necessary as discussed throughout this course.
</p>

<!-- !split -->
<h2 id="notations-again" class="anchor">Notations again </h2>

<p>After we introduced the particle-hole formalism, we have opted for a convention
where the indices \( i,j,k,\ldots \) run over hole states,
i.e. orbitals occupied in the reference state \eqref{HFref}, while
\( a,b,c,\ldots \) run over particle states, i.e. unoccupied
orbitals. Indices \( p,q,r,s \) can identify any orbital.  Let \( n_u \) be
the number of unoccupied states, and \( N \) is of course the number of
particles, which is also the number of occupied states used to define the ansatz for the ground state. 
</p>

<!-- !split -->
<h2 id="hamiltonian" class="anchor">Hamiltonian </h2>

<p>We consider the Hamiltonian</p>
$$
\begin{equation}
\label{Ham} H =
\sum_{pq} \langle p\vert h_0\vert q \rangle a^\dagger_p a_q +
\frac{1}{4}\sum_{pqrs}\langle pq\vert v\vert rs\rangle
a^\dagger_pa^\dagger_q a_sa_r
\end{equation}
$$


<!-- !split -->
<h2 id="the-reference-state" class="anchor">The reference state </h2>

<p>The reference state \eqref{HFref} is a non-trivial vacuum of our theory. 
We normal order this Hamiltonian with respect to the nontrivial vacuum
state given by the Hartree-Fock reference and obtain the
normal-ordered Hamiltonian
</p>

$$
\begin{equation}
\label{HN}
H_N = \sum_{pq} \langle p\vert f\vert q \rangle \left\{a^\dagger_p a_q\right\} + \frac{1}{4}\sum_{pqrs}\langle pq\vert V\vert rs\rangle \left\{a^\dagger_pa^\dagger_q a_sa_r\right\}.
\end{equation}
$$


<!-- !split -->
<h2 id="hartree-fock-basis" class="anchor">Hartree-Fock basis </h2>

<p>Here,</p>
$$
\begin{equation}
\label{Fock}
\langle p\vert f\vert q \rangle = \langle p\vert h_0\vert q \rangle + \sum_i \langle pi\vert V\vert qi\rangle
\end{equation}
$$

<p>is the Fock matrix. We note that the Fock matrix is diagonal in the
Hartree-Fock basis. The brackets \( \{\cdots\} \) in Eq. \eqref{HN} denote
normal ordering, i.e. all operators that annihilate the nontrivial
vaccum \eqref{HFref} are to the right of those operators that create
with respect to that vaccum. Normal ordering implies that \( \langle
\Phi_0\vert H_N\vert \Phi_0\rangle = 0 \).
</p>

<!-- !split -->
<h2 id="short-repetition-practice-in-normal-ordering" class="anchor">Short repetition: Practice in normal ordering </h2>

<p>Normal order the expression \( \sum\limits_{pq}\varepsilon_q^p a^\dagger_p a_q \).</p>

$$
\begin{align}
\sum_{pq}\langle p \vert h_0\vert q \rangle a^\dagger_p a_q
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a   
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\label{_auto1}
\end{align}
$$


<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>We have to move all operators that annihilate the reference state to the right of those that create on the reference state. Thus,</p>
$$
\begin{align}
\sum_{pq}\langle p \vert h_0\vert q \rangle a^\dagger_p a_q
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\label{_auto2}\\
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i \left(-a_ja^\dagger_i +\delta_i^j\right)
\label{_auto3}\\
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
-\sum_{ij}\varepsilon_j^i a_ja^\dagger_i +\sum_i \varepsilon_i^i
\label{_auto4}\\
&=\sum_{pq}\langle p \vert h_0\vert q \rangle \left\{a^\dagger_p a_q\right\} +\sum_i \varepsilon_i^i
\label{_auto5}
\end{align}
$$
<h2><a name=""></a></h2>

<!-- !split -->
<h2 id="hartree-fock-again" class="anchor">Hartree-Fock again </h2>
<p>We note that \( H = E_{HF} + H_N \), where</p>

$$
\begin{align}
E_{HF} &\equiv \langle\Phi_0\vert H\vert \Phi_0\rangle = \sum_{i} \varepsilon^i_i +\frac{1}{2}\sum_{ij}\langle ij\vert V\vert ij\rangle
\label{_auto6}
\end{align}
$$

<p>is the Hartree-Fock energy.
The coupled-cluster method is a very efficient tool to compute nuclei
when a &quot;good&quot; reference state is available. Let us assume that the
reference state results from a Hartree-Fock calculation.
</p>

<!-- !split -->
<h2 id="what-does-good-mean" class="anchor">What does &quot;good&quot; mean? </h2>

<p>How do you know whether a Hartree-Fock state is a &quot;good&quot; reference?
Which results of the Hartree-Fock computation will inform you?
</p>

<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>Once the Hartree-Fock equations are solved, the Fock matrix
\eqref{Fock} becomes diagonal, and its diagonal elements can be viewed
as single-particle energies. Hopefully, there is a clear gap in the
single-particle spectrum at the Fermi surface, i.e. after \( N \) orbitals
are filled.
</p>

<p>If symmetry-restricted Hartree-Fock is used, one is limited to compute
systems  with closed subshells for neutrons and for protons. On a first
view, this might seem as a severe limitation. But is it? 
</p>

<!-- !split -->
<h2 id="to-nuclear-physics-aficionadoss-how-many-nuclei-are-accessible-with-the-coupled-cluster-method-based-on-spherical-mean-fields" class="anchor">To nuclear physics aficionadoss: How many nuclei are accessible with the coupled cluster method based on spherical mean fields? </h2>

<p>If one limits oneself to nuclei with mass number up to
mass number \( A=60 \), how many nuclei can potentially be described with
the coupled-cluster method? Which of these nuclei are potentially
interesting? Why?
</p>

<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>Nuclear shell closures are at \( N,Z=2,8,20,28,50,82,126 \), and subshell
closures at \( N,Z=2,6,8,14,16,20,28,32,34,40,50,\ldots \). 
</p>

<p>In the physics of nuclei, the evolution of nuclear structure as
neutrons are added (or removed) from an isotope is a key
</p>
<!-- interest. Examples are the rare isotopes of helium (\( ^{8,10} \) He) -->
<!-- oxygen (\( ^{22,24,28} \) O), calcium (\( ^{52,54,60} \) Ca), nickel (\( ^{78} \) -->
<!-- Ni) and tin (\( ^{100,132} \) Sn). The coupled-cluster method has the -->
<p>interest. Examples are the rare isotopes of helium (He-8,10)
oxygen (O-22,24,28), calcium (Ca-52,54,60), nickel (Ni-78) and tin
(Sn-100,132). The coupled-cluster method has the
potential to address questions regarding these nuclei, and in a
several cases was used to make predictions before experimental data
was available. In addition, the method can be used to compute
neighbors of nuclei with closed subshells.
</p>

<!-- !split -->
<h2 id="the-similarity-transformed-hamiltonian" class="anchor">The similarity transformed Hamiltonian </h2>

<p>There are several ways to view and understand the coupled-cluster
method. A first simple view of coupled-cluster theory is that the
method induces correlations into the reference state by expressing a
correlated state as
</p>

$$
\begin{equation}
\label{psi}
\vert\Psi\rangle = e^T \vert\Phi_0\rangle ,
\end{equation}
$$


<!-- !split -->
<h2 id="clusters-of-excited-states" class="anchor">Clusters of excited states </h2>

<p>Here, \( T \) is an operator that induces correlations. We can now demand
that the correlate state \eqref{psi} becomes and eigenstate of the
Hamiltonian \( H_N \), i.e.  \( H_N\vert \Psi\rangle = E\vert \Psi\rangle \). This view,
while correct, is not the most productive one.  Instead, we
left-multiply the Schroedinger equation with \( e^{-T} \) and find
</p>

$$
\begin{equation}
\label{Schroedinger}
\overline{H_N}\vert \Phi_0\rangle = E_c \vert \Phi_0\rangle . 
\end{equation}
$$

<p>Here, \( E_c \) is the correlation energy, and the total energy is
\( E=E_c+E_{HF} \).
</p>

<!-- !split -->
<h2 id="similarity-transformation" class="anchor">Similarity transformation </h2>

<p>The similarity-transformed Hamiltonian is defined as</p>

$$
\begin{equation}
\label{Hsim}
\overline{H_N} \equiv e^{-T} H_N e^T .
\end{equation}
$$

<p>A more productive view on coupled-cluster theory thus emerges: This
method seeks a similarity transformation such that the uncorrelated
reference state \eqref{HFref} becomes an exact eigenstate of the
similarity-transformed Hamiltonian \eqref{Hsim}.
</p>

<!-- !split -->
<h2 id="what-t-leads-to-hermitian-overline-h-n" class="anchor">What \( T \) leads to Hermitian \( \overline{H_N} \) ? </h2>

<p>What are the conditions on \( T \) such that \( \overline{H_N} \) is Hermitian?</p>

<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>For a Hermitian \( \overline{H_N} \), we need a unitary \( e^T \), i.e. an
anti-Hermitian \( T \) with \( T = -T^\dagger \)
</p>

<p>As we will see below, coupld-cluster theory employs a non-Hermitian Hamiltonian.</p>

<!-- !split -->
<h2 id="understanding-non-unitary-similarity-transformations" class="anchor">Understanding (non-unitary) similarity transformations </h2>

<p>Show that \( \overline{H_N} \) has the same eigenvalues as \( H_N \) for
arbitrary \( T \). What is the spectral decomposition of a non-Hermitian
\( \overline{H_N} \) ?
</p>

<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>Let \( H_N\vert E\rangle = E\vert E\rangle \). Thus</p>

$$
\begin{align*}
H_N e^{T} e^{-T} \vert E\rangle &= E\vert E\rangle , \\
\left(e^{-T} H_N e^T\right) e^{-T} \vert E\rangle &= Ee^{-T} \vert E\rangle , \\
\overline{H_N} e^{-T} \vert E\rangle &= E e^{-T}\vert E\rangle .
\end{align*}
$$

<p>Thus, if \( \vert E\rangle \) is an eigenstate of \( H_N \) with eigenvalue \( E \),
then \( e^{-T}\vert E\rangle \) is eigenstate of \( \overline{H_N} \) with the same
eigenvalue.
</p>

<!-- !split -->
<h2 id="non-hermitian-operator" class="anchor">Non-hermitian operator </h2>

<p>A non-Hermitian \( \overline{H_N} \) has eigenvalues \( E_\alpha \)
corresponding to left \( \langle L_\alpha\vert  \) and right \( \vert R_\alpha
\rangle \) eigenstates. Thus
</p>

$$
\begin{align}
\overline{H_N} = \sum_\alpha \vert R_\alpha\rangle E_\alpha \langle L_\alpha \vert 
\label{_auto7}
\end{align}
$$

<p>with bi-orthonormal \( \langle L_\alpha\vert R_\beta\rangle = \delta_\alpha^\beta \). </p>

<!-- !split -->
<h2 id="more-formalism" class="anchor">More formalism </h2>

<p>To make progress, we have to specify the cluster operator \( T \). In
coupled cluster theory, this operator is
</p>

$$
\begin{equation}
\label{Top}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i + \cdots
+ \frac{1}{(N!)^2}\sum_{i_1\ldots i_N a_1 \ldots a_N}
t_{i_1\ldots i_N}^{a_1\ldots a_N} a^\dagger_{a_1}\cdots a^\dagger_{a_N} a_{i_N}\cdots a_{i_1} .
\end{equation}
$$


<!-- !split -->
<h2 id="particle-hole-excitations" class="anchor">Particle-hole excitations </h2>

<p>Thus, the operator \eqref{Top} induces particle-hole (p-h)
excitations with respect to the reference. In general, \( T \) generates
up to \( Ap-Ah \) excitations, and the unknown parameters are the cluster amplitides
\( t_i^a \), \( t_{ij}^{ab} \), ..., \( t_{i_1,\ldots,i_A}^{a_1,\ldots,a_A} \).
</p>

<!-- !split -->
<h2 id="how-many-unknowns" class="anchor">How many unknowns? </h2>

<p>Show that the number of unknowns is as large as the FCI dimension of
the problem, using the numbers \( A \) and \( n_u \).
</p>

<!-- !split -->
<h2 id="answer" class="anchor">Answer </h2>

<p>We have to sum up all \( np-nh \) excitations, and there are
\( \binom{n_u}{n} \) particle states and \( \binom{A}{A-n} \) hole states for
each \( n \). Thus, we have for the total number
</p>

$$
\begin{align}
\sum_{n=0}^A \binom{n_u}{n} \binom{A}{A-n}= \binom{A+n_u}{A} .
\label{_auto8}
\end{align}
$$

<p>The right hand side are obviously all ways to distribute \( A \) fermions over \( n_0+A \) orbitals.</p>

<!-- !split -->
<h2 id="full-clutser-operator" class="anchor">Full clutser operator </h2>

<p>Thus, the coupled-cluster method with the full cluster operator
\eqref{Top} is exponentially expensive, just as FCI. To make progress,
we need to make an approximation by truncating the operator. Here, we
will use the CCSD (coupled clusters singles doubles) approximation,
where
</p>

$$
\begin{equation}
\label{Tccsd}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i .
\end{equation}
$$


<!-- !split -->
<h2 id="unknown-aplitudes" class="anchor">Unknown aplitudes </h2>
<p>We need to determine the unknown cluster amplitudes that enter in CCSD. Let</p>

$$
\begin{align}
\vert\Phi_i^a\rangle &= a^\dagger_a a_i \vert \Phi_0\rangle , 
\label{_auto9}\\
\vert\Phi_{ij}^{ab}\rangle &= a^\dagger_a a^\dagger_b a_j a_i \vert \Phi_0\rangle
\label{_auto10}
\end{align}
$$

<p>be 1p-1h and 2p-2h excitations of the reference. Computing matrix
elements of the Schroedinger Equation \eqref{Schroedinger} yields
</p>

$$
\begin{align}
\label{ccsd}
\langle \Phi_0\vert \overline{H_N}\vert \Phi_0\rangle &= E_c , \\
\langle \Phi_i^a\vert \overline{H_N}\vert \Phi_0\rangle &= 0 , 
\label{_auto11}\\
\langle \Phi_{ij}^{ab}\vert \overline{H_N}\vert \Phi_0\rangle &= 0 .
\label{_auto12}
\end{align}
$$


<!-- !split -->
<h2 id="correlation-energy" class="anchor">Correlation energy </h2>

<p>The first equation states that the coupled-cluster correlation energy
is an expectation value of the similarity-transformed Hamiltonian. The
second and third equations state that the similarity-transformed
Hamiltonian exhibits no 1p-1h and no 2p-2h excitations. These
equations have to be solved to find the unknown amplitudes \( t_i^a \) and
\( t_{ij}^{ab} \). Then one can use these amplitudes and compute the
correlation energy from the first line of Eq. \eqref{ccsd}.
</p>

<p>We note that in the CCSD approximation the reference state is not an
exact eigenstates. Rather, it is decoupled from simple states but
\( \overline{H} \) still connects this state to 3p-3h, and 4p-4h states
etc.
</p>

<!-- !split -->
<h2 id="good-reference-state" class="anchor">Good reference state </h2>

<p>At this point, it is important to recall that we assumed starting from
a &quot;good&quot; reference state. In such a case, we might reasonably expect
that the inclusion of 1p-1h and 2p-2h excitations could result in an
accurate approximation. Indeed, empirically one finds that CCSD
accounts for about 90% of the corelation energy, i.e. of the
difference between the exact energy and the Hartree-Fock energy. The
inclusion of triples (3p-3h excitations) typically yields 99% of the
correlation energy.
</p>

<p>We see that the coupled-cluster method in its CCSD approximation
yields a similarity-transformed Hamiltonian that is of a two-body
structure with respect to a non-trivial vacuum. When viewed in this
light, the coupled-cluster method &quot;transforms&quot; an \( A \)-body problem
(in CCSD) into a two-body problem, albeit with respect to a nontrivial
vacuum.
</p>

<!-- !split -->

<!-- --- begin exercise --- -->
<h2 id="exercise-1-why-is-ccd-not-exact" class="anchor">Exercise 1: Why is CCD not exact? </h2>

<p>Above we argued that a similarity transformation preserves all eigenvalues. Nevertheless, the CCD correlation energy is not the exact correlation energy. Explain!</p>

<p>The CCD approximation does not make \( \vert\Phi_0\rangle \) an exact
eigenstate of \( \overline{H_N} \); it is only an eigenstate when the
similarity-transformed Hamiltonian is truncated to at most 2p-2h
states. The full \( \overline{H_N} \), with \( T=T_2 \), would involve
six-body terms (do you understand this?), and this full Hamiltonian
would reproduce the exact correlation energy. Thus CCD is a similarity
transformation plus a truncation, which decouples the ground state only
from 2p-2h states.
</p>

<!-- --- end exercise --- -->

<!-- !split -->
<h2 id="computing-the-similarity-transformed-hamiltonian" class="anchor">Computing the similarity-transformed Hamiltonian </h2>

<p>The solution of the CCSD equations, i.e. the second and third line of
Eq. \eqref{ccsd}, and the computation of the correlation energy
requires us to compute matrix elements of the similarity-transformed
Hamiltonian \eqref{Hsim}. This can be done with the
Baker-Campbell-Hausdorff expansion
</p>

$$
\begin{align}
\label{BCH}
\overline{H_N} &= e^{-T} H_N e^T \\
&=H_N + \left[ H_N, T\right]+ \frac{1}{2!}\left[ \left[ H_N, T\right], T\right]
+ \frac{1}{3!}\left[\left[ \left[ H_N, T\right], T\right], T\right] +\ldots .
\label{_auto13}
\end{align}
$$


<!-- !split -->
<h2 id="the-cluster-operator" class="anchor">The cluster operator </h2>

<p>We now come to a key element of coupled-cluster theory: the cluster
operator \eqref{Top} consists of sums of terms that consist of particle
creation and hole annihilation operators (but no particle annihilation
or hole creation operators). Thus, all terms that enter \( T \) commute
with each other. This means that the commutators in the
Baker-Campbell-Hausdorff expansion \eqref{BCH} can only be non-zero
because each \( T \) must connect to \( H_N \) (but no \( T \) with another
\( T \)). Thus, the expansion is finite.
</p>

<!-- !split -->
<h2 id="when-does-ccsd-truncate" class="anchor">When does CCSD truncate? </h2>

<p>In CCSD and for two-body Hamiltonians, how many nested
commutators yield nonzero results? Where does the
Baker-Campbell-Hausdorff expansion terminate? What is the (many-body) rank of the resulting \( \overline{H_N} \)? 
</p>

<p>CCSD truncates for two-body operators at four-fold nested commutators,
because each of the four annihilation and creation operators in
\( \overline{H_N} \) can be knocked out with one term of \( T \).
</p>

<!-- !split -->
<h2 id="non-hermitian-hamiltonian" class="anchor">Non-hermitian Hamiltonian </h2>

<p>We see that the (disadvantage of having a) non-Hermitian Hamiltonian
\( \overline{H_N} \) leads to the advantage that the
Baker-Campbell-Hausdorff expansion is finite, thus leading to the
possibility to compute \( \overline{H_N} \) exactly. In contrast, the
IMSRG deals with a Hermitian Hamiltonian throughout, and the infinite
Baker-Campbell-Hausdorff expansion is truncated at a high order when
terms become very small.
</p>

<!-- !split -->
<h2 id="similarity-transformed-hamiltonian" class="anchor">Similarity transformed Hamiltonian </h2>

<p>We write the similarity-transformed Hamiltonian as</p>

$$
\begin{align}
\overline{H_N}=\sum_{pq} \overline{H}^p_q a^\dagger_q a_p + {1\over 4} \sum_{pqrs} \overline{H}^{pq}_{rs} a^\dagger_p a^\dagger_q a_s a_r + \ldots
\label{_auto14}
\end{align}
$$

<p>with</p>
$$
\begin{align}
\overline{H}^p_q &\equiv \langle p\vert \overline{H_N}\vert q\rangle , 
\label{_auto15}\\
\overline{H}^{pq}_{rs} &\equiv \langle pq\vert \overline{H_N}\vert rs\rangle .
\label{_auto16}
\end{align}
$$

<p>Thus, the CCSD Eqs.&nbsp;\eqref{ccsd} for the amplitudes can be written as
\( \overline{H}_i^a = 0 \) and \( \overline{H}_{ij}^{ab}=0 \).
</p>

<!-- !split -->
<h2 id="compute-the-matrix-element-overline-h-ab-ij-equiv-langle-ij-vert-overline-h-n-vert-ab-rangle" class="anchor">Compute the matrix element \( \overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle \) </h2>

<p>This is a simple task. This matrix element is part of the operator
\( \overline{H}_{ab}^{ij}a^\dagger_ia^\dagger_ja_ba_a \), i.e. particles
are annihilated and holes are created. Thus, no contraction of the
Hamiltonian \( H \) with any cluster operator \( T \) (remember that \( T \)
annihilates holes and creates particles) can happen, and we simply
have \( \overline{H}_{ab}^{ij} = \langle ij\vert V\vert ab\rangle \).
</p>

<!-- !split -->
<h2 id="algebraic-manipulations" class="anchor">Algebraic manipulations </h2>

<p>We need to work out the similarity-transformed Hamiltonian of
Eq. \eqref{BCH}. To do this, we write \( T=T_1 +T_2 \) and \( H_N= F +V \),
where \( T_1 \) and \( F \) are one-body operators, and \( T_2 \) and \( V \) are
two-body operators.
</p>

<!-- !split -->
<h2 id="example-the-contribution-of-f-t-2-to-overline-h-n" class="anchor">Example: The contribution of \( [F, T_2] \) to \( \overline{H_N} \) </h2>

<p>The commutator \( [F, T_2] \) consists of two-body and one-body terms. Let
us compute first the two-body term, as it results from a single
contraction (i.e. a single application of \( [a_p, a^\dagger_q] =
\delta_p^q \)). We denote this as \( [F, T_2]_{2b} \) and find
</p>

$$
\begin{align*}
[F, T_2]_{2b} &= \frac{1}{4}\sum_{pq}\sum_{rsuv} \langle q \vert f \vert p \rangle  t_{ij}^{ab}\left[a^\dagger_q a_p, a^\dagger_a a^\dagger_b a_j a_i \right]_{2b} \\
&= \frac{1}{4}\sum_{pq}\sum_{abij} \langle q \vert f \vert p \rangle  t_{ij}^{ab}\delta_p^a a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{pq}\sum_{abij} \langle q \vert f \vert p \rangle  t_{ij}^{ab}\delta_p^b a^\dagger_q a^\dagger_a a_j a_i  \\
&- \frac{1}{4}\sum_{pq}\sum_{abij} \langle q \vert f \vert p \rangle  t_{ij}^{ab}\delta_q^j a^\dagger_a a^\dagger_b a_p a_i  \\
&+ \frac{1}{4}\sum_{pq}\sum_{abij} \langle q \vert f \vert p \rangle  t_{ij}^{ab}\delta_q^i a^\dagger_a a^\dagger_b a_p a_j  \\
&= \frac{1}{4}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{qaij}\left(\sum_{b} f_b^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_a a_j a_i  \\
&- \frac{1}{4}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  \\
&+ \frac{1}{4}\sum_{pabj}\left(\sum_{i} f_p^i t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_j  \\
&= \frac{1}{2}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{2}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
$$


<!-- !split -->
<h2 id="antisymmetry" class="anchor">Antisymmetry </h2>

<p>Here we exploited the antisymmetry \( t_{ij}^{ab} = -t_{ji}^{ab} =
-t_{ij}^{ba} = t_{ji}^{ba} \) in the last step. Using \( a^\dagger_q a^\dagger_b a_j a_i = -a^\dagger_b a^\dagger_q a_j a_i  \) and \( a^\dagger_a a^\dagger_b a_p a_i = a^\dagger_a a^\dagger_b a_i a_p \), we can make the expression 
manifest antisymmetric, i.e.
</p>

$$
\begin{align*}
[F, T_2]_{2b}
&= \frac{1}{4}\sum_{qbij}\left[\sum_{a} \left(f_a^q t_{ij}^{ab}-f_a^b t_{ij}^{qa}\right)\right]a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{pabi}\left[\sum_{j} \left(f_p^j t_{ij}^{ab}-f_i^j t_{pj}^{ab}\right)\right]a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
$$


<!-- !split -->
<h2 id="final-contribution" class="anchor">Final contribution </h2>
<p>Thus, the contribution of \( [F, T_2]_{2b} \) to the matrix element \( \overline{H}_{ij}^{ab} \) is  </p>
$$
\begin{align*}
\overline{H}_{ij}^{ab} \leftarrow  \sum_{c} \left(f_c^a t_{ij}^{cb}-f_c^b t_{ij}^{ac}\right) - \sum_{k} \left(f_j^k t_{ik}^{ab}-f_i^k t_{jk}^{ab}\right)
\end{align*}
$$

<p>Here we used an arrow to indicate that this is just one contribution
to this matrix element.  We see that the derivation straight forward,
but somewhat tedious. As no one likes to commute too much (neither in
this example nor when going to and from work), and so we need a better
approach. This is where diagramms come in handy.
</p>

<!-- !split -->
<h2 id="assign-the-correct-matrix-element-langle-pq-vert-v-vert-rs-rangle-to-each-of-the-following-diagrams-of-the-interaction" class="anchor">Assign the correct matrix element \( \langle pq\vert V\vert rs\rangle \) to each of the following diagrams of the interaction </h2>

<p>Remember: \( \langle\rm{left-out, right-out}\vert V\vert \rm{left-in, right-in}\rangle \).</p>

<!-- FIGURE: [figslides/Diagrams-V1.png, width=400 frac=0.8] -->

\( \langle ab\vert V\vert cd\rangle + \langle ij\vert V\vert kl\rangle + \langle ia\vert V\vert bj\rangle \)

<!-- FIGURE: [figslides/Diagrams-V2.png, width=400 frac=0.8] -->

\( \langle ai\vert V\vert bc\rangle + \langle ij\vert V\vert ka\rangle + \langle ab\vert V\vert ci\rangle \)

<!-- FIGURE: [figslides/Diagrams-V3.png, width=400 frac=0.8] -->

\( \langle ia\vert V\vert jk\rangle + \langle ab\vert V\vert ij\rangle + \langle ij\vert V\vert ab\rangle \)

<!-- !split -->
<h2 id="ccd-approximation" class="anchor">CCD Approximation </h2>

<p>In what follows, we will consider the coupled cluster doubles (CCD)
approximation. This approximation is valid in cases where the system
cannot exhibit any particle-hole excitations (such as nuclear matter
when formulated on a momentum-space grid) or for the pairing model (as
the pairing interactions only excites pairs of particles). In this
case \( t_i^a=0 \) for all \( i, a \), and \( \overline{H}_i^a=0 \). The CCD
approximation is also of some sort of leading order approximation in
the Hartree-Fock basis (as the Hartree-Fock Hamiltonian exhibits no
particle-hole excitations).
</p>

<!-- !split -->
<h2 id="deriving-the-ccd-equations" class="anchor">Deriving the CCD equations </h2>

<p>Let us consider the matrix element \( \overline{H}_{ij}^{ab} \). Clearly,
it consists of all diagrams (i.e. all combinations of \( T_2 \), and a
single \( F \) or \( V \) that have two incoming hole lines and two outgoing
particle lines. Write down all these diagrams.
</p>

<p>We start systematically and  consider all combinations of \( F \) and \( V \) diagrams with 0, 1, and 2 cluster amplitudes \( T_2 \).</p>

<!-- !split -->
<h2 id="the-algebraic-expression" class="anchor">The algebraic expression  </h2>
$$
\begin{align*}
\overline{H}_{ij}^{ab} &= \langle ab\vert V\vert ij\rangle + P(ab)\sum_c f_c^bt_{ij}^{ac} - P(ij)\sum_k f_j^k t_{ik}^{ab} \\
&+ {1\over 2} \sum_{cd} \langle ab\vert V\vert cd\rangle t_{ij}^{cd}+ {1\over 2} \sum_{kl} \langle kl\vert V\vert ij\rangle t_{kl}^{ab} + P(ab)P(ij)\sum_{kc} \langle kb\vert V\vert cj \rangle t_{ik}^{ac} \\
&+ {1\over 2} P(ij)P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}t_{lj}^{db} 
+ {1\over 2} P(ij)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}t_{lj}^{ab}\\
&+ {1\over 2} P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}t_{ij}^{db}
+ {1\over 4} \sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}t_{kl}^{ab} . 
\end{align*}
$$


<!-- !split -->
<h2 id="computational-cost-of-a-ccd-computation" class="anchor">Computational cost of a CCD computation </h2>

<p>For each of the diagrams in (add fig) write down the
computational cost in terms of the number of occupied \( A \) and the
number of unoccupied \( n_u \) orbitals.
</p>

<p>The cost is \( A^2 n_u^2 \), \( A^2 n_u^3 \), \( A^3 n_u^2 \),
\( A^2 n_u^4 \), \( A^4 n_u^2 \), \( A^3 n_u^3 \),
\( A^4 n_u^4 \), \( A^4 n_u^4 \),
\( A^4 n_u^4 \), and \( A^4 n_u^4 \) for the respective diagrams.
</p>

<!-- !split -->
<h2 id="additional-details" class="anchor">Additional details </h2>

<p>Note that \( n_u\gg A \) in general. In textbooks, one reads that CCD (and
CCSD) cost only \( A^2n_u^4 \). Our most expensive diagrams, however are
\( A^4n_u^4 \). What is going on?
</p>

<p>To understand this puzzle, let us consider the last diagram of
Figure xx . We break up the computation into two steps,
computing first the intermediate
</p>
$$
\begin{align}
\chi_{ij}^{kl}\equiv {1\over 2} \sum_{cd} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}
\label{_auto17}
\end{align}
$$

<p>at a cost of \( A^4n_u^2 \), and then </p>
$$
\begin{align}
{1\over 2} \sum_{kl} \chi_{ij}^{kl} t_{kl}^{ab}  
\label{_auto18}
\end{align}
$$

<p>at a cost of \( A^4n_u^2 \). This is affordable. The price to pay is the
storage of the intermediate \( \chi_{ij}^{kl} \), i.e. we traded
memory for computational cycles. This trick is known as <b>factorization</b>.
</p>

<!-- !split -->
<h2 id="factorizing-the-remaining-diagrams-of-the-ccd-equation" class="anchor">Factorizing the remaining diagrams of the CCD equation </h2>

<p>Diagrams 7, 8, and 9 of Fig. xx also need to be factorized. </p>

<p>For diagram number 7, we compute</p>
$$
\begin{align}
\chi_{id}^{al}\equiv\sum_{kc} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}
\label{_auto19}
\end{align}
$$

<p>at a cost of \( A^3 n_u^3 \) and then compute</p>
$$
\begin{align}
{1\over 2} P(ij)P(ab) \sum_{ld} \chi_{id}^{al} t_{lj}^{db} 
\label{_auto20}
\end{align}
$$

<p>at the cost of \( A^3 n_u^3 \).</p>

<!-- !split -->
<h2 id="diagram-8" class="anchor">Diagram 8 </h2>
<p>For diagram number 8, we compute</p>
$$
\begin{align}
\chi_{i}^{l}\equiv -{1\over 2} \sum_{kcd} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}
\label{_auto21}
\end{align}
$$

<p>at a cost of \( A^3 n_u^2 \), and then compute</p>
$$
\begin{align}
-P(ij) \sum_l \chi_i^l t_{lj}^{ab}
\label{_auto22}
\end{align}
$$

<p>at the cost of \( A^3 n_u^2 \).</p>

<!-- !split -->
<h2 id="diagram-9" class="anchor">Diagram 9 </h2>
<p>For diagram number 9, we compute</p>
$$
\begin{align}
\chi_d^a\equiv{1\over 2} \sum_{kcl} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}
\label{_auto23}
\end{align}
$$

<p>at a cost of \( A^2 n_u^3 \) and then compute</p>
$$
\begin{align}
P(ab)\sum_d \chi_d^a t_{ij}^{db}
\label{_auto24}
\end{align}
$$

<p>at the cost of \( A^3 n_u^3 \).</p>

<!-- !split -->
<h2 id="solving-the-ccd-equations" class="anchor">Solving the CCD equations </h2>

<p>The CCD equations, depicted in Fig xx, are nonlinear in the
cluster amplitudes. How do we solve \( \overline{H}_{ij}^{ab}=0 \)? We
subtract \( (f_a^a +f_b^b -f_i^i -f_j^j)t_{ij}^{ab} \) from both sides of
\( \overline{H}_{ij}^{ab}=0 \) (because this term is contained in
\( \overline{H}_{ij}^{ab} \)) and find
</p>

$$
\begin{align*}
(f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} &= (f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} +\overline{H}_{ij}^{ab}
\end{align*}
$$


<!-- !split -->
<h2 id="more-manipulations" class="anchor">More manipulations </h2>
<p>Dividing by \( (f_i^i +f_j^j -f_a^a -f_b^b) \) yields</p>
$$
\begin{align}
t_{ij}^{ab} &= t_{ij}^{ab} + \frac{\overline{H}_{ij}^{ab}}{f_i^i +f_j^j -f_a^a -f_b^b}
\label{iter}
\end{align}
$$

<p>This equation is of the type \( t=f(t) \), and we solve it by iteration,
i.e. we start with a guess \( t_0 \) and iterate \( t_{n+1}=f(t_n) \), and
hope that this will converge to a solution. We take the perturbative result
</p>
$$
\begin{align}
\label{pert}
\left(t_{ij}^{ab}\right)_0 = \frac{\langle ab\vert V\vert ij\rangle}{f_i^i +f_j^j -f_a^a -f_b^b}
\end{align}
$$

<p>as a starting point, compute \( \overline{H}_{ij}^{ab} \), and find a new
\( t_{ij}^{ab} \) from the right-hand side of Eq. \eqref{iter}. We repeat
this process until the amplitudes (or the CCD energy) converge.
</p>

<!-- !split -->
<h2 id="ccd-for-the-pairing-hamiltonian" class="anchor">CCD for the pairing Hamiltonian </h2>

<p>You learned about the pairing Hamiltonian earlier in this
school. Convince yourself that this Hamiltonian does not induce any
1p-1h excitations. Let us solve the CCD equations for this
problem. This consists of the following steps
</p>

<ol>
<li> Write a function that compute the potential, i.e. it returns a four-indexed array (or tensor). We need \( \langle ab\vert V\vert cd\rangle \), \( \langle ij\vert V\vert kl\rangle \), and \( \langle ab\vert V\vert ij\rangle \). Why is there no \( \langle ab\vert V\vert id\rangle \) or \( \langle ai\vert V\vert jb\rangle \) ?</li>
<li> Write a function that computes the Fock matrix, i.e. a two-indexed array. We only need \( f_a^b \) and \( f_i^j \). Why?</li> 
<li> Initialize the cluster amplitudes according to Eq. \eqref{pert}, and solve Eq. \eqref{iter} by iteration. The cluster amplitudes \( T_1 \) and \( T_2 \) are two- and four-indexed arrays, respectively.</li>
</ol>
<p>Please note that the contraction of tensors (i.e. the summation over
common indices in products of tensors) is very user friendly and
elegant in python when <code>numpy.einsum</code> is used.
</p>

<!-- !split -->
<h2 id="solving-the-ccd-equations-for-the-pairing-problem" class="anchor">Solving the CCD equations for the pairing problem </h2>
<p>The Hamiltonian is</p>
$$
\begin{align}
H = \delta \sum_{p=1}^\Omega (p-1)\left(a^\dagger_{p+}a_{p+} + a^\dagger_{p-}a_{p-}\right)
-{g \over 2} \sum_{p, q=1}^\Omega a^\dagger_{p+}a^\dagger_{p-} a_{q-} a_{q+} .
\label{_auto25}
\end{align}
$$


<!-- <a href="https://github.com/NuclearTalent/ManyBody2018/tree/master/doc/Programs/Python/PairingModel" target="_self">Click for IPython notebook for FCI and CCD solutions</a> -->

<!-- @@@CODE Programs/CCD_PairingModel.py -->

<!-- !split -->
<h2 id="python-code" class="anchor">Python code </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic">## Coupled clusters in CCD approximation</span>
<span style="color: #408080; font-style: italic">## Implemented for the pairing model of Lecture Notes in Physics 936, Chapter 8.</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">init_pairing_v</span>(g,pnum,hnum):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    returns potential matrices of the pairing model in three relevant channels</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    param g: strength of the pairing interaction, as in Eq. (8.42)</span>
<span style="color: #BA2121; font-style: italic">    param pnum: number of particle states</span>
<span style="color: #BA2121; font-style: italic">    param hnum: number of hole states</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    return v_pppp, v_pphh, v_hhhh: np.array(pnum,pnum,pnum,pnum), </span>
<span style="color: #BA2121; font-style: italic">                                   np.array(pnum,pnum,hnum,hnum), </span>
<span style="color: #BA2121; font-style: italic">                                   np.array(hnum,hnum,hnum,hnum), </span>
<span style="color: #BA2121; font-style: italic">                                   The interaction as a 4-indexed tensor in three channels.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    v_pppp<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((pnum,pnum,pnum,pnum))
    v_pphh<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((pnum,pnum,hnum,hnum))
    v_hhhh<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((hnum,hnum,hnum,hnum))
    
    gval<span style="color: #666666">=-0.5*</span>g
    <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,pnum,<span style="color: #666666">2</span>):
        <span style="color: #008000; font-weight: bold">for</span> b <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,pnum,<span style="color: #666666">2</span>):
            v_pppp[a,a<span style="color: #666666">+1</span>,b,b<span style="color: #666666">+1</span>]<span style="color: #666666">=</span>gval
            v_pppp[a<span style="color: #666666">+1</span>,a,b,b<span style="color: #666666">+1</span>]<span style="color: #666666">=-</span>gval
            v_pppp[a,a<span style="color: #666666">+1</span>,b<span style="color: #666666">+1</span>,b]<span style="color: #666666">=-</span>gval
            v_pppp[a<span style="color: #666666">+1</span>,a,b<span style="color: #666666">+1</span>,b]<span style="color: #666666">=</span>gval
            
    <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,pnum,<span style="color: #666666">2</span>):
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,hnum,<span style="color: #666666">2</span>):
            v_pphh[a,a<span style="color: #666666">+1</span>,i,i<span style="color: #666666">+1</span>]<span style="color: #666666">=</span>gval
            v_pphh[a<span style="color: #666666">+1</span>,a,i,i<span style="color: #666666">+1</span>]<span style="color: #666666">=-</span>gval
            v_pphh[a,a<span style="color: #666666">+1</span>,i<span style="color: #666666">+1</span>,i]<span style="color: #666666">=-</span>gval
            v_pphh[a<span style="color: #666666">+1</span>,a,i<span style="color: #666666">+1</span>,i]<span style="color: #666666">=</span>gval
    
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,hnum,<span style="color: #666666">2</span>):
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,hnum,<span style="color: #666666">2</span>):
            v_hhhh[j,j<span style="color: #666666">+1</span>,i,i<span style="color: #666666">+1</span>]<span style="color: #666666">=</span>gval
            v_hhhh[j<span style="color: #666666">+1</span>,j,i,i<span style="color: #666666">+1</span>]<span style="color: #666666">=-</span>gval
            v_hhhh[j,j<span style="color: #666666">+1</span>,i<span style="color: #666666">+1</span>,i]<span style="color: #666666">=-</span>gval
            v_hhhh[j<span style="color: #666666">+1</span>,j,i<span style="color: #666666">+1</span>,i]<span style="color: #666666">=</span>gval
        
    <span style="color: #008000; font-weight: bold">return</span> v_pppp, v_pphh, v_hhhh
    
    
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">init_pairing_fock</span>(delta,g,pnum,hnum):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    initializes the Fock matrix of the pairing model</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    param delta: Single-particle spacing, as in Eq. (8.41)</span>
<span style="color: #BA2121; font-style: italic">    param g: pairing strength, as in eq. (8.42)</span>
<span style="color: #BA2121; font-style: italic">    param pnum: number of particle states</span>
<span style="color: #BA2121; font-style: italic">    param hnum: number of hole states</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    return f_pp, f_hh: The Fock matrix in two channels as numpy arrays np.array(pnum,pnum), np.array(hnum,hnum). </span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
<span style="color: #408080; font-style: italic"># the Fock matrix for the pairing model. No f_ph needed, because we are in Hartree-Fock basis </span>
    deltaval<span style="color: #666666">=0.5*</span>delta
    gval<span style="color: #666666">=-0.5*</span>g
    f_pp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((pnum,pnum))
    f_hh <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((hnum,hnum))

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,hnum,<span style="color: #666666">2</span>):
        f_hh[i  ,i  ] <span style="color: #666666">=</span> deltaval<span style="color: #666666">*</span>i<span style="color: #666666">+</span>gval
        f_hh[i<span style="color: #666666">+1</span>,i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> deltaval<span style="color: #666666">*</span>i<span style="color: #666666">+</span>gval
        
    <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,pnum,<span style="color: #666666">2</span>):
        f_pp[a  ,a  ] <span style="color: #666666">=</span> deltaval<span style="color: #666666">*</span>(hnum<span style="color: #666666">+</span>a)
        f_pp[a<span style="color: #666666">+1</span>,a<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> deltaval<span style="color: #666666">*</span>(hnum<span style="color: #666666">+</span>a)
    
    <span style="color: #008000; font-weight: bold">return</span> f_pp, f_hh


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">init_t2</span>(v_pphh,f_pp,f_hh):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Initializes t2 amlitudes as in MBPT2, see first equation on page 345</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    param v_pphh: pairing tensor in pphh channel</span>
<span style="color: #BA2121; font-style: italic">    param f_pp:   Fock matrix in pp channel</span>
<span style="color: #BA2121; font-style: italic">    param f_hh:   Fock matrix in hh channel</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    return t2: numpy array in pphh format, 4-indices tensor</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    pnum <span style="color: #666666">=</span> <span style="color: #008000">len</span>(f_pp)
    hnum <span style="color: #666666">=</span> <span style="color: #008000">len</span>(f_hh)
    t2_new <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((pnum,pnum,hnum,hnum))
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(hnum):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(hnum):
            <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(pnum):
                <span style="color: #008000; font-weight: bold">for</span> b <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(pnum):
                    t2_new[a,b,i,j] <span style="color: #666666">=</span> v_pphh[a,b,i,j] <span style="color: #666666">/</span> (f_hh[i,i]<span style="color: #666666">+</span>f_hh[j,j]<span style="color: #666666">-</span>f_pp[a,a]<span style="color: #666666">-</span>f_pp[b,b])
    <span style="color: #008000; font-weight: bold">return</span> t2_new


<span style="color: #408080; font-style: italic"># CCD equations. Note that the &quot;-&gt;abij&quot; assignment is redundant, because indices are ordered alphabetically.</span>
<span style="color: #408080; font-style: italic"># Nevertheless, we retain it for transparency.</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ccd_iter</span>(v_pppp,v_pphh,v_hhhh,f_pp,f_hh,t2):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Performs one iteration of the CCD equations (8.34), using also intermediates for the nonliniar terms</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    param v_pppp: pppp-channel pairing tensor, numpy array</span>
<span style="color: #BA2121; font-style: italic">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span style="color: #BA2121; font-style: italic">    param v_hhhh: hhhh-channel pairing tensor, numpy array</span>
<span style="color: #BA2121; font-style: italic">    param f_pp: Fock matrix in pp channel</span>
<span style="color: #BA2121; font-style: italic">    param f_hh: Fock matrix in hh channel</span>
<span style="color: #BA2121; font-style: italic">    param t2: Initial t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    return t2_new: new t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    pnum <span style="color: #666666">=</span> <span style="color: #008000">len</span>(f_pp)
    hnum <span style="color: #666666">=</span> <span style="color: #008000">len</span>(f_hh)
    Hbar_pphh <span style="color: #666666">=</span> (  v_pphh 
                 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;bc,acij-&gt;abij&#39;</span>,f_pp,t2) 
                 <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;ac,bcij-&gt;abij&#39;</span>,f_pp,t2) 
                 <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abik,kj-&gt;abij&#39;</span>,t2,f_hh)
                 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abjk,ki-&gt;abij&#39;</span>,t2,f_hh)
                 <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abcd,cdij-&gt;abij&#39;</span>,v_pppp,t2) 
                 <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abkl,klij-&gt;abij&#39;</span>,t2,v_hhhh)
                )

    <span style="color: #408080; font-style: italic"># hh intermediate, see (8.47)</span>
    chi_hh <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;cdkl,cdjl-&gt;kj&#39;</span>,v_pphh,t2)

    Hbar_pphh <span style="color: #666666">=</span> Hbar_pphh <span style="color: #666666">-</span> (  np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abik,kj-&gt;abij&#39;</span>,t2,chi_hh) 
                             <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abik,kj-&gt;abji&#39;</span>,t2,chi_hh) )

    <span style="color: #408080; font-style: italic"># pp intermediate, see (8.46)</span>
    chi_pp <span style="color: #666666">=</span> <span style="color: #666666">-0.5*</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;cdkl,bdkl-&gt;cb&#39;</span>,v_pphh,t2)

    Hbar_pphh <span style="color: #666666">=</span> Hbar_pphh <span style="color: #666666">+</span> (  np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;acij,cb-&gt;abij&#39;</span>,t2,chi_pp) 
                             <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;acij,cb-&gt;baij&#39;</span>,t2,chi_pp) )

    <span style="color: #408080; font-style: italic"># hhhh intermediate, see (8.48)</span>
    chi_hhhh <span style="color: #666666">=</span> <span style="color: #666666">0.5</span> <span style="color: #666666">*</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;cdkl,cdij-&gt;klij&#39;</span>,v_pphh,t2)

    Hbar_pphh <span style="color: #666666">=</span> Hbar_pphh <span style="color: #666666">+</span> <span style="color: #666666">0.5</span> <span style="color: #666666">*</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abkl,klij-&gt;abij&#39;</span>,t2,chi_hhhh)

    <span style="color: #408080; font-style: italic"># phph intermediate, see (8.49)</span>
    chi_phph<span style="color: #666666">=</span> <span style="color: #666666">+</span> <span style="color: #666666">0.5</span> <span style="color: #666666">*</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;cdkl,dblj-&gt;bkcj&#39;</span>,v_pphh,t2)


    Hbar_pphh <span style="color: #666666">=</span> Hbar_pphh <span style="color: #666666">+</span> (  np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;bkcj,acik-&gt;abij&#39;</span>,chi_phph,t2)
                             <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;bkcj,acik-&gt;baij&#39;</span>,chi_phph,t2)
                             <span style="color: #666666">-</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;bkcj,acik-&gt;abji&#39;</span>,chi_phph,t2)
                             <span style="color: #666666">+</span> np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;bkcj,acik-&gt;baji&#39;</span>,chi_phph,t2) )
                 
    t2_new<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((pnum,pnum,hnum,hnum))
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(hnum):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(hnum):
            <span style="color: #008000; font-weight: bold">for</span> a <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(pnum):
                <span style="color: #008000; font-weight: bold">for</span> b <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(pnum):
                    t2_new[a,b,i,j] <span style="color: #666666">=</span> (  t2[a,b,i,j] 
                                       <span style="color: #666666">+</span> Hbar_pphh[a,b,i,j] <span style="color: #666666">/</span> (f_hh[i,i]<span style="color: #666666">+</span>f_hh[j,j]<span style="color: #666666">-</span>f_pp[a,a]<span style="color: #666666">-</span>f_pp[b,b]) )

    <span style="color: #008000; font-weight: bold">return</span> t2_new


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ccd_energy</span>(v_pphh,t2):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Computes CCD energy. Call as </span>
<span style="color: #BA2121; font-style: italic">    energy = ccd_energy(v_pphh,t2)</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span style="color: #BA2121; font-style: italic">    param t2: t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    return energy: CCD correlation energy</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    erg <span style="color: #666666">=</span> <span style="color: #666666">0.25*</span>np<span style="color: #666666">.</span>einsum(<span style="color: #BA2121">&#39;abij,abij&#39;</span>,v_pphh,t2)
    <span style="color: #008000; font-weight: bold">return</span> erg

<span style="color: #408080; font-style: italic">###############################</span>
<span style="color: #408080; font-style: italic">######## Main Program</span>

<span style="color: #408080; font-style: italic"># set parameters as for model</span>
pnum <span style="color: #666666">=</span> <span style="color: #666666">4</span> <span style="color: #408080; font-style: italic"># number of particle states</span>
hnum <span style="color: #666666">=</span> <span style="color: #666666">4</span> <span style="color: #408080; font-style: italic"># number of hole states</span>
delta <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>

g <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>

<span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;parameters&quot;</span>)
<span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;delta =&quot;</span>, delta, <span style="color: #BA2121">&quot;, g =&quot;</span>, g)


<span style="color: #408080; font-style: italic"># Initialize pairing matrix elements and Fock matrix</span>
v_pppp, v_pphh, v_hhhh <span style="color: #666666">=</span> init_pairing_v(g,pnum,hnum)
f_pp, f_hh <span style="color: #666666">=</span> init_pairing_fock(delta,g,pnum,hnum)

<span style="color: #408080; font-style: italic"># Initialize T2 amplitudes from MBPT2</span>
t2 <span style="color: #666666">=</span> init_t2(v_pphh,f_pp,f_hh)
erg <span style="color: #666666">=</span> ccd_energy(v_pphh,t2)

<span style="color: #408080; font-style: italic"># Exact MBPT2 for comparison, see last equation on page 365 </span>
exact_mbpt2 <span style="color: #666666">=</span> <span style="color: #666666">-0.25*</span>g<span style="color: #666666">**2*</span>(<span style="color: #666666">1.0/</span>(<span style="color: #666666">2.0+</span>g) <span style="color: #666666">+</span> <span style="color: #666666">2.0/</span>(<span style="color: #666666">4.0+</span>g) <span style="color: #666666">+</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">6.0+</span>g))
<span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;MBPT2 energy =&quot;</span>, erg, <span style="color: #BA2121">&quot;, compared to exact:&quot;</span>, exact_mbpt2)
    
    
<span style="color: #408080; font-style: italic"># iterate CCD equations niter times</span>
niter<span style="color: #666666">=60</span>
<span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">iter</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(niter):
    t2_new <span style="color: #666666">=</span> ccd_iter(v_pppp,v_pphh,v_hhhh,f_pp,f_hh,t2)
    erg <span style="color: #666666">=</span> ccd_energy(v_pphh,t2_new)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;iter=&quot;</span>, <span style="color: #008000">iter</span>, <span style="color: #BA2121">&quot;erg=&quot;</span>, erg)
    t2 <span style="color: #666666">=</span> <span style="color: #666666">0.5</span> <span style="color: #666666">*</span> (t2_new <span style="color: #666666">+</span> t2) 
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

