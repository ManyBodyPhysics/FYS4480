<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="The Coupled Cluster Method">

<title>The Coupled Cluster Method</title>







<!-- reveal.js: http://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">The Coupled Cluster Method</h1></center>  <!-- document title -->

<p>
<!-- author(s): Thomas Papenbrock -->

<center>
<b>Thomas Papenbrock</b> 
</center>

<p>
<!-- institution -->

<center><b>The University of Tennessee, Knoxville, tpapenbr@utk.edu</b></center>
<br>
<p>&nbsp;<br>
<center><h4>Aug 4, 2018</h4></center> <!-- date -->
<br>

<h1 id="table_of_contents">Table of contents</h2>

<p>
<a href="#___sec0"> The Coupled-Cluster Method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> The normal-ordered Hamiltonian </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-1"> Exercise 1: Practice in normal ordering </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec4"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-2"> Exercise 2: What does &quot;good&quot; mean? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-3"> Exercise 3: How many nuclei are accessible with the coupled cluster method based on spherical mean fields? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec8"> </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> The similarity transformed Hamiltonian </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-4"> Exercise 4: What \( T \) leads to Hermitian \( \overline{H_N} \) ? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec11"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-5"> Exercise 5: Understanding (non-unitary) similarity transformations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-6"> Exercise 6: How many unknowns? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-6b"> Exercise 7: Why is CCD not exact? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Computing the similarity-transformed Hamiltonian </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-7"> Exercise 8: When does CCSD truncate? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec20"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-8"> Exercise 9: Compute the matrix element \( \overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-9"> Example: The contribution of \( [F, T_2] \) to \( \overline{H_N} \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec24"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-10"> Exercise 10: Assign the correct matrix element \( \langle pq\vert V\vert rs\rangle \) to each of the following diagrams of the interaction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-11"> Example: CCSD correlation energy </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> CCD Approximation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-12"> Exercise 11: Derive the CCD equations! </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec32"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-13"> Exercise 12: Computational scaling of CCD </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-14"> Exercise 13: Factorize the remaining diagrams of the CCD equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec36"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-15"> Project 14: (Optional) Derive the CCSD equations! </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec38"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec39"> Solving the CCD equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> CCD for the pairing Hamiltonian </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-16"> Project 15: Solve the CCD equations for the pairing problem </a><br>
<a href="#___sec42"> Nucleonic Matter </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-17"> Exercise 16: Which symmetries are relevant for nuclear matter? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec44"> </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Basis states </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-18"> Exercise 17: Determine the basis states </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec47"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-19"> Exercise 18: How large should the basis be? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec49"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-20"> Exercise 19: Determine the lowest few magic numbers for a cubic lattice. </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec52"> Finite size effects </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Channel structure of Hamiltonian and cluster amplitudes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-21"> Example: Channel structure and its usage </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec55"> </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex-30"> Exercise 20: Write a CCD code for neutron matter, focusing first on ladder approximation, i.e. including the first five diagrams in Figure <a href="#fig-ccd">11</a>. </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec57"> </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec58"> Benchmarks with the Minnesota potential </a><br>
<a href="#___sec59"> From Structure to Reactions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Electroweak reactions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Computing optical potentials from microscopic input </a><br>
</p>
<p>

<center><h1 id="___sec0">The Coupled-Cluster Method </h1></center> <hr>

<h1 id="___sec1">Introduction </h1>

<p>
The coupled-cluster method is an efficient tool to compute atomic
nuclei with an effort that grows polynomial with system size. While
this might still be expensive, it is now possible to compute nuclei
with mass numbers about \( A\approx 100 \) with this method. Recall that
full configuration interaction (FCI) such as the no-core shell model
exhibits an exponential cost and is therefore limited to light nuclei.

<p>
<center> <!-- figure label: --> <div id="fig-explosion"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Realistic computations of atomic nuclei with interactions from chiral EFT. The slow increase prior to 2015 is based on quantum Monte Carlo and the no-core shell model. These methods are exponentially expensive (in mass number \( A \)) and meet with exponentially increasing computer power (Moore's law), thus leading to a progress that is linear in time. Methods such as coupled clusters and in-medium SRG carry a polynomial cost in mass number are transforming the field.  <!-- caption label: fig-explosion --> </p></center>
<p><img src="figslides/Explosion.png" align="bottom" width=400></p>
</center>

<h1 id="___sec2">The normal-ordered Hamiltonian </h1>

<p>
We start from the reference state

<p>&nbsp;<br>
$$
\begin{equation}
\tag{1}
\vert\Phi_0\rangle = \prod_{i=1}^A a^\dagger_i \vert 0\rangle 
\end{equation}
$$
<p>&nbsp;<br>

<p>
for the description of a nucleus with mass number \( A \).  Usually, this
reference is the Hartree-Fock state, but that is not necessary. In the
shell-model picture, it could also be a product state where the lowest
\( A \) harmonic oscillator states are occupied.  Here and in what
follows, the indices \( i,j,k,\ldots \) run over hole states,
i.e. orbitals occupied in the reference state <a href="#mjx-eqn-1">(1)</a>, while
\( a,b,c,\ldots \) run over particle states, i.e. unoccupied
orbitals. Indices \( p,q,r,s \) can identify any orbital.  Let \( n_u \) be
the number of unoccupied states, and \( A \) is of course the number of
occupied states. We consider the Hamiltonian

<p>&nbsp;<br>
$$
\begin{equation}
\tag{2} H =
\sum_{pq} \varepsilon^p_q a^\dagger_p a_q +
\frac{1}{4}\sum_{pqrs}\langle pq\vert V\vert rs\rangle
a^\dagger_pa^\dagger_q a_sa_r
\end{equation}
$$
<p>&nbsp;<br>

<p>
The reference state <a href="#mjx-eqn-1">(1)</a> is a non-trivial vacuum of our theory. 
We normal order this Hamiltonian with respect to the nontrivial vacuum
state given by the Hartree-Fock reference and obtain the
normal-ordered Hamiltonian

<p>&nbsp;<br>
$$
\begin{equation}
\tag{3}
H_N = \sum_{pq} f_{pq} \left\{a^\dagger_p a_q\right\} + \frac{1}{4}\sum_{pqrs}\langle pq\vert V\vert rs\rangle \left\{a^\dagger_pa^\dagger_q a_sa_r\right\}.
\end{equation}
$$
<p>&nbsp;<br>

<p>
Here,

<p>&nbsp;<br>
$$
\begin{equation}
\tag{4}
f^p_q = \varepsilon^p_q + \sum_i \langle pi\vert V\vert qi\rangle
\end{equation}
$$
<p>&nbsp;<br>

<p>
is the Fock matrix. We note that the Fock matrix is diagonal in the
Hartree-Fock basis. The brackets \( \{\cdots\} \) in Eq. <a href="#mjx-eqn-3">(3)</a> denote
normal ordering, i.e. all operators that annihilate the nontrivial
vaccum <a href="#mjx-eqn-1">(1)</a> are to the right of those operators that create
with respect to that vaccum. Normal ordering implies that \( \langle
\Phi_0\vert H_N\vert \Phi_0\rangle = 0 \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-1">Exercise 1: Practice in normal ordering</h2>

<p>
Normal order the expression \( \sum\limits_{pq}\varepsilon_q^p a^\dagger_p a_q \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{pq}\varepsilon_q^p a^\dagger_p a_q
=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a   
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\tag{5}
\end{align}
$$
<p>&nbsp;<br>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
We have to move all operators that annihilate the reference state to the right of those that create on the reference state. Thus,
<p>&nbsp;<br>
$$
\begin{align}
\sum_{pq}\varepsilon_q^p a^\dagger_p a_q
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i a^\dagger_i a_j
\tag{6}\\
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
+\sum_{ij}\varepsilon_j^i \left(-a_ja^\dagger_i +\delta_i^j\right)
\tag{7}\\
&=\sum_{ab}\varepsilon_b^a a^\dagger_a a_b
+\sum_{ai}\varepsilon_i^a a^\dagger_a a_i
+\sum_{ai}\varepsilon_a^i a^\dagger_i a_a
-\sum_{ij}\varepsilon_j^i a_ja^\dagger_i +\sum_i \varepsilon_i^i
\tag{8}\\
&=\sum_{pq}\varepsilon_q^p \left\{a^\dagger_p a_q\right\} +\sum_i \varepsilon_i^i
\tag{9}
\end{align}
$$
<p>&nbsp;<br>

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec4"></div></h2>
</div>

<p>
We note that \( H = E_{HF} + H_N \), where

<p>&nbsp;<br>
$$
\begin{align}
E_{HF} &\equiv \langle\Phi_0\vert H\vert \Phi_0\rangle = \sum_{i} \varepsilon^i_i +\frac{1}{2}\sum_{ij}\langle ij\vert V\vert ij\rangle
\tag{10}
\end{align}
$$
<p>&nbsp;<br>

<p>
is the Hartree-Fock energy.
The coupled-cluster method is a very efficient tool to compute nuclei
when a &quot;good&quot; reference state is available. Let us assume that the
reference state results from a Hartree-Fock calculation.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-2">Exercise 2: What does &quot;good&quot; mean?</h2>

<p>
How do you know whether a Hartree-Fock state is a &quot;good&quot; reference?
Which results of the Hartree-Fock computation will inform you?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
Once the Hartree-Fock equations are solved, the Fock matrix
<a href="#mjx-eqn-4">(4)</a> becomes diagonal, and its diagonal elements can be viewed
as single-particle energies. Hopefully, there is a clear gap in the
single-particle spectrum at the Fermi surface, i.e. after \( A \) orbitals
are filled.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec6"></div></h2>
</div>

<p>
If symmetry-restricted Hartree-Fock is used, one is limited to compute
nuclei with closed subshells for neutrons and for protons. On a first
view, this might seem as a severe limitation. But is it?

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-3">Exercise 3: How many nuclei are accessible with the coupled cluster method based on spherical mean fields?</h2>

<p>
If one limits oneself to nuclei with mass number up to
mass number \( A=60 \), how many nuclei can potentially be described with
the coupled-cluster method? Which of these nuclei are potentially
interesting? Why?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
Nuclear shell closures are at \( N,Z=2,8,20,28,50,82,126 \), and subshell
closures at \( N,Z=2,6,8,14,16,20,28,32,34,40,50,\ldots \).

<p>
In the physics of nuclei, the evolution of nuclear structure as
neutrons are added (or removed) from an isotope is a key
<!-- interest. Examples are the rare isotopes of helium (\( ^{8,10} \) He) -->
<!-- oxygen (\( ^{22,24,28} \) O), calcium (\( ^{52,54,60} \) Ca), nickel (\( ^{78} \) -->
<!-- Ni) and tin (\( ^{100,132} \) Sn). The coupled-cluster method has the -->
interest. Examples are the rare isotopes of helium (He-8,10)
oxygen (O-22,24,28), calcium (Ca-52,54,60), nickel (Ni-78) and tin
(Sn-100,132). The coupled-cluster method has the
potential to address questions regarding these nuclei, and in a
several cases was used to make predictions before experimental data
was available. In addition, the method can be used to compute
neighbors of nuclei with closed subshells.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec8"></div></h2>
</div>

<h1 id="___sec9">The similarity transformed Hamiltonian </h1>

<p>
There are several ways to view and understand the coupled-cluster
method. A first simple view of coupled-cluster theory is that the
method induces correlations into the reference state by expressing a
correlated state as

<p>&nbsp;<br>
$$
\begin{equation}
\tag{11}
\vert\Psi\rangle = e^T \vert\Phi_0\rangle ,
\end{equation}
$$
<p>&nbsp;<br>

<p>
Here, \( T \) is an operator that induces correlations. We can now demand
that the correlate state <a href="#mjx-eqn-11">(11)</a> becomes and eigenstate of the
Hamiltonian \( H_N \), i.e.  \( H_N\vert \Psi\rangle = E\vert \Psi\rangle \). This view,
while correct, is not the most productive one.  Instead, we
left-multiply the Schroedinger equation with \( e^{-T} \) and find

<p>&nbsp;<br>
$$
\begin{equation}
\tag{12}
\overline{H_N}\vert \Phi_0\rangle = E_c \vert \Phi_0\rangle . 
\end{equation}
$$
<p>&nbsp;<br>

<p>
Here, \( E_c \) is the correlation energy, and the total energy is
\( E=E_c+E_{HF} \).  The similarity-transformed Hamiltonian is defined as

<p>&nbsp;<br>
$$
\begin{equation}
\tag{13}
\overline{H_N} \equiv e^{-T} H_N e^T .
\end{equation}
$$
<p>&nbsp;<br>

<p>
A more productive view on coupled-cluster theory thus emerges: This
method seeks a similarity transformation such that the uncorrelated
reference state <a href="#mjx-eqn-1">(1)</a> becomes an exact eigenstate of the
similarity-transformed Hamiltonian <a href="#mjx-eqn-13">(13)</a>.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-4">Exercise 4: What \( T \) leads to Hermitian \( \overline{H_N} \) ?</h2>

<p>
What are the conditions on \( T \) such that \( \overline{H_N} \) is Hermitian?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
For a Hermitian \( \overline{H_N} \), we need a unitary \( e^T \), i.e. an
anti-Hermitian \( T \) with \( T = -T^\dagger \)

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec11"></div></h2>
</div>

<p>
As we will see below, coupld-cluster theory employs a non-Hermitian Hamiltonian.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-5">Exercise 5: Understanding (non-unitary) similarity transformations</h2>

<p>
Show that \( \overline{H_N} \) has the same eigenvalues as \( H_N \) for
arbitrary \( T \). What is the spectral decomposition of a non-Hermitian
\( \overline{H_N} \) ?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
Let \( H_N\vert E\rangle = E\vert E\rangle \). Thus

<p>&nbsp;<br>
$$
\begin{align*}
H_N e^{T} e^{-T} \vert E\rangle &= E\vert E\rangle , \\
\left(e^{-T} H_N e^T\right) e^{-T} \vert E\rangle &= Ee^{-T} \vert E\rangle , \\
\overline{H_N} e^{-T} \vert E\rangle &= E e^{-T}\vert E\rangle .
\end{align*}
$$
<p>&nbsp;<br>

<p>
Thus, if \( \vert E\rangle \) is an eigenstate of \( H_N \) with eigenvalue \( E \),
then \( e^{-T}\vert E\rangle \) is eigenstate of \( \overline{H_N} \) with the same
eigenvalue.

<p>
A non-Hermitian \( \overline{H_N} \) has eigenvalues \( E_\alpha \)
corresponding to left \( \langle L_\alpha\vert  \) and right \( \vert R_\alpha
\rangle \) eigenstates. Thus

<p>&nbsp;<br>
$$
\begin{align}
\overline{H_N} = \sum_\alpha \vert R_\alpha\rangle E_\alpha \langle L_\alpha \vert 
\tag{14}
\end{align}
$$
<p>&nbsp;<br>

with bi-orthonormal \( \langle L_\alpha\vert R_\beta\rangle = \delta_\alpha^\beta \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec13"></div></h2>
</div>

<p>
To make progress, we have to specify the cluster operator \( T \). In
coupled cluster theory, this operator is

<p>&nbsp;<br>
$$
\begin{equation}
\tag{15}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i + \cdots
+ \frac{1}{(A!)^2}\sum_{i_1\ldots i_A a_1 \ldots a_A}
t_{i_1\ldots i_A}^{a_1\ldots a_A} a^\dagger_{a_1}\cdots a^\dagger_{a_A} a_{i_A}\cdots a_{i_1} .
\end{equation}
$$
<p>&nbsp;<br>

<p>
Thus, the operator <a href="#mjx-eqn-15">(15)</a> induces particle-hole (p-h)
excitations with respect to the reference. In general, \( T \) generates
up to \( Ap-Ah \) excitations, and the unknown parameters are the cluster amplitides
\( t_i^a \), \( t_{ij}^{ab} \), ..., \( t_{i_1,\ldots,i_A}^{a_1,\ldots,a_A} \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-6">Exercise 6: How many unknowns?</h2>

<p>
Show that the number of unknowns is as large as the FCI dimension of
the problem, using the numbers \( A \) and \( n_u \).

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
We have to sum up all \( np-nh \) excitations, and there are
\( \binom{n_u}{n} \) particle states and \( \binom{A}{A-n} \) hole states for
each \( n \). Thus, we have for the total number

<p>&nbsp;<br>
$$
\begin{align}
\sum_{n=0}^A \binom{n_u}{n} \binom{A}{A-n}= \binom{A+n_u}{A} .
\tag{16}
\end{align}
$$
<p>&nbsp;<br>

<p>
The right hand side are obviously all ways to distribute \( A \) fermions over \( n_0+A \) orbitals.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec15"></div></h2>
</div>

<p>
Thus, the coupled-cluster method with the full cluster operator
<a href="#mjx-eqn-15">(15)</a> is exponentially expensive, just as FCI. To make progress,
we need to make an approximation by truncating the operator. Here, we
will use the CCSD (coupled clusters singles doubles) approximation,
where

<p>&nbsp;<br>
$$
\begin{equation}
\tag{17}
T \equiv \sum_{ia} t_i^a a^\dagger_a a_i + \frac{1}{4}\sum_{ijab}t_{ij}^{ab}
a^\dagger_aa^\dagger_ba_ja_i .
\end{equation}
$$
<p>&nbsp;<br>

<p>
We need to determine the unknown cluster amplitudes that enter in CCSD. Let

<p>&nbsp;<br>
$$
\begin{align}
\vert\Phi_i^a\rangle &= a^\dagger_a a_i \vert \Phi_0\rangle , 
\tag{18}\\
\vert\Phi_{ij}^{ab}\rangle &= a^\dagger_a a^\dagger_b a_j a_i \vert \Phi_0\rangle
\tag{19}
\end{align}
$$
<p>&nbsp;<br>

<p>
be 1p-1h and 2p-2h excitations of the reference. Computing matrix
elements of the Schroedinger Equation <a href="#mjx-eqn-12">(12)</a> yields

<p>&nbsp;<br>
$$
\begin{align}
\tag{20}
\langle \Phi_0\vert \overline{H_N}\vert \Phi_0\rangle &= E_c , \\
\langle \Phi_i^a\vert \overline{H_N}\vert \Phi_0\rangle &= 0 , 
\tag{21}\\
\langle \Phi_{ij}^{ab}\vert \overline{H_N}\vert \Phi_0\rangle &= 0 .
\tag{22}
\end{align}
$$
<p>&nbsp;<br>

<p>
The first equation states that the coupled-cluster correlation energy
is an expectation value of the similarity-transformed Hamiltonian. The
second and third equations state that the similarity-transformed
Hamiltonian exhibits no 1p-1h and no 2p-2h excitations. These
equations have to be solved to find the unknown amplitudes \( t_i^a \) and
\( t_{ij}^{ab} \). Then one can use these amplitudes and compute the
correlation energy from the first line of Eq. <a href="#mjx-eqn-20">(20)</a>.

<p>
We note that in the CCSD approximation the reference state is not an
exact eigenstates. Rather, it is decoupled from simple states but
\( \overline{H} \) still connects this state to 3p-3h, and 4p-4h states
etc.

<p>
At this point, it is important to recall that we assumed starting from
a &quot;good&quot; reference state. In such a case, we might reasonably expect
that the inclusion of 1p-1h and 2p-2h excitations could result in an
accurate approximation. Indeed, empirically one finds that CCSD
accounts for about 90% of the corelation energy, i.e. of the
difference between the exact energy and the Hartree-Fock energy. The
inclusion of triples (3p-3h excitations) typically yields 99% of the
correlation energy.

<p>
We see that the coupled-cluster method in its CCSD approximation
yields a similarity-transformed Hamiltonian that is of a two-body
structure with respect to a non-trivial vacuum. When viewed in this
light, the coupled-cluster method &quot;transforms&quot; an \( A \)-body problem
(in CCSD) into a two-body problem, albeit with respect to a nontrivial
vacuum.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-6b">Exercise 7: Why is CCD not exact?</h2>

<p>
Above we argued that a similarity transformation preserves all eigenvalues. Nevertheless, the CCD correlation energy is not the exact correlation energy. Explain!

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
The CCD approximation does not make \( \vert\Phi_0\rangle \) an exact
eigenstate of \( \overline{H_N} \); it is only an eigenstate when the
similarity-transformed Hamiltonian is truncated to at most 2p-2h
states. The full \( \overline{H_N} \), with \( T=T_2 \), would involve
six-body terms (do you understand this?), and this full Hamiltonian
would reproduce the exact correlation energy. Thus CCD is a similarity
transformation plus a truncation, which decouples the ground state only
from 2p-2h states.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec17"></div></h2>
</div>

<h1 id="___sec18">Computing the similarity-transformed Hamiltonian </h1>

<p>
The solution of the CCSD equations, i.e. the second and third line of
Eq. <a href="#mjx-eqn-20">(20)</a>, and the computation of the correlation energy
requires us to compute matrix elements of the similarity-transformed
Hamiltonian <a href="#mjx-eqn-13">(13)</a>. This can be done with the
Baker-Campbell-Hausdorff expansion

<p>&nbsp;<br>
$$
\begin{align}
\tag{23}
\overline{H_N} &= e^{-T} H_N e^T \\
&=H_N + \left[ H_N, T\right]+ \frac{1}{2!}\left[ \left[ H_N, T\right], T\right]
+ \frac{1}{3!}\left[\left[ \left[ H_N, T\right], T\right], T\right] +\ldots .
\tag{24}
\end{align}
$$
<p>&nbsp;<br>

<p>
We now come to a key element of coupled-cluster theory: the cluster
operator <a href="#mjx-eqn-15">(15)</a> consists of sums of terms that consist of particle
creation and hole annihilation operators (but no particle annihilation
or hole creation operators). Thus, all terms that enter \( T \) commute
with each other. This means that the commutators in the
Baker-Campbell-Hausdorff expansion <a href="#mjx-eqn-23">(23)</a> can only be non-zero
because each \( T \) must connect to \( H_N \) (but no \( T \) with another
\( T \)). Thus, the expansion is finite.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-7">Exercise 8: When does CCSD truncate?</h2>

<p>
In CCSD and for two-body Hamiltonians, how many nested
commutators yield nonzero results? Where does the
Baker-Campbell-Hausdorff expansion terminate? What is the (many-body) rank of the resulting \( \overline{H_N} \)?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
CCSD truncates for two-body operators at four-fold nested commutators,
because each of the four annihilation and creation operators in
\( \overline{H_N} \) can be knocked out with one term of \( T \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec20"></div></h2>
</div>

<p>
We see that the (disadvantage of having a) non-Hermitian Hamiltonian
\( \overline{H_N} \) leads to the advantage that the
Baker-Campbell-Hausdorff expansion is finite, thus leading to the
possibility to compute \( \overline{H_N} \) exactly. In contrast, the
IMSRG deals with a Hermitian Hamiltonian throughout, and the infinite
Baker-Campbell-Hausdorff expansion is truncated at a high order when
terms become very small.

<p>
We write the similarity-transformed Hamiltonian as

<p>&nbsp;<br>
$$
\begin{align}
\overline{H_N}=\sum_{pq} \overline{H}^p_q a^\dagger_q a_p + {1\over 4} \sum_{pqrs} \overline{H}^{pq}_{rs} a^\dagger_p a^\dagger_q a_s a_r + \ldots
\tag{25}
\end{align}
$$
<p>&nbsp;<br>

with
<p>&nbsp;<br>
$$
\begin{align}
\overline{H}^p_q &\equiv \langle p\vert \overline{H_N}\vert q\rangle , 
\tag{26}\\
\overline{H}^{pq}_{rs} &\equiv \langle pq\vert \overline{H_N}\vert rs\rangle .
\tag{27}
\end{align}
$$
<p>&nbsp;<br>

<p>
Thus, the CCSD Eqs.&nbsp;<a href="#mjx-eqn-20">(20)</a> for the amplitudes can be written as
\( \overline{H}_i^a = 0 \) and \( \overline{H}_{ij}^{ab}=0 \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-8">Exercise 9: Compute the matrix element \( \overline{H}_{ab}^{ij}\equiv \langle ij\vert \overline{H_N}\vert ab\rangle \)</h2>

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
This is a simple task. This matrix element is part of the operator
\( \overline{H}_{ab}^{ij}a^\dagger_ia^\dagger_ja_ba_a \), i.e. particles
are annihilated and holes are created. Thus, no contraction of the
Hamiltonian \( H \) with any cluster operator \( T \) (remember that \( T \)
annihilates holes and creates particles) can happen, and we simply
have \( \overline{H}_{ab}^{ij} = \langle ij\vert V\vert ab\rangle \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec22"></div></h2>
</div>

<p>
We need to work out the similarity-transformed Hamiltonian of
Eq. <a href="#mjx-eqn-23">(23)</a>. To do this, we write \( T=T_1 +T_2 \) and \( H_N= F +V \),
where \( T_1 \) and \( F \) are one-body operators, and \( T_2 \) and \( V \) are
two-body operators.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>

<h2 id="ex-9">Example: The contribution of \( [F, T_2] \) to \( \overline{H_N} \)</h2>

<p>
The commutator \( [F, T_2] \) consists of two-body and one-body terms. Let
us compute first the two-body term, as it results from a single
contraction (i.e. a single application of \( [a_p, a^\dagger_q] =
\delta_p^q \)). We denote this as \( [F, T_2]_{2b} \) and find

<p>&nbsp;<br>
$$
\begin{align*}
[F, T_2]_{2b} &= \frac{1}{4}\sum_{pq}\sum_{rsuv} f_p^q t_{ij}^{ab}\left[a^\dagger_q a_p, a^\dagger_a a^\dagger_b a_j a_i \right]_{2b} \\
&= \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_p^a a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_p^b a^\dagger_q a^\dagger_a a_j a_i  \\
&- \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_q^j a^\dagger_a a^\dagger_b a_p a_i  \\
&+ \frac{1}{4}\sum_{pq}\sum_{abij} f_p^q t_{ij}^{ab}\delta_q^i a^\dagger_a a^\dagger_b a_p a_j  \\
&= \frac{1}{4}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{qaij}\left(\sum_{b} f_b^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_a a_j a_i  \\
&- \frac{1}{4}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  \\
&+ \frac{1}{4}\sum_{pabj}\left(\sum_{i} f_p^i t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_j  \\
&= \frac{1}{2}\sum_{qbij}\left(\sum_{a} f_a^q t_{ij}^{ab}\right)a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{2}\sum_{pabi}\left(\sum_{j} f_p^j t_{ij}^{ab}\right)a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
$$
<p>&nbsp;<br>

<p>
Here we exploited the antisymmetry \( t_{ij}^{ab} = -t_{ji}^{ab} =
-t_{ij}^{ba} = t_{ji}^{ba} \) in the last step. Using \( a^\dagger_q a^\dagger_b a_j a_i = -a^\dagger_b a^\dagger_q a_j a_i  \) and \( a^\dagger_a a^\dagger_b a_p a_i = a^\dagger_a a^\dagger_b a_i a_p \), we can make the expression 
manifest antisymmetric, i.e.

<p>&nbsp;<br>
$$
\begin{align*}
[F, T_2]_{2b}
&= \frac{1}{4}\sum_{qbij}\left[\sum_{a} \left(f_a^q t_{ij}^{ab}-f_a^b t_{ij}^{qa}\right)\right]a^\dagger_q a^\dagger_b a_j a_i  \\
&- \frac{1}{4}\sum_{pabi}\left[\sum_{j} \left(f_p^j t_{ij}^{ab}-f_i^j t_{pj}^{ab}\right)\right]a^\dagger_a a^\dagger_b a_p a_i  .
\end{align*}
$$
<p>&nbsp;<br>

Thus, the contribution of \( [F, T_2]_{2b} \) to the matrix element \( \overline{H}_{ij}^{ab} \) is

<p>&nbsp;<br>
$$
\begin{align*}
\overline{H}_{ij}^{ab} \leftarrow  \sum_{c} \left(f_c^a t_{ij}^{cb}-f_c^b t_{ij}^{ac}\right) - \sum_{k} \left(f_j^k t_{ik}^{ab}-f_i^k t_{jk}^{ab}\right)
\end{align*}
$$
<p>&nbsp;<br>

<p>
Here we used an arrow to indicate that this is just one contribution
to this matrix element.  We see that the derivation straight forward,
but somewhat tedious. As no one likes to commute too much (neither in
this example nor when going to and from work), and so we need a better
approach. This is where diagramms come in handy.

<h2><div id="___sec24"></div></h2>
</div>

<h3 id="___sec25">Diagrams  </h3>

The pictures in this Subsection are taken from Crawford and Schaefer.

<p>
By convention, hole lines (labels \( i, j, k,\ldots \)) are pointing down.

<p>
<center> <!-- figure label: --> <div id="fig-i"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  This is a hole line.  <!-- caption label: fig-i --> </p></center>
<p><img src="figslides/Diagram-i.png" align="bottom" height=120></p>
</center>

<p>
By convention, particle lines (labels \( a, b, c,\ldots \)) are pointing up.

<p>
<center> <!-- figure label: --> <div id="fig-a"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  This is a particle line.  <!-- caption label: fig-a --> </p></center>
<p><img src="figslides/Diagram-a.png" align="bottom" height=120></p>
</center>

<p>
Let us look at the one-body operator of the normal-ordered Hamiltonian, i.e. Fock matrix. Its diagrams are as follows.

<p>
<center> <!-- figure label: --> <div id="fig-fab"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 4:  The diagrams corresponding to \( f_a^b \). The dashed line with the 'X' denotes the interaction \( F \) between the incoming and outgoing lines. The labels \( a \) and \( b \) are not denoted, but you should label the outgoing and incoming lines accordingly.  <!-- caption label: fig-fab --> </p></center>
<p><img src="figslides/Diagram-fab.png" align="bottom" height=120></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fig-fij"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 5:  The diagrams corresponding to \( f_i^j \). The dashed line with the 'X' denotes the interaction \( F \) between the incoming and outgoing lines.  <!-- caption label: fig-fij --> </p></center>
<p><img src="figslides/Diagram-fij.png" align="bottom" height=120></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fig-fia"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 6:  The diagrams corresponding to \( f_a^i \). The dashed line with the 'X' denotes the interaction \( F \) between the incoming and outgoing lines.  <!-- caption label: fig-fia --> </p></center>
<p><img src="figslides/Diagram-fia.png" align="bottom" height=120></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fig-fai"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 7:  The diagrams corresponding to \( f_i^a \). The dashed line with the 'X' denotes the interaction \( F \) between the incoming and outgoing lines.  <!-- caption label: fig-fai --> </p></center>
<p><img src="figslides/Diagram-fai.png" align="bottom" height=120></p>
</center>

<p>
We now turn to the two-body interaction. It is denoted as a horizontal
dashed line with incoming and outgoing lines attached to it. We start
by noting that the following diagrams of the interaction are all
related by permutation symmetry.

<p>
<center> <!-- figure label: --> <div id="fig-symmetry"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 8:  The diagrams corresponding to \( \langle ai\vert V\vert jb \rangle = - \langle ai\vert V\vert bj \rangle = -\langle ia\vert V\vert jb \rangle = \langle ia\vert V\vert bj\rangle \).  <!-- caption label: fig-symmetry --> </p></center>
<p><img src="figslides/Diagrams-symmetry.png" align="bottom" width=400></p>
</center>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-10">Exercise 10: Assign the correct matrix element \( \langle pq\vert V\vert rs\rangle \) to each of the following diagrams of the interaction</h2>

<p>
Remember: \( \langle\rm{left-out, right-out}\vert V\vert \rm{left-in, right-in}\rangle \).

<p>
<b>a)</b>
<br /><br /><center><p><img src="figslides/Diagrams-V1.png" align="bottom" width=400></p></center><br /><br />

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
\( \langle ab\vert V\vert cd\rangle + \langle ij\vert V\vert kl\rangle + \langle ia\vert V\vert bj\rangle \)

<p>
<!-- --- end answer of exercise --- -->

<p>
<b>b)</b>
<br /><br /><center><p><img src="figslides/Diagrams-V2.png" align="bottom" width=400></p></center><br /><br />

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
\( \langle ai\vert V\vert bc\rangle + \langle ij\vert V\vert ka\rangle + \langle ab\vert V\vert ci\rangle \)

<p>
<!-- --- end answer of exercise --- -->

<p>
<b>c)</b>
<br /><br /><center><p><img src="figslides/Diagrams-V3.png" align="bottom" width=400></p></center><br /><br />

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
\( \langle ia\vert V\vert jk\rangle + \langle ab\vert V\vert ij\rangle + \langle ij\vert V\vert ab\rangle \)

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec27"></div></h2>
</div>

<p>
Finally, we have the following diagrams for the \( T_1 \) and \( T_2 \) amplitudes.

<p>
<center> <!-- figure label: --> <div id="fig-T"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  The horizontal full line is the cluster amplitude with incoming hole lines and outgoing particle lines as indicated.  <!-- caption label: fig-T --> </p></center>
<p><img src="figslides/Diagrams-T.png" align="bottom" width=400></p>
</center>

<p>
We are now in the position to construct the diagrams of the
similarity-transformed Hamiltonian, keeping in mind that these
diagrams correspond to matrix elements of \( \overline{H_N} \). The rules
are as follows.

<ol>
<p><li> Write down all <em>topologically different</em> diagrams corresponding to the desired matrix element. Topologically different diagrams differ in the number and type of lines (particle or hole) that connect the Fock matrix \( F \) or the interaction \( V \) to the cluster amplitudes \( T \), but not whether these connections are left or right (as those are related by antisymmetry). As an example, all diagrams in Fig. <a href="#fig-symmetry">8</a> are topologically identical, because they consist of incoming particle and hole lines and of outgoing particle and hole lines.</li> 
<p><li> Write down the matrix elements that enter the diagram, and sum over all internal lines.</li> 
<p><li> The overall sign is \( (-1) \) to the power of [(number of hole lines) &ndash; (number of loops)].</li>
<p><li> Symmetry factor: For each pair of equivalent lines (i.e. lines that connect the same two operators) multiply with a factor \( 1/2 \). For \( n \) identical vertices, multiply the algebraic expression by the symmery factor \( 1/n! \) to account properly for the number of ways the diagram can be constructed.</li>

<p><li> Antisymmetrize the outgoing and incoming lines as necessary.</li>
</ol>
<p>

Please note that this really works. You could derive these rules for
yourself from the commutations and factors that enter the
Baker-Campbell-Hausdorff expansion. The sign comes obviously from the
arrangement of creation and annilhilation operators, while the
symmetry factor stems from all the different ways, one can contract
the cluster operator with the normal-ordered Hamiltonian.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>

<h2 id="ex-11">Example: CCSD correlation energy</h2>
The CCSD correlation energy, \( E_c= \langle
\Phi_0\vert \overline{H_N}\vert \Phi_0\rangle \), is the first of the CCSD
equations <a href="#mjx-eqn-20">(20)</a>. It is a vacuum expectation value and thus
consists of all diagrams with no external legs. There are three such diagrams:

<p>
<center> <!-- figure label: --> <div id="fig-E0"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Three diagrams enter for the CCSD correlation energy, i.e. all diagrams that leave no external legs.  <!-- caption label: fig-E0 --> </p></center>
<p><img src="figslides/Diagrams-E0.png" align="bottom" width=400></p>
</center>

<p>
The correponding algebraic expression is \( E_c=\sum_{ia}f^i_a t_i^a +{1\over 4}\sum_{ijab} \langle ij\vert V\vert ab\rangle t_{ij}^{ab} + {1\over 2} \sum_{ijab} \langle ij\vert V\vert ab\rangle t_i^a t_j^b \).

<p>
The first algebraic expression is clear. We have one hole line and one
loop, giving it a positive sign. There are no equivalent lines or
vertices, giving it no symmetry factor. The second diagram has two
loops and two hole lines, again leading to a positive sign. We have a
pair of equivalent hole lines and a pair of equivalent particle lines,
each giving a symmetry factor of \( 1/2 \). The third diagram has two
loops and two hole lines, again leading to a positive sign. We have
two indentical vertices (each connecting to a \( T_1 \) in the same way)
and thus a symmetry factor \( 1/2 \).

<h2><div id="___sec29"></div></h2>
</div>

<h1 id="___sec30">CCD Approximation </h1>

<p>
In what follows, we will consider the coupled cluster doubles (CCD)
approximation. This approximation is valid in cases where the system
cannot exhibit any particle-hole excitations (such as nuclear matter
when formulated on a momentum-space grid) or for the pairing model (as
the pairing interactions only excites pairs of particles). In this
case \( t_i^a=0 \) for all \( i, a \), and \( \overline{H}_i^a=0 \). The CCD
approximation is also of some sort of leading order approximation in
the Hartree-Fock basis (as the Hartree-Fock Hamiltonian exhibits no
particle-hole excitations).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-12">Exercise 11: Derive the CCD equations!</h2>

<p>
Let us consider the matrix element \( \overline{H}_{ij}^{ab} \). Clearly,
it consists of all diagrams (i.e. all combinations of \( T_2 \), and a
single \( F \) or \( V \) that have two incoming hole lines and two outgoing
particle lines. Write down all these diagrams.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Start systematically! Consider all combinations of \( F \) and \( V \) diagrams with 0, 1, and 2 cluster amplitudes \( T_2 \).

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>

<p>
<center> <!-- figure label: --> <div id="fig-ccd"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 11:  The diagrams for the \( T_2 \) equation, i.e. the matrix elements of \( \overline{H}_{ij}^{ab} \). Taken from Baardsen et al (2013).  <!-- caption label: fig-ccd --> </p></center>
<p><img src="figslides/Diagrams-CCD.png" align="bottom" width=400></p>
</center>

<p>
The corresponding algebraic expression is
<p>&nbsp;<br>
$$
\begin{align*}
\overline{H}_{ij}^{ab} &= \langle ab\vert V\vert ij\rangle + P(ab)\sum_c f_c^bt_{ij}^{ac} - P(ij)\sum_k f_j^k t_{ik}^{ab} \\
&+ {1\over 2} \sum_{cd} \langle ab\vert V\vert cd\rangle t_{ij}^{cd}+ {1\over 2} \sum_{kl} \langle kl\vert V\vert ij\rangle t_{kl}^{ab} + P(ab)P(ij)\sum_{kc} \langle kb\vert V\vert cj \rangle t_{ik}^{ac} \\
&+ {1\over 2} P(ij)P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}t_{lj}^{db} 
+ {1\over 2} P(ij)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}t_{lj}^{ab}\\
&+ {1\over 2} P(ab)\sum_{kcld} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}t_{ij}^{db}
+ {1\over 4} \sum_{kcld} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}t_{kl}^{ab} . 
\end{align*}
$$
<p>&nbsp;<br>

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec32"></div></h2>
</div>

<p>
Let us now turn to the computational cost of a CCD computation.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-13">Exercise 12: Computational scaling of CCD</h2>

<p>
For each of the diagrams in Fig. <a href="#fig-ccd">11</a> write down the
computational cost in terms of the number of occupied \( A \) and the
number of unoccupied \( n_u \) orbitals.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
The cost is \( A^2 n_u^2 \), \( A^2 n_u^3 \), \( A^3 n_u^2 \),
\( A^2 n_u^4 \), \( A^4 n_u^2 \), \( A^3 n_u^3 \),
\( A^4 n_u^4 \), \( A^4 n_u^4 \),
\( A^4 n_u^4 \), and \( A^4 n_u^4 \) for the respective diagrams.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec34"></div></h2>
</div>

<p>
Note that \( n_u\gg A \) in general. In textbooks, one reads that CCD (and
CCSD) cost only \( A^2n_u^4 \). Our most expensive diagrams, however are
\( A^4n_u^4 \). What is going on?

<p>
To understand this puzzle, let us consider the last diagram of
Fig. <a href="#fig-ccd">11</a>. We break up the computation into two steps,
computing first the intermediate
<p>&nbsp;<br>
$$
\begin{align}
\chi_{ij}^{kl}\equiv {1\over 2} \sum_{cd} \langle kl\vert V\vert cd\rangle t_{ij}^{cd}
\tag{28}
\end{align}
$$
<p>&nbsp;<br>

at a cost of \( A^4n_u^2 \), and then 
<p>&nbsp;<br>
$$
\begin{align}
{1\over 2} \sum_{kl} \chi_{ij}^{kl} t_{kl}^{ab}  
\tag{29}
\end{align}
$$
<p>&nbsp;<br>

at a cost of \( A^4n_u^2 \). This is affordable. The price to pay is the
storage of the intermediate \( \chi_{ij}^{kl} \), i.e. we traded
memory for computational cycles. This trick is known as
&quot;factorization.&quot;

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-14">Exercise 13: Factorize the remaining diagrams of the CCD equation</h2>

<p>
Diagrams 7, 8, and 9 of Fig. <a href="#fig-ccd">11</a> also need to be factorized.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
For diagram number 7, we compute
<p>&nbsp;<br>
$$
\begin{align}
\chi_{id}^{al}\equiv\sum_{kc} \langle kl\vert V\vert cd\rangle t_{ik}^{ac}
\tag{30}
\end{align}
$$
<p>&nbsp;<br>

at a cost of \( A^3 n_u^3 \) and then compute
<p>&nbsp;<br>
$$
\begin{align}
{1\over 2} P(ij)P(ab) \sum_{ld} \chi_{id}^{al} t_{lj}^{db} 
\tag{31}
\end{align}
$$
<p>&nbsp;<br>

at the cost of \( A^3 n_u^3 \).

<p>
For diagram number 8, we compute
<p>&nbsp;<br>
$$
\begin{align}
\chi_{i}^{l}\equiv -{1\over 2} \sum_{kcd} \langle kl\vert V\vert cd\rangle t_{ik}^{cd}
\tag{32}
\end{align}
$$
<p>&nbsp;<br>

at a cost of \( A^3 n_u^2 \), and then compute
<p>&nbsp;<br>
$$
\begin{align}
-P(ij) \sum_l \chi_i^l t_{lj}^{ab}
\tag{33}
\end{align}
$$
<p>&nbsp;<br>

at the cost of \( A^3 n_u^2 \).

<p>
For diagram number 9, we compute
<p>&nbsp;<br>
$$
\begin{align}
\chi_d^a\equiv{1\over 2} \sum_{kcl} \langle kl\vert V\vert cd\rangle t_{kl}^{ac}
\tag{34}
\end{align}
$$
<p>&nbsp;<br>

at a cost of \( A^2 n_u^3 \) and then compute
<p>&nbsp;<br>
$$
\begin{align}
P(ab)\sum_d \chi_d^a t_{ij}^{db}
\tag{35}
\end{align}
$$
<p>&nbsp;<br>

at the cost of \( A^3 n_u^3 \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec36"></div></h2>
</div>

<p>
We are now ready, to derive the full CCSD equations, i.e. the matrix
elements of \( \overline{H}_i^a \) and \( \overline{H}_{ij}^{ab} \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-15">Project 14: (Optional) Derive the CCSD equations!</h2>

<p>
<b>a)</b>
Let us consider the matrix element \( \overline{H}_i^a \) first. Clearly, it consists of all diagrams (i.e. all combinations of \( T_1 \), \( T_2 \), and a single \( F \) or \( V \) that have an incoming hole line and an outgoing particle line. Write down all these diagrams.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>

<p>
<center> <!-- figure label: --> <div id="fig-CCSD1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 12:  The diagrams for the \( T_1 \) equation, i.e. the matrix elements of \( \overline{H}_i^a \). Taken from Crawford and Schaefer. Here \( \langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle \) and \( f_{pq}\equiv f^p_q \).  <!-- caption label: fig-CCSD1 --> </p></center>
<p><img src="figslides/Diagrams-CCSD1.png" align="bottom" width=800></p>
</center>

<p>
<!-- --- end answer of exercise --- -->

<p>
<b>b)</b>
Let us now consider the matrix element \( \overline{H}_{ij}^{ab} \). Clearly, it consists of all diagrams (i.e. all combinations of \( T_1 \), \( T_2 \), and a single \( F \) or \( V \) that have two incoming hole lines and two outgoing particle lines. Write down all these diagrams and corresponding algebraic expressions.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>

<p>
<center> <!-- figure label: --> <div id="fig-CCSD2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  The diagrams for the \( T_2 \) equation, i.e. the matrix elements of \( \overline{H}_{ij}^{ab} \). Taken from Crawford and Schaefer. Here \( \langle pq\vert \vert rs\rangle \equiv \langle pq\vert V\vert rs\rangle \), \( f_{pq}\equiv f^p_q \), and \( P(ab) = 1 - (a\leftrightarrow b) \) antisymmetrizes.  <!-- caption label: fig-CCSD2 --> </p></center>
<p><img src="figslides/Diagrams-CCSD2.png" align="bottom" width=800></p>
</center>

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec38"></div></h2>
</div>

<p>
We can now turn to the solution of the coupled-cluster equations.

<h2 id="___sec39">Solving the CCD equations </h2>

<p>
The CCD equations, depicted in Fig. <a href="#fig-ccd">11</a>, are nonlinear in the
cluster amplitudes. How do we solve \( \overline{H}_{ij}^{ab}=0 \)? We
subtract \( (f_a^a +f_b^b -f_i^i -f_j^j)t_{ij}^{ab} \) from both sides of
\( \overline{H}_{ij}^{ab}=0 \) (because this term is contained in
\( \overline{H}_{ij}^{ab} \)) and find

<p>&nbsp;<br>
$$
\begin{align*}
(f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} &= (f_i^i +f_j^j -f_a^a -f_b^b)t_{ij}^{ab} +\overline{H}_{ij}^{ab}
\end{align*}
$$
<p>&nbsp;<br>

<p>
Dividing by \( (f_i^i +f_j^j -f_a^a -f_b^b) \) yields
<p>&nbsp;<br>
$$
\begin{align}
t_{ij}^{ab} &= t_{ij}^{ab} + \frac{\overline{H}_{ij}^{ab}}{f_i^i +f_j^j -f_a^a -f_b^b}
\tag{36}
\end{align}
$$
<p>&nbsp;<br>

<p>
This equation is of the type \( t=f(t) \), and we solve it by iteration,
i.e. we start with a guess \( t_0 \) and iterate \( t_{n+1}=f(t_n) \), and
hope that this will converge to a solution. We take the perturbative result
<p>&nbsp;<br>
$$
\begin{align}
\tag{37}
\left(t_{ij}^{ab}\right)_0 = \frac{\langle ab\vert V\vert ij\rangle}{f_i^i +f_j^j -f_a^a -f_b^b}
\end{align}
$$
<p>&nbsp;<br>

<p>
as a starting point, compute \( \overline{H}_{ij}^{ab} \), and find a new
\( t_{ij}^{ab} \) from the right-hand side of Eq. <a href="#mjx-eqn-36">(36)</a>. We repeat
this process until the amplitudes (or the CCD energy) converge.

<h1 id="___sec40">CCD for the pairing Hamiltonian </h1>

<p>
You learned about the pairing Hamiltonian earlier in this
school. Convince yourself that this Hamiltonian does not induce any
1p-1h excitations. Let us solve the CCD equations for this
problem. This consists of the following steps

<ol>
<p><li> Write a function that compute the potential, i.e. it returns a four-indexed array (or tensor). We need \( \langle ab\vert V\vert cd\rangle \), \( \langle ij\vert V\vert kl\rangle \), and \( \langle ab\vert V\vert ij\rangle \). Why is there no \( \langle ab\vert V\vert id\rangle \) or \( \langle ai\vert V\vert jb\rangle \) ?</li>
<p><li> Write a function that computes the Fock matrix, i.e. a two-indexed array. We only need \( f_a^b \) and \( f_i^j \). Why?</li> 
<p><li> Initialize the cluster amplitudes according to Eq. <a href="#mjx-eqn-37">(37)</a>, and solve Eq. <a href="#mjx-eqn-36">(36)</a> by iteration. The cluster amplitudes \( T_1 \) and \( T_2 \) are two- and four-indexed arrays, respectively.</li>
</ol>
<p>

Please note that the contraction of tensors (i.e. the summation over
common indices in products of tensors) is very user friendly and
elegant in python when <code>numpy.einsum</code> is used.

<p>
<!-- --- begin exercise --- -->

<h2 id="ex-16">Project 15: Solve the CCD equations for the pairing problem</h2>

<p>
The Hamiltonian is
<p>&nbsp;<br>
$$
\begin{align}
H = \delta \sum_{p=1}^\Omega (p-1)\left(a^\dagger_{p+}a_{p+} + a^\dagger_{p-}a_{p-}\right)
-{g \over 2} \sum_{p, q=1}^\Omega a^\dagger_{p+}a^\dagger_{p-} a_{q-} a_{q+} .
\tag{38}
\end{align}
$$
<p>&nbsp;<br>

<p>
Check your results and reproduce Fig 8.5 and Table 8.12 from Lecture Notes in Physics 936.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
<a href="https://github.com/NuclearTalent/ManyBody2018/tree/master/doc/Programs/Python/PairingModel" target="_blank">Click for IPython notebook for FCI and CCD solutions</a>

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22">## Coupled clusters in CCD approximation</span>
<span style="color: #228B22">## Implemented for the pairing model of Lecture Notes in Physics 936, Chapter 8.</span>
<span style="color: #228B22">## Thomas Papenbrock, June 2018</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_pairing_v</span>(g,pnum,hnum):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    returns potential matrices of the pairing model in three relevant channels</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param g: strength of the pairing interaction, as in Eq. (8.42)</span>
<span style="color: #CD5555">    param pnum: number of particle states</span>
<span style="color: #CD5555">    param hnum: number of hole states</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return v_pppp, v_pphh, v_hhhh: np.array(pnum,pnum,pnum,pnum), </span>
<span style="color: #CD5555">                                   np.array(pnum,pnum,hnum,hnum), </span>
<span style="color: #CD5555">                                   np.array(hnum,hnum,hnum,hnum), </span>
<span style="color: #CD5555">                                   The interaction as a 4-indexed tensor in three channels.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    v_pppp=np.zeros((pnum,pnum,pnum,pnum))
    v_pphh=np.zeros((pnum,pnum,hnum,hnum))
    v_hhhh=np.zeros((hnum,hnum,hnum,hnum))
    
    gval=-<span style="color: #B452CD">0.5</span>*g
    <span style="color: #8B008B; font-weight: bold">for</span> a <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,pnum,<span style="color: #B452CD">2</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> b <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,pnum,<span style="color: #B452CD">2</span>):
            v_pppp[a,a+<span style="color: #B452CD">1</span>,b,b+<span style="color: #B452CD">1</span>]=gval
            v_pppp[a+<span style="color: #B452CD">1</span>,a,b,b+<span style="color: #B452CD">1</span>]=-gval
            v_pppp[a,a+<span style="color: #B452CD">1</span>,b+<span style="color: #B452CD">1</span>,b]=-gval
            v_pppp[a+<span style="color: #B452CD">1</span>,a,b+<span style="color: #B452CD">1</span>,b]=gval
            
    <span style="color: #8B008B; font-weight: bold">for</span> a <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,pnum,<span style="color: #B452CD">2</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,hnum,<span style="color: #B452CD">2</span>):
            v_pphh[a,a+<span style="color: #B452CD">1</span>,i,i+<span style="color: #B452CD">1</span>]=gval
            v_pphh[a+<span style="color: #B452CD">1</span>,a,i,i+<span style="color: #B452CD">1</span>]=-gval
            v_pphh[a,a+<span style="color: #B452CD">1</span>,i+<span style="color: #B452CD">1</span>,i]=-gval
            v_pphh[a+<span style="color: #B452CD">1</span>,a,i+<span style="color: #B452CD">1</span>,i]=gval
    
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,hnum,<span style="color: #B452CD">2</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,hnum,<span style="color: #B452CD">2</span>):
            v_hhhh[j,j+<span style="color: #B452CD">1</span>,i,i+<span style="color: #B452CD">1</span>]=gval
            v_hhhh[j+<span style="color: #B452CD">1</span>,j,i,i+<span style="color: #B452CD">1</span>]=-gval
            v_hhhh[j,j+<span style="color: #B452CD">1</span>,i+<span style="color: #B452CD">1</span>,i]=-gval
            v_hhhh[j+<span style="color: #B452CD">1</span>,j,i+<span style="color: #B452CD">1</span>,i]=gval
        
    <span style="color: #8B008B; font-weight: bold">return</span> v_pppp, v_pphh, v_hhhh
    
    
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_pairing_fock</span>(delta,g,pnum,hnum):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    initializes the Fock matrix of the pairing model</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param delta: Single-particle spacing, as in Eq. (8.41)</span>
<span style="color: #CD5555">    param g: pairing strength, as in eq. (8.42)</span>
<span style="color: #CD5555">    param pnum: number of particle states</span>
<span style="color: #CD5555">    param hnum: number of hole states</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return f_pp, f_hh: The Fock matrix in two channels as numpy arrays np.array(pnum,pnum), np.array(hnum,hnum). </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
<span style="color: #228B22"># the Fock matrix for the pairing model. No f_ph needed, because we are in Hartree-Fock basis </span>
    deltaval=<span style="color: #B452CD">0.5</span>*delta
    gval=-<span style="color: #B452CD">0.5</span>*g
    f_pp = np.zeros((pnum,pnum))
    f_hh = np.zeros((hnum,hnum))

    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,hnum,<span style="color: #B452CD">2</span>):
        f_hh[i  ,i  ] = deltaval*i+gval
        f_hh[i+<span style="color: #B452CD">1</span>,i+<span style="color: #B452CD">1</span>] = deltaval*i+gval
        
    <span style="color: #8B008B; font-weight: bold">for</span> a <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,pnum,<span style="color: #B452CD">2</span>):
        f_pp[a  ,a  ] = deltaval*(hnum+a)
        f_pp[a+<span style="color: #B452CD">1</span>,a+<span style="color: #B452CD">1</span>] = deltaval*(hnum+a)
    
    <span style="color: #8B008B; font-weight: bold">return</span> f_pp, f_hh


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_t2</span>(v_pphh,f_pp,f_hh):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Initializes t2 amlitudes as in MBPT2, see first equation on page 345</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param v_pphh: pairing tensor in pphh channel</span>
<span style="color: #CD5555">    param f_pp:   Fock matrix in pp channel</span>
<span style="color: #CD5555">    param f_hh:   Fock matrix in hh channel</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return t2: numpy array in pphh format, 4-indices tensor</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    pnum = <span style="color: #658b00">len</span>(f_pp)
    hnum = <span style="color: #658b00">len</span>(f_hh)
    t2_new = np.zeros((pnum,pnum,hnum,hnum))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(hnum):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(hnum):
            <span style="color: #8B008B; font-weight: bold">for</span> a <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(pnum):
                <span style="color: #8B008B; font-weight: bold">for</span> b <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(pnum):
                    t2_new[a,b,i,j] = v_pphh[a,b,i,j] / (f_hh[i,i]+f_hh[j,j]-f_pp[a,a]-f_pp[b,b])
    <span style="color: #8B008B; font-weight: bold">return</span> t2_new


<span style="color: #228B22"># CCD equations. Note that the &quot;-&gt;abij&quot; assignment is redundant, because indices are ordered alphabetically.</span>
<span style="color: #228B22"># Nevertheless, we retain it for transparency.</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ccd_iter</span>(v_pppp,v_pphh,v_hhhh,f_pp,f_hh,t2):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Performs one iteration of the CCD equations (8.34), using also intermediates for the nonliniar terms</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param v_pppp: pppp-channel pairing tensor, numpy array</span>
<span style="color: #CD5555">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span style="color: #CD5555">    param v_hhhh: hhhh-channel pairing tensor, numpy array</span>
<span style="color: #CD5555">    param f_pp: Fock matrix in pp channel</span>
<span style="color: #CD5555">    param f_hh: Fock matrix in hh channel</span>
<span style="color: #CD5555">    param t2: Initial t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return t2_new: new t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    pnum = <span style="color: #658b00">len</span>(f_pp)
    hnum = <span style="color: #658b00">len</span>(f_hh)
    Hbar_pphh = (  v_pphh 
                 + np.einsum(<span style="color: #CD5555">&#39;bc,acij-&gt;abij&#39;</span>,f_pp,t2) 
                 - np.einsum(<span style="color: #CD5555">&#39;ac,bcij-&gt;abij&#39;</span>,f_pp,t2) 
                 - np.einsum(<span style="color: #CD5555">&#39;abik,kj-&gt;abij&#39;</span>,t2,f_hh)
                 + np.einsum(<span style="color: #CD5555">&#39;abjk,ki-&gt;abij&#39;</span>,t2,f_hh)
                 + <span style="color: #B452CD">0.5</span>*np.einsum(<span style="color: #CD5555">&#39;abcd,cdij-&gt;abij&#39;</span>,v_pppp,t2) 
                 + <span style="color: #B452CD">0.5</span>*np.einsum(<span style="color: #CD5555">&#39;abkl,klij-&gt;abij&#39;</span>,t2,v_hhhh)
                )

    <span style="color: #228B22"># hh intermediate, see (8.47)</span>
    chi_hh = <span style="color: #B452CD">0.5</span>* np.einsum(<span style="color: #CD5555">&#39;cdkl,cdjl-&gt;kj&#39;</span>,v_pphh,t2)

    Hbar_pphh = Hbar_pphh - (  np.einsum(<span style="color: #CD5555">&#39;abik,kj-&gt;abij&#39;</span>,t2,chi_hh) 
                             - np.einsum(<span style="color: #CD5555">&#39;abik,kj-&gt;abji&#39;</span>,t2,chi_hh) )

    <span style="color: #228B22"># pp intermediate, see (8.46)</span>
    chi_pp = -<span style="color: #B452CD">0.5</span>* np.einsum(<span style="color: #CD5555">&#39;cdkl,bdkl-&gt;cb&#39;</span>,v_pphh,t2)

    Hbar_pphh = Hbar_pphh + (  np.einsum(<span style="color: #CD5555">&#39;acij,cb-&gt;abij&#39;</span>,t2,chi_pp) 
                             - np.einsum(<span style="color: #CD5555">&#39;acij,cb-&gt;baij&#39;</span>,t2,chi_pp) )

    <span style="color: #228B22"># hhhh intermediate, see (8.48)</span>
    chi_hhhh = <span style="color: #B452CD">0.5</span> * np.einsum(<span style="color: #CD5555">&#39;cdkl,cdij-&gt;klij&#39;</span>,v_pphh,t2)

    Hbar_pphh = Hbar_pphh + <span style="color: #B452CD">0.5</span> * np.einsum(<span style="color: #CD5555">&#39;abkl,klij-&gt;abij&#39;</span>,t2,chi_hhhh)

    <span style="color: #228B22"># phph intermediate, see (8.49)</span>
    chi_phph= + <span style="color: #B452CD">0.5</span> * np.einsum(<span style="color: #CD5555">&#39;cdkl,dblj-&gt;bkcj&#39;</span>,v_pphh,t2)


    Hbar_pphh = Hbar_pphh + (  np.einsum(<span style="color: #CD5555">&#39;bkcj,acik-&gt;abij&#39;</span>,chi_phph,t2)
                             - np.einsum(<span style="color: #CD5555">&#39;bkcj,acik-&gt;baij&#39;</span>,chi_phph,t2)
                             - np.einsum(<span style="color: #CD5555">&#39;bkcj,acik-&gt;abji&#39;</span>,chi_phph,t2)
                             + np.einsum(<span style="color: #CD5555">&#39;bkcj,acik-&gt;baji&#39;</span>,chi_phph,t2) )
                 
    t2_new=np.zeros((pnum,pnum,hnum,hnum))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(hnum):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(hnum):
            <span style="color: #8B008B; font-weight: bold">for</span> a <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(pnum):
                <span style="color: #8B008B; font-weight: bold">for</span> b <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(pnum):
                    t2_new[a,b,i,j] = (  t2[a,b,i,j] 
                                       + Hbar_pphh[a,b,i,j] / (f_hh[i,i]+f_hh[j,j]-f_pp[a,a]-f_pp[b,b]) )

    <span style="color: #8B008B; font-weight: bold">return</span> t2_new


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ccd_energy</span>(v_pphh,t2):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Computes CCD energy. Call as </span>
<span style="color: #CD5555">    energy = ccd_energy(v_pphh,t2)</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param v_pphh: pphh-channel pairing tensor, numpy array</span>
<span style="color: #CD5555">    param t2: t2 amplitude, tensor in form of pphh channel</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return energy: CCD correlation energy</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    erg = <span style="color: #B452CD">0.25</span>*np.einsum(<span style="color: #CD5555">&#39;abij,abij&#39;</span>,v_pphh,t2)
    <span style="color: #8B008B; font-weight: bold">return</span> erg

<span style="color: #228B22">###############################</span>
<span style="color: #228B22">######## Main Program</span>

<span style="color: #228B22"># set parameters as for model</span>
pnum = <span style="color: #B452CD">20</span> <span style="color: #228B22"># number of particle states</span>
hnum = <span style="color: #B452CD">10</span> <span style="color: #228B22"># number of hole states</span>
delta = <span style="color: #B452CD">1.0</span>

g = <span style="color: #B452CD">0.5</span>

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;parameters&quot;</span>)
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;delta =&quot;</span>, delta, <span style="color: #CD5555">&quot;, g =&quot;</span>, g)


<span style="color: #228B22"># Initialize pairing matrix elements and Fock matrix</span>
v_pppp, v_pphh, v_hhhh = init_pairing_v(g,pnum,hnum)
f_pp, f_hh = init_pairing_fock(delta,g,pnum,hnum)

<span style="color: #228B22"># Initialize T2 amplitudes from MBPT2</span>
t2 = init_t2(v_pphh,f_pp,f_hh)
erg = ccd_energy(v_pphh,t2)

<span style="color: #228B22"># Exact MBPT2 for comparison, see last equation on page 365 </span>
exact_mbpt2 = -<span style="color: #B452CD">0.25</span>*g**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1.0</span>/(<span style="color: #B452CD">2.0</span>+g) + <span style="color: #B452CD">2.0</span>/(<span style="color: #B452CD">4.0</span>+g) + <span style="color: #B452CD">1.0</span>/(<span style="color: #B452CD">6.0</span>+g))
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;MBPT2 energy =&quot;</span>, erg, <span style="color: #CD5555">&quot;, compared to exact:&quot;</span>, exact_mbpt2)
    
    
<span style="color: #228B22"># iterate CCD equations niter times</span>
niter=<span style="color: #B452CD">200</span>
mix=<span style="color: #B452CD">0.3</span>
erg_old=<span style="color: #B452CD">0.0</span>
eps=<span style="color: #B452CD">1.e-8</span>
<span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">iter</span> <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(niter):
    t2_new = ccd_iter(v_pppp,v_pphh,v_hhhh,f_pp,f_hh,t2)
    erg = ccd_energy(v_pphh,t2_new)
    myeps = <span style="color: #658b00">abs</span>(erg-erg_old)/<span style="color: #658b00">abs</span>(erg)
    <span style="color: #8B008B; font-weight: bold">if</span> myeps &lt; eps: <span style="color: #8B008B; font-weight: bold">break</span>
    erg_old=erg
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;iter=&quot;</span>, <span style="color: #658b00">iter</span>, <span style="color: #CD5555">&quot;erg=&quot;</span>, erg, <span style="color: #CD5555">&quot;myeps=&quot;</span>, myeps)
    t2 = mix*t2_new + (<span style="color: #B452CD">1.0</span>-mix)*t2 
    
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Energy = &quot;</span>, erg)
</pre></div>
<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>

<center><h1 id="___sec42">Nucleonic Matter </h1></center> <hr>

<p>
We want to compute nucleonic matter using coupled cluster or IMSRG
methods, and start with considering the relevant symmetries.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-17">Exercise 16: Which symmetries are relevant for nuclear matter?</h2>

<p>
<b>a)</b>
Enumerate continuous and discrete symmetries of nuclear matter.

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
The symmetries are the same as for nuclei.  Continuous symmetries:
translational and rotational invariance. Discrete symmetries: Parity
and time reversal invariance.

<p>
<!-- --- end answer of exercise --- -->

<p>
<b>b)</b>
What basis should we use to implement these symmetries? Why do we have to make a choice between the two continuous symmetries? Which basis is most convenient and why?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
Angular momentum and momentum do not commute. Thus, there is no basis
that respects both symmetries simultaneously. If we choose the
spherical basis, we are computing a spherical blob of nuclear matter
and have to contend with surface effects, i.e. with finite size
effects. We also need a partial-wave decomposition of the nuclear
interaction. This approach has been done followed in
[&quot;Coupled-cluster studies of infinite nuclear matter, &quot; G. Baardsen,
A. Ekstr&#246;m, G. Hagen, M. Hjorth-Jensen, arXiv:1306.5681, Phys. Rev. C
88, 054312 (2013)]. If we choose a basis of discrete momentum states,
translational invariance can be respected. This also facilitates the
implementetation of modern nuclear interactions (which are often
formulated in momentum space in effective field theories). However, we
have to think about the finite size effects imposed by periodic
boundary conditions (or generalized Bloch waves). This approch was
implemented in [&quot;Coupled-cluster calculations of nucleonic matter,&quot;
G. Hagen, T. Papenbrock, A. Ekstr&#246;m, K. A. Wendt, G. Baardsen,
S. Gandolfi, M. Hjorth-Jensen, C. J. Horowitz, arXiv:1311.2925,
Phys. Rev. C 89, 014319 (2014)].

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec44"></div></h2>
</div>

<h1 id="___sec45">Basis states </h1>

<p>
In what follows, we employ a basis made from discrete momentum states,
i.e. those states \( \vert k_x, k_y, k_z\rangle \) in a cubic box of size \( L \) that
exhibit periodic boundary conditions, i.e. \( \psi_k(x+L) =\psi_k(x) \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-18">Exercise 17: Determine the basis states</h2>

<p>
What are the discrete values of momenta admissable in \( (k_x, k_y, k_z) \)?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
In 1D position space \( \psi_k(x) \propto e^{i k x} \) with \( k =
{2\pi n\over L} \) and \( n=0, \pm 1, \pm 2, \ldots \) fulfill \( \psi_k(x+L)
= \psi_k(x) \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec47"></div></h2>
</div>

<p>
Thus, we use a cubic lattice in momentum space.  Note that the
momentum states \( e^{i k x} \) are not invariant under time reversal
(i.e. under \( k\to -k \)), and also do not exhibit good parity (\( x\to
-x \)). The former implies that the Hamiltonian matrix will in general
be complex Hermitian and that the cluster amplitudes will in general
be complex.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-19">Exercise 18: How large should the basis be?</h2>

<p>
What values should be chosen for the box size \( L \) and for the maximum number \( n_{\rm max} \) , i.e.
for the discrete momenta \( k = {2\pi n\over L} \) and \( n=0, \pm 1,\
 \pm 2, \ldots, \pm n_{\rm max} \)?

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
Usually \( n_{\rm max} \) is fixed by computational cost, because we have
\( (2n_{\rm max}+1)^3 \) basis states. We have used \( n_{\rm max}=4 \) or up
to \( n_{\rm max}=6 \) in actual calculations to get converged results.

<p>
The maximum momentum must fulfill \( k_{n_{\rm max}}> \Lambda \), where
\( \Lambda \) is the momemtum cutoff of the interaction. This then fixes
\( L \) for a given \( n_{\rm max} \).

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec49"></div></h2>
</div>

<p>
Coupled cluster and IMSRG start from a Hartree-Fock reference state,
and we need to think about this next. What are the magic numbers of a
cubic lattice for neutron matter?

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-20">Exercise 19: Determine the lowest few magic numbers for a cubic lattice.</h2>

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
As the spin-degeneracy is \( g_s=2 \), we have the magic numbers \( g_s N \)
with \( N=1, 7, 19, 27, 33, 57, 66, \ldots \) for neutrons.

<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec51"></div></h2>
</div>

<p>
Given \( n_{\rm max} \) and \( L \) for the basis parameters, we can choose a
magic neutron number \( N \). Clearly, the density of the system is then
\( \rho=N/L^3 \). This summarizes the requirements for the basis. We
choose \( n_{\rm max} \) as large as possible, i.e. as large as
computationally feasible. Then \( L \) and \( N \) are constrained by the UV
cutoff and density of the system.

<h2 id="___sec52">Finite size effects </h2>
We could also have considered the case of a more generalized boundary
condition, i.e.  \( \psi_k(x+L) =e^{i\theta}\psi_k(x) \).  Admissable
momenta that fulfill such a boundary condition are \( k_n(\theta) = {2\pi n
+\theta \over L} \). Avering over the &quot;twist&quot; angle \( \theta \) removes
finite size effects, because the discrete momenta are really drawn
form a continuum.  In three dimensions, there are three possible twist
angles, and averaging over twist angles implies summing over many
results corresponding to different angles. Thus, the removal of
finite-size effects significantly increases the numerical expense.
An example
is shown in Figure <a href="#fig-finite">14</a>, where we compute the kinetic
energy per particle

<p>&nbsp;<br>
$$
\begin{align}
T_N(\theta_x,\theta_y,\theta_z)=g_s\sum_{n_x, n_y, n_z \in N} {\hbar^2 \left( k_{n_x}^2(\theta_x) +k_{n_y}^2(\theta_y) +k_{n_z}^2(\theta_z)\right)\over 2m}
\tag{39}
\end{align}
$$
<p>&nbsp;<br>

<p>
and compare with the infinite result \( T_{\rm inf} = {3\over 10} 
{\hbar^2 k_F^2\over m} N \) valid for the free Fermi gas. We clearly see
strong shell effects (blue dashed line) and that averaging over the twist angles
(red full line) very much reduces the shell oscillations. We also note that
the neutron number 66 is quite attractive as it exhibits smaller
finite size effects than other of the accessible magic numbers.

<p>
<center> <!-- figure label: --> <div id="fig-finite"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 14:  Relative finite-size corrections for the kinetic energy in pure neutron matter at the Fermi momentum \( k_F = 1.6795 {\rm fm}^{-1} \) versus the neutron number A. TABC10 are twist-averaged boundary conditions with 10 Gauss-Legendre points in each spatial direction.  <!-- caption label: fig-finite --> </p></center>
<p><img src="figslides/fig-finite.png" align="bottom" width=600></p>
</center>

<h1 id="___sec53">Channel structure of Hamiltonian and cluster amplitudes </h1>

<p>
Good quantum numbers for the nuclear interaction (i.e. operators that
commute with the Hamiltonian and with each other) are total momentum,
and the number of neutrons and protons, and &ndash; for simple interactions
&ndash; also the spin (this is really spin, not orbital anular momentum or
total angular momentum, as the latter two do not commute with
momentum). Thus the Hamiltonian (and the cluster amplitudes) will
consist of blocks, one for each set of quantum numbers. We call the
set of quantum numbers that label each such block as a &quot;channel.&quot;
As the interaction is block diagonal, a numerically efficient
implementation of nuclear matter has to take advantage of this channel
structure. In fact, neutron matter cannot be computed in a numerically
converged way (i.e. for large enough \( n_{\rm max} \)) if one does not
exploit the channel structure.

<p>
The Hamiltonian is of the structure

<p>&nbsp;<br>
$$
\begin{align}
\tag{40}
H = \sum_{\vec{k}, \sigma} \varepsilon_{\vec{k}, \sigma}^{\vec{k}, \sigma} a^\dagger_{\vec{k}, \sigma}a_{\vec{k}, \sigma}
+ \sum_{\vec{Q},\vec{p},\vec{k},\sigma_s} V_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(\vec{p},\vec{k}) a^\dagger_{\vec{Q/2}+\vec{p}, \sigma_3}a^\dagger_{\vec{Q/2}-\vec{p}, \sigma_4} a_{\vec{Q/2}-\vec{k}, \sigma_2}a_{\vec{Q/2}+\vec{k}, \sigma_1}
\end{align}
$$
<p>&nbsp;<br>

<p>
with \( \varepsilon_{\vec{k}, \sigma}^{\vec{k}, \sigma} = {k^2\over
2m} \).  In Eq. <a href="#mjx-eqn-40">(40)</a> we expressed the single-particle momenta in
terms of center-of-mass momentum \( \vec{Q} \) and relative momenta
\( (\vec{k},\vec{p}) \), i.e. the incoming momenta \( (\vec{k}_1,
\vec{k}_2) \) and outgoing momenta \( (\vec{k}_3, \vec{k}_3) \) are

<p>&nbsp;<br>
$$
\begin{align}
\tag{41}
\vec{k}_1 &= \vec{Q}/2 +\vec{k} ,\\
\vec{k}_2 &= \vec{Q}/2 -\vec{k} ,
\tag{42}\\
\vec{k}_3 &= \vec{Q}/2 +\vec{p} ,
\tag{43}\\
\vec{k}_4 &= \vec{Q}/2 -\vec{p} .
\tag{44}
\end{align}
$$
<p>&nbsp;<br>

<p>
The conservation of momentum is obvious in the two-body interaction as
both the annihilation operators and the creation operators depend on
the same center-of-mass momentum \( \vec{Q} \). We note that the two-body
interaction \( V \) depends only on the relative momenta
\( (\vec{k},\vec{p}) \) but not on the center-of-mass momentum. We also
note that a local interaction (i.e. an interaction that is
multiplicative in position space) depends only on the momentum
transfer \( \vec{k}-\vec{p} \). The spin projections \( \pm 1/2 \) are denoted
as \( \sigma \).

<p>
Thus, the \( T_2 \) operator is
<p>&nbsp;<br>
$$
\begin{align}
\tag{45}
T_2 = {1\over 4} \sum_{\vec{Q},\vec{p},\vec{k},\sigma_s} t_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(Q; \vec{p},\vec{k}) a^\dagger_{\vec{Q/2}+\vec{p}, \sigma_3}a^\dagger_{\vec{Q/2}-\vec{p}, \sigma_4} a_{\vec{Q/2}-\vec{k}, \sigma_2}a_{\vec{Q/2}+\vec{k}, \sigma_1} . 
\end{align}
$$
<p>&nbsp;<br>

<p>
We note that the amplitude \( t_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(Q;
\vec{p},\vec{k}) \) depends on the center-of-mass momentum \( \vec{Q} \), in
contrast to the potential matrix element
\( V_{\sigma_1\sigma_2}^{\sigma_3\sigma_4}(\vec{p},\vec{k}) \).

<p>
In the expressions <a href="#mjx-eqn-40">(40)</a> and <a href="#mjx-eqn-45">(45)</a> we supressed that
\( \sigma_1+\sigma_2 = \sigma_3+\sigma_4 \). So, a channel is defined by
\( \vec{Q} \) and total spin projection \( \sigma_1+\sigma_2 \).

<p>
Because of this channel structure, the simple solution we implemented
for the pairing problem cannot be really re-used when computing
neutron matter.  Let us take a look at the Minnesota potential

<p>&nbsp;<br>
$$
\begin{align}
V(r) = \left( V_R(r)  + {1\over 2}(1+P_{12}^\sigma)V_T(r) + {1\over 2}(1-P_{12}^\sigma)V_S(r)\right) {1\over 2}(1-P_{12}^\sigma P_{12}^\tau). 
\tag{46}
\end{align}
$$
<p>&nbsp;<br>

<p>
Here,

<p>&nbsp;<br>
$$
\begin{align}
P^\sigma_{12}&= {1\over 2}(1+\vec{\sigma}_1\cdot\vec{\sigma}_2) , \nonumber\\
P^\tau_{12} &= {1\over 2}(1+\vec{\tau}_1\cdot\vec{\tau}_2) 
\tag{47}
\end{align}
$$
<p>&nbsp;<br>

<p>
are spin and isospin exchange operators, respectively, and
\( \vec{\sigma} \) and \( \vec{\tau} \) are vectors of Pauli matrices in spin
and isospin space, respectively. Thus,

<p>&nbsp;<br>
$$
\begin{align}
{1\over 2}(1-P_{12}^\sigma P_{12}^\tau) & = \vert
S_{12}=0, T_{12}=1\rangle\langle S_{12}=0,T_{12}=1\vert + \vert
S_{12}=1, T_{12}=0\rangle\langle S_{12}=1,T_{12}=0\vert
\tag{48}
\end{align}
$$
<p>&nbsp;<br>

projects onto two-particle spin-isospin states as indicated, while
<p>&nbsp;<br>
$$
\begin{align}
{1\over 2}(1-P_{12}^\sigma) & = \vert
S_{12}=0\rangle\langle S_{12}=0\vert , 
\tag{49}\\ {1\over 2}(1+P_{12}^\sigma)
& = \vert S_{12}=1\rangle\langle S_{12}=1\vert
\tag{50}
\end{align}
$$
<p>&nbsp;<br>

project onto spin singlet and spin triplet combinations,
respectively. For neutron matter, two-neutron states have isospin
\( T_{12}=1 \), and the Minnesota potential has no triplet term \( V_T \).
For the spin-exchange operator (and spins \( s_1, s_2=\pm 1/2 \)), we have
\( P_{12}^\sigma\vert s_1s_2\rangle= \vert s_2s_1\rangle \).  For neutron
matter, \( P_{12}^\tau=1 \), because the states are symmetric under exchange of
isospin. Thus, the Minnesota potential simplifies significantly for
neutron matter as \( V_T \) does not contribute.

<p>
We note that the spin operator has matrix elements
<p>&nbsp;<br>
$$
\begin{align}
\langle s_1' s_2'\vert {1\over 2}(1-P_{12}^{\sigma})\vert s_1 s_2\rangle
= {1\over 2} \left(
 \delta_{s_1}^{s_1'}\delta_{s_2}^{s_2'}
-\delta_{s_1}^{s_2'}\delta_{s_2}^{s_1'}\right) . 
\tag{51}
\end{align}
$$
<p>&nbsp;<br>

<p>
The radial functions are
<p>&nbsp;<br>
$$
\begin{align}
V_R(r) &=V_R e^{-\kappa_R r^2} , 
\tag{52}\\
V_S(r) &=V_S e^{-\kappa_S r^2} , 
\tag{53}\\
V_T(r) &=V_T e^{-\kappa_T r^2} , 
\tag{54}\\
\tag{55}
\end{align}
$$
<p>&nbsp;<br>

and the parameters are as follows

<p>
<table border="1">
<thead>
<tr><td align="center">\( \alpha \)</td> <td align="center">\( V_\alpha \)</td> <td align="center">\( \kappa_\alpha \) </td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( R \)         </td> <td align="right">   +200 MeV          </td> <td align="center">   1.487 fm \( ^{-2} \)    </td> </tr>
<tr><td align="center">   \( S \)         </td> <td align="right">   -91.85 MeV        </td> <td align="center">   0.465 fm \( ^{-2} \)    </td> </tr>
<tr><td align="center">   \( T \)         </td> <td align="right">   -178 MeV          </td> <td align="center">   0.639 fm \( ^{-2} \)    </td> </tr>
</tbody>
</table>
<p>
Note that \( \kappa_\alpha^{1/2} \) sets the momentum scale of the
Minnesota potential. We see that we deal with a short-ranged repulsive
core (the \( V_R \) term) and longer ranged attractive terms in the
singlet (the term \( V_S \)) and triplet (the term \( V_T \)) channels.

<p>
A Fourier transform (in the finite cube of length \( L \)) yields the momentum-space form of the potential
<p>&nbsp;<br>
$$
\begin{align}
\langle k_p k_q \vert V_\alpha\vert k_r k_s \rangle = {V_\alpha\over L^3} \left({\pi\over\kappa_\alpha}\right)^{3/2}
e^{- {q^2 \over 4\kappa_\alpha}} \delta_{k_p+k_q}^{k_r+k_s} . 
\tag{56}
\end{align}
$$
<p>&nbsp;<br>

Here, \( q\equiv {1\over 2}(k_p-k_q-k_r+k_s) \) is the momentum transfer,
and the momentum conservation \( k_p+k_q=k_r+k_s \) is explicit.

<p>
As we are dealing only with neutrons, the potential matrix elements
(including spin) are for \( \alpha = R, S \)
<p>&nbsp;<br>
$$
\begin{align}
\tag{57}
\langle	k_p s_p k_q s_q\vert V_\alpha\vert k_r s_r k_s s_s\rangle &= \langle	k_p k_q \vert V_\alpha\vert k_r k_s \rangle
{1\over 2}\left(\delta_{s_p}^{s_r}\delta_{s_q}^{s_s} - \delta_{s_p}^{s_s}\delta_{s_q}^{s_r}\right) , 
\end{align}
$$
<p>&nbsp;<br>

and it is understood that there is no contribution from \( V_T \). Please note that the matrix elements <a href="#mjx-eqn-57">(57)</a> are not yet antisymmetric under exchange, but \( \langle k_p s_p k_q s_q\vert V_\alpha\vert k_r s_r k_s s_s\rangle -
\langle k_p s_p k_q s_q\vert V_\alpha\vert k_s s_s k_r s_r\rangle \) is.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>

<h2 id="ex-21">Example: Channel structure and its usage</h2>

<p>
We have single-particle states with momentum and spin, namely

<p>&nbsp;<br>
$$
\begin{align}
\vert r\rangle \equiv \vert k_r s_r\rangle .
\tag{58}
\end{align}
$$
<p>&nbsp;<br>

<p>
Naively, two-body states are then
<p>&nbsp;<br>
$$
\begin{align}
\vert r s \rangle \equiv \vert k_r s_r k_s s_s\rangle ,
\tag{59}
\end{align}
$$
<p>&nbsp;<br>

but using the center-of-mass transformation <a href="#mjx-eqn-41">(41)</a> we can rewrite
<p>&nbsp;<br>
$$
\begin{align}
\vert r s \rangle \equiv \vert P_{rs} k_{rs} s_r s_s\rangle ,
\tag{60}
\end{align}
$$
<p>&nbsp;<br>

<p>
where \( P_{rs} = k_r +k_s \) is the total momentum and
\( k_{rs}=(k_r-k_s)/2 \) is the relative momentum. This representation of
two-body states is well adapated to our problem, because the
interaction and the \( T_2 \) amplitudes preserve the total momentum.
Thus, we store the cluster amplitudes \( t_{ij}^{ab} \) as matrices

<p>&nbsp;<br>
$$
\begin{align}
t_{ij}^{ab} \to \left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv t_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\tag{61}
\end{align}  
$$
<p>&nbsp;<br>

<p>
and the conservation of total momentum is explicit.

<p>
Likewise, the pppp, pphh, and hhhh parts of the interaction can be written in this form, namely
<p>&nbsp;<br>
$$
\begin{align}
V_{cd}^{ab} &\to \left[V(P_{ab})\right]_{\vert k_{cd} s_c s_d\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv V_{\vert P_{ab} k_{cd} s_c s_d\rangle}^{\vert P_{ab} k_{ab} s_a s_b\rangle} , 
\tag{62}\\
V_{ij}^{ab} &\to \left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv V_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\tag{63}\\ 
V_{ij}^{kl} &\to \left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{kl} s_k s_l\rangle}
\equiv V_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{kl} s_k s_l\rangle} , 
\tag{64}
\end{align} 
$$
<p>&nbsp;<br>

<p>
and we also have
<p>&nbsp;<br>
$$
\begin{align}
\overline{H}_{ij}^{ab} \to \left[\overline{H}(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\equiv \overline{H}_{\vert P_{ij} k_{ij} s_i s_j\rangle}^{\vert P_{ij} k_{ab} s_a s_b\rangle} , 
\tag{65}
\end{align}  
$$
<p>&nbsp;<br>

<p>
Using these objects, diagrams (1), (4), and (5) of Figure
<a href="#fig-ccd">11</a> can be done for each block of momentum \( P_{ij} \) as a
copy and matrix-matrix multiplications, respectively

<p>&nbsp;<br>
$$
\begin{align}
\left[\overline{H}(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle} &=
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle} 
\tag{66}\\
&+ {1\over 2} \sum_{\vert k_{kl} s_k s_l\rangle}
\left[t(P_{ij})\right]_{\vert k_{kl} s_k s_l\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{kl} s_k s_l\rangle} 
\tag{67}\\
&+ {1\over 2} \sum_{\vert k_{cd} s_c s_d\rangle}
\left[V(P_{ij})\right]_{\vert k_{cd} s_c s_d\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{cd} s_c s_d\rangle} .
\tag{68}
\end{align}
$$
<p>&nbsp;<br>

<p>
Similarly, the CCD correlation energy results from
<p>&nbsp;<br>
$$
\begin{align}
E_c = {1\over 4} \sum_{P_{ij}} \sum_{\vert k_{ij} s_i s_j\rangle}\sum_{\vert k_{ab} s_a s_b\rangle }
\left[t(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\left[V(P_{ij})\right]_{\vert k_{ij} s_i s_j\rangle}^{\vert k_{ab} s_a s_b\rangle}
\tag{69}
\end{align}
$$
<p>&nbsp;<br>

<p>
These efficiences cannot be used for the sixth diagram of Figure
<a href="#fig-ccd">11</a>. One could either change to a ph formulation, noting that
\( k_a-k_i = k_k -k_c \) is also a preserved quantity in \( t_{ik}^{ac} \) and
that \( k_k-k_c = k_j-k_b \) is preserved in \( V_{cj}^{kb} \). Thus
\( \sum_{kc} t_{ik}^{ac}V_{cj}^{kb} \) has a conserved quantity \( k_k-k_c \)
in the loop, and we can again use matrix-matrix multiplications for
this diagram. This requires us to store the \( T_2 \) amplitude in a phhp
and in the usual pphh formulation. Alternatively, we could simply code
this diagram with the loops over single-particle states. If this seems
too tedious, one can also limit CCD to the first five diagrams in
Figure <a href="#fig-ccd">11</a> (these are the pp and hh ladders), which gives a
good description for neutron matter, see the comparison between this
and full CCD in [&quot;Coupled-cluster calculations of nucleonic matter,&quot;
G. Hagen, T. Papenbrock, A. Ekstr&#246;m, K. A. Wendt, G. Baardsen,
S. Gandolfi, M. Hjorth-Jensen, C. J. Horowitz, arXiv:1311.2925,
Phys. Rev. C 89, 014319 (2014)].

<h2><div id="___sec55"></div></h2>
</div>

<p>
The steps towards the solution of the CCD equations for neutron matter are as follows

<ol>
<p><li> For a given density and UV cutoff, set up the lattice, i.e. determine the single-particle basis.</li>
<p><li> Determine the channels allowed by the (Minnesota) interaction, i.e. sets of two-body states that are connected by the interaction.</li>
<p><li> Exploit this channel structure when computing the diagrams.</li>
<p><li> Solve the coupled-cluster equations. Here we start first with the pp and hh ladders, i.e. using only  the first five diagrams of Figure <a href="#fig-ccd">11</a>.</li>
</ol>
<p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<!-- --- begin exercise --- -->

<h2 id="ex-30">Exercise 20: Write a CCD code for neutron matter, focusing first on ladder approximation, i.e. including the first five diagrams in Figure <a href="#fig-ccd">11</a>.</h2>

<p>
<!-- --- begin answer of exercise --- -->
<b>Answer.</b>
<a href="https://github.com/NuclearTalent/ManyBody2018/tree/master/doc/Programs/Python/NeutronMatter" target="_blank">Click for IPython notebook</a>

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #228B22">##############################################################</span>
<span style="color: #228B22"># CCD Program for neutron matter with the Minnesota potential.</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># Thomas Papenbrock, July/August 2018</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># License: Free Software following Version 3 of GNU General Public License, </span>
<span style="color: #228B22"># see https://www.gnu.org/licenses/gpl.html</span>
<span style="color: #228B22">#######</span>


<span style="color: #228B22">##########################</span>
<span style="color: #228B22"># Class for neutron matter </span>
<span style="color: #228B22">#######</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">MomSpaceBasis</span>:
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    momentum-space basis class</span>
<span style="color: #CD5555">    The constructor has the form</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    MomSpaceBasis(Nmax,kmax)</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param Nmax: Number of lattice points in positive kx-direction</span>
<span style="color: #CD5555">    param kmax: Highest lattice momentum (in 1/fm)</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return: MomSpaceBasis as a single-partcle basis. </span>
<span style="color: #CD5555">    attributes of MomSpaceBasis are</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    dk : lattice spacing in 1/fm</span>
<span style="color: #CD5555">    Lbox : linear dimension (in fm) of cubic box</span>
<span style="color: #CD5555">    nvec : lattice vectors (integers)</span>
<span style="color: #CD5555">    kvec : lattice momentum vectors (floats, in 1/fm)</span>
<span style="color: #CD5555">    ngrid : total number of lattice points </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>,Nmax,kmax,ordered=<span style="color: #658b00">True</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        the constructor</span>
<span style="color: #CD5555">        </span>
<span style="color: #CD5555">        Generates a cubic lattice in momentum space</span>
<span style="color: #CD5555">        param Nmax: Number of lattice points in positive kx-direction</span>
<span style="color: #CD5555">        param kmax: Highest lattice momentum (in 1/fm)</span>
<span style="color: #CD5555">        param ordered: Optional parameter, True by default, will order lattice points by kinetic energy</span>
<span style="color: #CD5555">        </span>
<span style="color: #CD5555">        return MomSpaceBasis</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #658b00">self</span>.Nmax = Nmax
        <span style="color: #658b00">self</span>.dim = <span style="color: #B452CD">0</span>
        <span style="color: #658b00">self</span>.ngrid = <span style="color: #B452CD">0</span>
        <span style="color: #658b00">self</span>._kvec=[]
        <span style="color: #658b00">self</span>._nvec=[]

        dk = kmax / Nmax
        <span style="color: #658b00">self</span>.dk = dk
        <span style="color: #658b00">self</span>.Lbox = <span style="color: #B452CD">2.0</span>*np.pi/dk
        
        nx=[]
        nvec=[]
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(-Nmax,Nmax+<span style="color: #B452CD">1</span>):
            <span style="color: #658b00">self</span>.dim=<span style="color: #658b00">self</span>.dim+<span style="color: #B452CD">1</span>
            nx.append(i)
        
        <span style="color: #228B22">#print(&#39;nx=&#39;,nx)</span>
        
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> nx:
            <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> nx:
                <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> nx:
                    nvec.append(np.array([i,j,k], dtype=<span style="color: #658b00">int</span>))
                    
        <span style="color: #228B22">#print(&#39;nvec=&#39;,nvec)</span>
        <span style="color: #658b00">self</span>.ngrid=<span style="color: #658b00">len</span>(nvec)
        
        <span style="color: #8B008B; font-weight: bold">if</span> ordered:
            <span style="color: #228B22">#print(&quot;ordered&quot;)</span>
            norm=np.zeros(<span style="color: #658b00">self</span>.ngrid,dtype=<span style="color: #658b00">int</span>)
            <span style="color: #8B008B; font-weight: bold">for</span> i, vec <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(nvec):
                npvec=np.array(vec,dtype=<span style="color: #658b00">int</span>)
                norm[i]=np.dot(npvec,npvec)
               <span style="color: #228B22"># print(i, vec, norm[i])</span>
        
            index=np.argsort(norm)
            <span style="color: #228B22">#print(index)</span>
            <span style="color: #658b00">self</span>._nvec=[]
            <span style="color: #8B008B; font-weight: bold">for</span> i, ind <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(index):
                <span style="color: #228B22">#print(i, ind, nvec[ind])</span>
                <span style="color: #658b00">self</span>._nvec.append(nvec[ind])
                
        <span style="color: #8B008B; font-weight: bold">else</span>: 
            <span style="color: #658b00">self</span>._nvec=nvec  <span style="color: #228B22"># a list</span>
            
        <span style="color: #658b00">self</span>._kvec = np.array(<span style="color: #658b00">self</span>._nvec)*dk <span style="color: #228B22"># a numpy array</span>

    
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">kvec</span>(<span style="color: #658b00">self</span>,indx=-<span style="color: #B452CD">1</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        MomSpaceBasis.kvec(i) returns ith momentum vector</span>
<span style="color: #CD5555">        MomSpaceBasis.kvec() returns all momentum vectors</span>
<span style="color: #CD5555">        </span>
<span style="color: #CD5555">        param indx: index of k-vector to be returned, optional</span>
<span style="color: #CD5555">        return 3-vector (if index non-negative), or all vectors if no index specified</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">if</span> indx == -<span style="color: #B452CD">1</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._kvec
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._kvec[indx]
        
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">nvec</span>(<span style="color: #658b00">self</span>,indx=-<span style="color: #B452CD">1</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        MomSpaceBasis.nvec(i) returns ith lattice vector</span>
<span style="color: #CD5555">        MomSpaceBasis.nvec() returns all lattice vectors</span>
<span style="color: #CD5555">        </span>
<span style="color: #CD5555">        param indx: index of lattice vector to be returned, optional</span>
<span style="color: #CD5555">        return 3-vector (if index non-negative), or all lattice vectors if no index specified</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">if</span> indx == -<span style="color: #B452CD">1</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._nvec
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>._nvec[indx]
        
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dens</span>(<span style="color: #658b00">self</span>,num):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        returns density of system if num particles are present</span>
<span style="color: #CD5555">        param num: int, number of particles</span>
<span style="color: #CD5555">        return dens: float</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> num/(<span style="color: #658b00">self</span>.Lbox)**<span style="color: #B452CD">3</span>
    
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">update</span>(<span style="color: #658b00">self</span>,dk):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        Uses dk as new lattice spacing and rescales existing lattice</span>
<span style="color: #CD5555">        param dk: in 1/fm lattice spacing in momentum space</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #658b00">self</span>.Lbox=<span style="color: #B452CD">2.0</span>*np.pi/dk
        <span style="color: #658b00">self</span>._kvec = np.array(<span style="color: #658b00">self</span>._nvec)*dk
    
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__len__</span>(<span style="color: #658b00">self</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">        overloading of the &#39;len&#39; function</span>
<span style="color: #CD5555">        &quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.ngrid
    
    
<span style="color: #228B22">############</span>
<span style="color: #228B22"># useful functions</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">magic_numbers</span>(basis):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    param basis: MomSpaceBasis object</span>
<span style="color: #CD5555">    return magic: array of magic numbers</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    nvecs = basis.nvec()
    vec=np.array(nvecs[<span style="color: #B452CD">0</span>],dtype=<span style="color: #658b00">int</span>)
    norm = np.dot(vec,vec)
    magic=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #658b00">len</span>(nvecs)):
        vec=np.array(nvecs[i],dtype=<span style="color: #658b00">int</span>)
        norm2 = np.dot(vec,vec)
        <span style="color: #8B008B; font-weight: bold">if</span> norm2 &gt; norm: 
            magic.append(<span style="color: #B452CD">2</span>*i)
            norm=norm2
    <span style="color: #8B008B; font-weight: bold">return</span> magic


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_dk</span>(rho,Num):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    param rho: desired density</span>
<span style="color: #CD5555">    param Num: magic number of particles</span>
<span style="color: #CD5555">    return dk: grid spacing in momentum space (in 1/fm)</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    Lbox = (Num/rho)**(<span style="color: #B452CD">1.0</span>/<span style="color: #B452CD">3.0</span>)
    dk = <span style="color: #B452CD">2.0</span>*np.pi/Lbox
    <span style="color: #8B008B; font-weight: bold">return</span> dk

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">spbasis_from_MomSpaceBasis</span>(lattice_vecs,st_degen):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    converts a lattice to a single particle basis for spin-isospin degeneracy st_degen</span>
<span style="color: #CD5555">    param lattice_vecs: list of lattice vectors for 1st particle</span>
<span style="color: #CD5555">    param st_degen: spin-isospin degeneracy</span>
<span style="color: #CD5555">    return: basis as a list of momenta</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">if</span> st_degen != <span style="color: #B452CD">2</span>: <span style="color: #228B22"># for now only neutron matter</span>
        <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Unexpected parameter st_degen&quot;</span>)
        <span style="color: #8B008B; font-weight: bold">return</span> lattice_vecs
    
    basis=[]
    <span style="color: #8B008B; font-weight: bold">for</span> vec <span style="color: #8B008B">in</span> lattice_vecs:
        <span style="color: #8B008B; font-weight: bold">for</span> st <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(st_degen):
            basis.append(np.array(vec,dtype=<span style="color: #658b00">int</span>))
            
    <span style="color: #8B008B; font-weight: bold">return</span> basis



<span style="color: #228B22">#########################################################</span>
<span style="color: #228B22"># Functions for comparisons with infinite free Fermi gas</span>
                         
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">kF_from_density</span>(rho,st_degen=<span style="color: #B452CD">2</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Computes Fermi momentum for given density and spin/isospin degeneracy.</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    param rho: density in inverse fm cubed</span>
<span style="color: #CD5555">    param st_degen: spin-isospin degeneracy; default 2</span>
<span style="color: #CD5555">    return: Fermi momentum in inverse fm</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    res = (<span style="color: #B452CD">6.0</span>*(np.pi)**<span style="color: #B452CD">2</span>*rho/st_degen)**(<span style="color: #B452CD">1.0</span>/<span style="color: #B452CD">3.0</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> res

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">EnergyDensity_FermiGas</span>(kF,st_degen=<span style="color: #B452CD">2</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Computes energy density of free Fermi gas at Fermi momentum and spin/isospin degeneracy</span>
<span style="color: #CD5555">    param kF: Fermi momentum in inverse fm</span>
<span style="color: #CD5555">    param st_degen: spin-isospin degeneracy; default 2</span>
<span style="color: #CD5555">    return: Energy density in MeV/fm**3</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    pvec = np.array([kF,<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">0.0</span>])
    erg = (st_degen*kF**<span style="color: #B452CD">3</span>/(<span style="color: #B452CD">10.0</span>*np.pi**<span style="color: #B452CD">2</span>)) * Tkin(pvec)
    <span style="color: #8B008B; font-weight: bold">return</span> erg


<span style="color: #228B22">########################################################################################</span>
<span style="color: #228B22"># Functions for CCD of neutron matter</span>
<span style="color: #228B22"># Implementation uses only pp and hh ladders</span>
<span style="color: #228B22"># </span>
<span style="color: #228B22">########################################################################################</span>


<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numba</span> <span style="color: #8B008B; font-weight: bold">import</span> jit  
<span style="color: #228B22"># compile a few functions to gain speed; should probably done in Fortran or C++, </span>
<span style="color: #228B22"># and called from Python</span>

<span style="color: #707a7c">@jit</span>(nopython=<span style="color: #658b00">True</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">minnesota_nn</span>(p_out,s1_out,s2_out,p_in,s1_in,s2_in,Lbox):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    The Minnesota potential between two neutrons, not yet anti-symmetrized </span>
<span style="color: #CD5555">    param p_out: relative out momentum</span>
<span style="color: #CD5555">    param p_in : relative in momentum</span>
<span style="color: #CD5555">    param s1_out, s2_out: spin projections of out particles 1 and 2</span>
<span style="color: #CD5555">    param s1_in, s2_in  : spin projections of in particles 1 and 2</span>
<span style="color: #CD5555">    Lbox : size of momentum box</span>
<span style="color: #CD5555">    return: value of potential in MeV; not anti-symmetrized!</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># parameters. VT is not active between two neutrons (no triplet)</span>
    VR = <span style="color: #B452CD">200.0</span>
    VS = -<span style="color: #B452CD">91.85</span>  <span style="color: #228B22"># sign typo in Lecture Notes Physics 936, Chap. 8</span>
    kappaR = <span style="color: #B452CD">1.487</span>
    kappaS = <span style="color: #B452CD">0.465</span>
    
    qvec=p_out-p_in
    q2=np.dot(qvec,qvec)
    
    s1_i =spin2spinor(s1_in)
    s2_i =spin2spinor(s2_in)
    s1_o =spin2spinor(s1_out)
    s2_o =spin2spinor(s2_out)
    
    spin_part = <span style="color: #B452CD">0.5</span> * ( np.dot(s1_i,s1_o)*np.dot(s2_i,s2_o)
                       -np.dot(s1_i,s2_o)*np.dot(s2_i,s1_o) )
    
    
    pot = spin_part * (  VR*np.exp(-<span style="color: #B452CD">0.25</span>*q2/kappaR) / (Lbox*np.sqrt(kappaR))**<span style="color: #B452CD">3</span> 
                       + VS*np.exp(-<span style="color: #B452CD">0.25</span>*q2/kappaS) / (Lbox*np.sqrt(kappaS))**<span style="color: #B452CD">3</span> )
    
    pot = pot*(np.sqrt(np.pi))**<span style="color: #B452CD">3</span> 

    
    <span style="color: #8B008B; font-weight: bold">return</span> pot

<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">spin_of_index</span>(i):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Even indices of the lattive have spin up, odds have spin down</span>
<span style="color: #CD5555">    param i: index of sp_basis</span>
<span style="color: #CD5555">    return: spin as +/- 1</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    spin = <span style="color: #B452CD">1</span>-<span style="color: #B452CD">2</span>*np.remainder(i,<span style="color: #B452CD">2</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> spin

<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">spin2spinor</span>(s):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Makes a two-component spinor of an integer s</span>
<span style="color: #CD5555">    param s: spin = +/- 1</span>
<span style="color: #CD5555">    return: two-component numpy array [1,0] for up and [0,1] for down</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    up  =np.array([<span style="color: #B452CD">1.0</span>,<span style="color: #B452CD">0.0</span>])
    down=np.array([<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">1.0</span>])
    <span style="color: #8B008B; font-weight: bold">if</span> s == <span style="color: #B452CD">1</span>:
        <span style="color: #8B008B; font-weight: bold">return</span> up
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">return</span> down

<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Tkin</span>(pvec):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Kinetic energy for a momentum vector</span>
<span style="color: #CD5555">    param pvec: 3-component numpy array in inverse fm</span>
<span style="color: #CD5555">    return: kinetic energy of that momentum in MeV</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    nucleon_mass = <span style="color: #B452CD">938.92</span>
    hbarc = <span style="color: #B452CD">197.33</span>
<span style="color: #228B22"># More precise numbers for neutron mass and hbar follow.</span>
<span style="color: #228B22"># For N=14, this yields E_HF = 10.3337 MeV per nucleon in HF. Benchmarked with Ragnar Stroberg.</span>
<span style="color: #228B22">#     nucleon_mass = 939.56563</span>
<span style="color: #228B22">#     hbarc = 197.3269718</span>
    p2 = np.dot(pvec,pvec)
    res = <span style="color: #B452CD">0.5</span>*hbarc**<span style="color: #B452CD">2</span>*p2/nucleon_mass
    <span style="color: #8B008B; font-weight: bold">return</span> res
    
<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_total_Tkin</span>(Nocc,sp_basis,dk):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Computes total kinetic energy of reference state</span>
<span style="color: #CD5555">    param Nocc, sp_basis, dk: particle number, integer s.p. lattice, delta k </span>
<span style="color: #CD5555">    return: total kinetic energy</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    erg=<span style="color: #B452CD">0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nocc):
        mom_vec = sp_basis[i]
        vec=np.array(mom_vec)*dk
        erg=erg+Tkin(vec)
        
    <span style="color: #8B008B; font-weight: bold">return</span> erg



<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Fock</span>(pvec,s,sp_basis,Nocc,dk,Lbox):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Fock matrix of momentum pvec in hh space</span>
<span style="color: #CD5555">    param pvec: 3-component numpy array in inverse fm</span>
<span style="color: #CD5555">    param s: spin as +/- 1 of state</span>
<span style="color: #CD5555">    param_sp_basis, Nocc, dk, Lbox : parameters of s.p. basis and system</span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return: Fock matrix element = kinetic energy of that momentum in MeV</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    res = Tkin(pvec)
    
    dum=<span style="color: #B452CD">0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nocc):
        vec=sp_basis[i]*dk
        si=spin_of_index(i)
        p_in = <span style="color: #B452CD">0.5</span>*(vec-pvec)
        p_out= p_in
        dum = dum + ( minnesota_nn(p_out,s,si, p_in, s,si,Lbox) 
                     -minnesota_nn(p_out,s,si,-p_in,si, s,Lbox) )  <span style="color: #228B22">#antisymmetrized Minnesota</span>
        
    res = res+dum
    <span style="color: #8B008B; font-weight: bold">return</span> res

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_E_HF_simple</span>(Nocc,sp_basis,dk):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Computes HF energy of reference state</span>
<span style="color: #CD5555">    param Nocc, sp_basis, dk: particle number, integer s.p. lattice, delta k </span>
<span style="color: #CD5555">    return: total HF energy</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    erg=compute_total_Tkin(Nocc,sp_basis,dk)

    pot=<span style="color: #B452CD">0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nocc):
        momi=sp_basis[i]*dk
        si = spin_of_index(i)
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nocc):
            momj=sp_basis[j]*dk
            sj = spin_of_index(j)
            p_rel = <span style="color: #B452CD">0.5</span>*(momi-momj)
            pot = pot + <span style="color: #B452CD">0.5</span>* (  minnesota_nn(p_rel,si,sj, p_rel,si,sj,Lbox)
                                - minnesota_nn(p_rel,si,sj,-p_rel,sj,si,Lbox) )
            
    erg = erg+pot
    <span style="color: #8B008B; font-weight: bold">return</span> erg


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_channels</span>(sp_basis,start1,end1,start2,end2,identical,other_channels=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Returns channels for coupled cluster based on Minnesota potential</span>
<span style="color: #CD5555">    param sp_Basis: A single-particle basis</span>
<span style="color: #CD5555">    param start1: index to start for particle 1</span>
<span style="color: #CD5555">    param end1: index to end for particle 1</span>
<span style="color: #CD5555">    param start2: index to start for particle 2</span>
<span style="color: #CD5555">    param end2: index to end for particle 2</span>
<span style="color: #CD5555">    param identical: True for hh or pp, False for hp</span>
<span style="color: #CD5555">    param other_channels: list of other channels to compare with</span>
<span style="color: #CD5555">    return: channels, p_rel, t2amp. channels is a list of p12, where p12 is a momentum vector; </span>
<span style="color: #CD5555">            p_rel is a nested list with relative momenta and spins for each channel</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    channel=[]
    p_rel=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i, mom_vecs1 <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(sp_basis[start1:end1]):
        <span style="color: #228B22">#vec1=np.array(mom_vecs1,dtype=int)</span>
        vec1=mom_vecs1
        spin1=spin_of_index(i)
            
        <span style="color: #8B008B; font-weight: bold">for</span> j, mom_vecs2 <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(sp_basis[start2:end2]):
            <span style="color: #8B008B; font-weight: bold">if</span> identical <span style="color: #8B008B">and</span> i==j: <span style="color: #8B008B; font-weight: bold">continue</span>  <span style="color: #228B22">#Fortran cycle</span>
            <span style="color: #228B22">#vec2=np.array(mom_vecs2,dtype=int)</span>
            vec2=mom_vecs2
            spin2=spin_of_index(j)
                
            p12 = vec1+vec2
            prel= vec1-vec2
            spins=np.array([spin1,spin2],dtype=<span style="color: #658b00">int</span>)
            ps=[prel,spins]

            new=<span style="color: #658b00">True</span>
            needed=<span style="color: #658b00">True</span>
            <span style="color: #8B008B; font-weight: bold">if</span> other_channels <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>: <span style="color: #228B22">#check whether we need this channel</span>
                needed=<span style="color: #658b00">False</span>
                <span style="color: #8B008B; font-weight: bold">for</span> chan_o <span style="color: #8B008B">in</span> other_channels:
                    <span style="color: #8B008B; font-weight: bold">if</span> (chan_o==p12).all(): 
                        needed=<span style="color: #658b00">True</span>
                        <span style="color: #8B008B; font-weight: bold">break</span>
            <span style="color: #8B008B; font-weight: bold">if</span> needed: <span style="color: #228B22">#check whether this channel exists already</span>
                <span style="color: #8B008B; font-weight: bold">for</span> ipos, chan <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(channel):
                    <span style="color: #8B008B; font-weight: bold">if</span> (chan==p12).all(): 
                        new=<span style="color: #658b00">False</span>
                        <span style="color: #8B008B; font-weight: bold">break</span>
                    
            <span style="color: #8B008B; font-weight: bold">if</span> needed <span style="color: #8B008B">and</span> new: 
                channel.append(p12)
                p_rel.append([ps])
                
            <span style="color: #8B008B; font-weight: bold">if</span> needed <span style="color: #8B008B">and</span> <span style="color: #8B008B">not</span> new:
                p_rel[ipos].append(ps)
                
    <span style="color: #8B008B; font-weight: bold">return</span> channel, p_rel 
    

    
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">setup_T2_amplitudes</span>(sp_basis,NN,st_degen):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    returns the t2 amplitudes and t2 channels</span>
<span style="color: #CD5555">    param sp_basis: a sp_basis</span>
<span style="color: #CD5555">    param NN: neutron number</span>
<span style="color: #CD5555">    param st_degen: 2 for the moment, spin-isospin degeneracy</span>
<span style="color: #CD5555">    return: hh_channels, pp_channels, p_rel_hh, p_rel_pp, t2amp</span>
<span style="color: #CD5555">            these are the hh and pp channels of T2, lists of the relative momenta, </span>
<span style="color: #CD5555">            and t2amps as a list of numpy arrays set to zero </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    num_states = <span style="color: #658b00">len</span>(sp_basis)
    
    hh_channels, p_rel_hh = get_channels(sp_basis,<span style="color: #B452CD">0</span>,NN,<span style="color: #B452CD">0</span>,NN,<span style="color: #658b00">True</span>)
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;hh channels=&#39;</span>, <span style="color: #658b00">len</span>(hh_channels))

    pp_channels, p_rel_pp = get_channels(sp_basis,NN,num_states,NN,num_states,<span style="color: #658b00">True</span>,hh_channels)
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;pp channels=&#39;</span>, <span style="color: #658b00">len</span>(pp_channels))
    
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(pp_channels) != <span style="color: #658b00">len</span>(hh_channels): <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;pp and hh channels do not match&#39;</span>)
     

    ordered_pp_channel=[]
    ordered_p_rel_pp=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i, chanhh <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(hh_channels):
        <span style="color: #8B008B; font-weight: bold">for</span> j, chanpp <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(pp_channels):
            <span style="color: #8B008B; font-weight: bold">if</span> (chanpp==chanhh).all():
                ordered_pp_channel.append(chanpp)
                ordered_p_rel_pp.append(p_rel_pp[j])    
                <span style="color: #8B008B; font-weight: bold">break</span>
                
    pp_channels = ordered_pp_channel
    p_rel_pp = ordered_p_rel_pp
            
    <span style="color: #228B22"># set t2 amplitudes to zero in each channel</span>
    t2amp = fill_pot(Lbox, dk, pp_channels, hh_channels, p_rel_pp, p_rel_hh, <span style="color: #658b00">True</span>)
        
    <span style="color: #8B008B; font-weight: bold">return</span> hh_channels, pp_channels, p_rel_hh, p_rel_pp, t2amp

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">fill_pot</span>(Lbox, dk, channels_out, channels_in, p_rel_out, p_rel_in, T2amp=<span style="color: #658b00">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Fills lists of matrices such as Vhhhh, Vpphh, Vpppp, t2_pphh</span>
<span style="color: #CD5555">    param Lbox: Lbox</span>
<span style="color: #CD5555">    param dk: dk</span>
<span style="color: #CD5555">    param channels_out, channels_in: the channels we have</span>
<span style="color: #CD5555">    param p_rel_out, p_rel_in: the list of [prel, [s1,s2]]</span>
<span style="color: #CD5555">    param T2amp=False: Set to True if t2_pphh needs to be computed</span>
<span style="color: #CD5555">    return: The object of desire as a list of numpy matrices. </span>
<span style="color: #CD5555">            Contain matrix elements for potentials, zeros if T2amp=True is requested. </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    Vpot=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i, chan_in <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(channels_in):
        dim_in = <span style="color: #658b00">len</span>(p_rel_in[i])
        dim_out= <span style="color: #658b00">len</span>(p_rel_out[i])
        Vpot_chan=np.zeros((dim_out,dim_in))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> T2amp: 
            <span style="color: #8B008B; font-weight: bold">for</span> ii, ps_i <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_in[i]):
                [pii, [s1, s2]] = ps_i
                pii = pii*dk*<span style="color: #B452CD">0.5</span>
                <span style="color: #8B008B; font-weight: bold">for</span> jj, ps_j <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_out[i]):
                    <span style="color: #8B008B; font-weight: bold">if</span> dim_in == dim_out <span style="color: #8B008B">and</span> jj &gt; ii: <span style="color: #8B008B; font-weight: bold">continue</span>
                    [pjj, [ss1, ss2]] = ps_j
                    pjj = pjj*dk*<span style="color: #B452CD">0.5</span>
                    Vpot_chan[jj,ii] = ( minnesota_nn( pjj,ss1,ss2, pii,s1,s2,Lbox)
                                        -minnesota_nn(-pjj,ss2,ss1, pii,s1,s2,Lbox) )
                    <span style="color: #8B008B; font-weight: bold">if</span> dim_in == dim_out : Vpot_chan[ii,jj] = Vpot_chan[jj,ii]
        
        Vpot.append(Vpot_chan)
    <span style="color: #8B008B; font-weight: bold">return</span> Vpot


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_V</span>(Lbox, dk, hhchannels, ppchannels, p_relhh, p_relpp,zeros=<span style="color: #658b00">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Sets up Vhhhh, Vpphh, and Vpppp. </span>
<span style="color: #CD5555">    </span>
<span style="color: #CD5555">    return: Vhhhh, Vpphh, Vpppp as a lists of numpy arrays</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    Vhhhh = fill_pot(Lbox, dk, hhchannels, hhchannels, p_relhh, p_relhh,zeros)
    Vpphh = fill_pot(Lbox, dk, ppchannels, hhchannels, p_relpp, p_relhh,zeros)
    Vpppp = fill_pot(Lbox, dk, ppchannels, ppchannels, p_relpp, p_relpp,zeros)
    
    <span style="color: #8B008B; font-weight: bold">return</span> Vhhhh, Vpphh, Vpppp  
            
<span style="color: #707a7c">@jit</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">make_diagram</span>(obj1,obj2,fac):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Makes diagrams for pp or hh ladders as matrix-matrix multiplications</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    hbar_pphh=[]
    dim1=<span style="color: #658b00">len</span>(obj1)
    <span style="color: #8B008B; font-weight: bold">for</span> chan <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(dim1):
        mat1 = obj1[chan]
        mat2 = obj2[chan]
        hbar_pphh.append( fac*np.matmul(mat1,mat2) )
        
    <span style="color: #8B008B; font-weight: bold">return</span> hbar_pphh


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">make_diagrams2_3</span>(t2_pphh,fabij):
    hbar_pphh=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i, t2_mat <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(t2_pphh):
        f_mat = fabij[i]
        hbar_mat = t2_mat*f_mat
        hbar_pphh.append(hbar_mat)
    <span style="color: #8B008B; font-weight: bold">return</span> hbar_pphh


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_hbar</span>(v_pppp,v_pphh,v_hhhh,t2_pphh,fabij):
    diagram1 = v_pphh.copy()
    diagram23 = make_diagrams2_3(t2_pphh, fabij)
    diagram4 = make_diagram(v_pppp,t2_pphh,<span style="color: #B452CD">0.5</span>)
    diagram5 = make_diagram(t2_pphh,v_hhhh,<span style="color: #B452CD">0.5</span>)
    
    hbar_pphh=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t2_pphh)):
        mat = (  diagram1[i]
               + diagram23[i]
               + diagram4[i]
               + diagram5[i]  )
        hbar_pphh.append(mat)
    
    <span style="color: #8B008B; font-weight: bold">return</span> hbar_pphh
    
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_energy_denominator</span>(hh_channels,p_rel_pp,p_rel_hh,sp_basis,Nocc,dk,Lbox):
    res=[]
    fabij=[]
    <span style="color: #8B008B; font-weight: bold">for</span> i, Ptot <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(hh_channels):
        dimhh=<span style="color: #658b00">len</span>(p_rel_hh[i])
        dimpp=<span style="color: #658b00">len</span>(p_rel_pp[i])
        res_mat = np.zeros((dimpp,dimhh))
        f_mat   = np.zeros((dimpp,dimhh))
        <span style="color: #8B008B; font-weight: bold">for</span> ii, psh_rel <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_hh[i]):
            [pij, [si, sj]] = psh_rel  
            p_i = (Ptot+pij)//<span style="color: #B452CD">2</span>
            p_i = p_i + np.array([Nmax,Nmax,Nmax],dtype=<span style="color: #658b00">int</span>)
            p_j = (Ptot-pij)//<span style="color: #B452CD">2</span>
            p_j = p_j + np.array([Nmax,Nmax,Nmax],dtype=<span style="color: #658b00">int</span>)
            ssi = (<span style="color: #B452CD">1</span>-si)//<span style="color: #B452CD">2</span>
            ssj = (<span style="color: #B452CD">1</span>-sj)//<span style="color: #B452CD">2</span>
            fii = fock_mtx4[p_i[<span style="color: #B452CD">0</span>],p_i[<span style="color: #B452CD">1</span>],p_i[<span style="color: #B452CD">2</span>],ssi]
            fjj = fock_mtx4[p_j[<span style="color: #B452CD">0</span>],p_j[<span style="color: #B452CD">1</span>],p_j[<span style="color: #B452CD">2</span>],ssj]
            <span style="color: #8B008B; font-weight: bold">for</span> jj, psp_rel <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_pp[i]):
                [pab, [sa, sb]] = psp_rel
                p_a = (Ptot+pab)//<span style="color: #B452CD">2</span>
                p_a = p_a + np.array([Nmax,Nmax,Nmax],dtype=<span style="color: #658b00">int</span>)
                p_b = (Ptot-pab)//<span style="color: #B452CD">2</span>
                p_b = p_b + np.array([Nmax,Nmax,Nmax],dtype=<span style="color: #658b00">int</span>)
                ssa = (<span style="color: #B452CD">1</span>-sa)//<span style="color: #B452CD">2</span>
                ssb = (<span style="color: #B452CD">1</span>-sb)//<span style="color: #B452CD">2</span>
                faa = fock_mtx4[p_a[<span style="color: #B452CD">0</span>],p_a[<span style="color: #B452CD">1</span>],p_a[<span style="color: #B452CD">2</span>],ssa]
                fbb = fock_mtx4[p_b[<span style="color: #B452CD">0</span>],p_b[<span style="color: #B452CD">1</span>],p_b[<span style="color: #B452CD">2</span>],ssb]
                
                res_mat[jj,ii] = <span style="color: #B452CD">1.0</span> / (fii + fjj - faa - fbb) 
                f_mat[jj,ii] = faa + fbb - fii - fjj
        res.append(res_mat)
        fabij.append(f_mat)
    <span style="color: #8B008B; font-weight: bold">return</span> res, fabij


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_t2_from_mbpt</span>(Vpphh,denom):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    param Vpphh: Vpphh</span>
<span style="color: #CD5555">    param denom: energy denominator in pphh format</span>
<span style="color: #CD5555">    return t2: quotient of both, element for element </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    res = []
    <span style="color: #8B008B; font-weight: bold">for</span> i, vv <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(Vpphh):
        dd = denom[i]
        res_mat = vv*dd  <span style="color: #228B22">#how simple in python; element by element multiply</span>
        res.append(res_mat)
    <span style="color: #8B008B; font-weight: bold">return</span> res


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_E_CCD</span>(Vpphh,T2pphh):
    erg=<span style="color: #B452CD">0.0</span>
<span style="color: #228B22">#     erg2=0.0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i, t2mat <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(T2pphh):
        vmat  = Vpphh[i]
        erg = erg + <span style="color: #B452CD">0.25</span>*np.sum(vmat*t2mat)
    <span style="color: #8B008B; font-weight: bold">return</span> erg


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_Fock_4</span>(sp_basis,Nocc,dk,Lbox,Nmax):
    fock_mtx4=np.zeros(shape=(<span style="color: #B452CD">2</span>*Nmax+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>*Nmax+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>*Nmax+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> i, vec <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(sp_basis):
        pvec=vec*dk
        spin=spin_of_index(i)
        si = (<span style="color: #B452CD">1</span> - spin)//<span style="color: #B452CD">2</span>
        px=vec[<span style="color: #B452CD">0</span>]+Nmax
        py=vec[<span style="color: #B452CD">1</span>]+Nmax
        pz=vec[<span style="color: #B452CD">2</span>]+Nmax
        fock_mtx4[px,py,pz,si] = Fock(pvec,spin,sp_basis,Nocc,dk,Lbox)
    <span style="color: #8B008B; font-weight: bold">return</span> fock_mtx4

<span style="color: #228B22">#####################################</span>
<span style="color: #228B22">########### Main Program starts here    </span>

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">timeit</span> <span style="color: #8B008B; font-weight: bold">import</span> default_timer <span style="color: #8B008B; font-weight: bold">as</span> timer
<span style="color: #228B22"># for timing purposes</span>

progstart=timer()

Nmax=<span style="color: #B452CD">1</span>
kmax=<span style="color: #B452CD">1.0</span>
mbase = MomSpaceBasis(Nmax,kmax)
lattice=mbase.nvec()

<span style="color: #228B22">## set particle number</span>
NN=<span style="color: #B452CD">14</span>
st_degen=<span style="color: #B452CD">2</span>  <span style="color: #228B22"># spin up and down</span>
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;chosen N =&quot;</span>, NN)
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;magic numbers&quot;</span>, magic_numbers(mbase))

<span style="color: #228B22">## set density</span>
rho=<span style="color: #B452CD">0.08</span>

dk = get_dk(rho,NN)

mbase.update(dk)
Lbox = mbase.Lbox


<span style="color: #228B22">## get single particle basis</span>

sp_basis = spbasis_from_MomSpaceBasis(lattice,st_degen)
num_states = <span style="color: #658b00">len</span>(sp_basis)

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;number of s.p. states:&#39;</span>, num_states)

<span style="color: #228B22"># print out a few facts of the reference state</span>
total_Tkin = compute_total_Tkin(NN,sp_basis,dk)
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;total Tkin per particle =&#39;</span>, total_Tkin/NN )

k_fermi = kF_from_density(rho)

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Fermi momentum =&quot;</span>, k_fermi)

E_gas = EnergyDensity_FermiGas(k_fermi)

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Energy per neutron of infinite free Fermi gas&quot;</span>, E_gas/rho)

E_HF = compute_E_HF_simple(NN,sp_basis,dk)
E_HF = E_HF/NN
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;HF energy per neutron =&quot;</span>, E_HF)

<span style="color: #228B22">## now we start our business ...</span>
<span style="color: #228B22">## get all channels and two-body states within those channels; set T2 to zero</span>
hh_channels, pp_channels, p_rel_hh, p_rel_pp, t2_pphh = setup_T2_amplitudes(sp_basis,NN,st_degen)

<span style="color: #228B22"># get some insight in how big this all is</span>
count=<span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> i, channel <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_hh):
    dim=<span style="color: #658b00">len</span>(p_rel_hh[i])
    count=count+dim

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;hh number of total combinations&#39;</span>, count)

count=<span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> i, channel <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(p_rel_pp):
    dim=<span style="color: #658b00">len</span>(p_rel_pp[i])
    count=count+dim
    
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;pp number of total combinations&#39;</span>, count)


<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;get v_hhhh, v_pphh, v_pppp&quot;</span>)
start = timer()
v_hhhh, v_pphh, v_pppp = init_V(Lbox, dk, hh_channels, pp_channels, p_rel_hh, p_rel_pp)
end = timer()
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;what a hog!&quot;</span>, end-start, <span style="color: #CD5555">&#39;seconds&#39;</span>)


<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;compute energy denominator&quot;</span>)
start = timer()
fock_mtx4 = compute_Fock_4(sp_basis,NN,dk,Lbox,Nmax)
denom_pphh, f_abij = get_energy_denominator(pp_channels,p_rel_pp,p_rel_hh,sp_basis,NN,dk,Lbox)
end = timer()
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;that&#39;s faster&quot;</span>, end-start, <span style="color: #CD5555">&#39;seconds&#39;</span>)

<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Initialize T2 from MBPT2&quot;</span>)
t2_pphh = get_t2_from_mbpt(v_pphh,denom_pphh)

erg = compute_E_CCD(v_pphh,t2_pphh)
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;MBPT2 correlation energy per neutron =&#39;</span>, erg/NN)


<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;start CCD iterations ...&quot;</span>)

niter=<span style="color: #B452CD">200</span>
mix=<span style="color: #B452CD">0.99</span>
erg_old=<span style="color: #B452CD">0.0</span>
eps=<span style="color: #B452CD">1.e-8</span>
<span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">iter</span> <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(niter):
    
    start = timer()
    hbar_pphh = compute_hbar(v_pppp,v_pphh,v_hhhh,t2_pphh,f_abij)
    end = timer()
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;time of making Hbar:&quot;</span>, end-start, <span style="color: #CD5555">&#39;seconds&#39;</span>)
    
    t2_new = get_t2_from_mbpt(hbar_pphh,denom_pphh)
    
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t2_new)):
        t2_new[i] = t2_pphh[i] + t2_new[i]
    
    erg = compute_E_CCD(v_pphh,t2_new)
    
    myeps = <span style="color: #658b00">abs</span>(erg-erg_old)/<span style="color: #658b00">abs</span>(erg)
    <span style="color: #8B008B; font-weight: bold">if</span> myeps &lt; eps: <span style="color: #8B008B; font-weight: bold">break</span>
    erg_old=erg

    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;iter=&quot;</span>, <span style="color: #658b00">iter</span>, <span style="color: #CD5555">&quot;Correlation energy per neutron=&quot;</span>, erg/NN, <span style="color: #CD5555">&quot;, epsilon=&quot;</span>, myeps)
    
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t2_pphh)):
        t2_pphh[i] = mix*t2_new[i] + (<span style="color: #B452CD">1.0</span>-mix)*t2_pphh[i]
    
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Correlation energy per neutron= &quot;</span>, erg/NN)

progend=timer()
<span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&#39;total time in seconds&#39;</span>, progend-progstart)
</pre></div>
<p>
<!-- --- end answer of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h2><div id="___sec57"></div></h2>
</div>

<h1 id="___sec58">Benchmarks with the Minnesota potential </h1>

<p>
For the benchmarks, let us use a nucleon mass \( m=938.92 \) MeV, \( \hbar =
197.33 \) MeV fm, and \( c=1 \). For \( N=14 \) neutrons at a density \( \rho=0.08
{\rm fm}^{-3} \) one finds \( T_{\rm kin}(\vert\phi_0\rangle)/N =
22.427553 \) MeV, and \( E_{HF}/N = 10.3498 \) MeV. In model spaces with
\( N_{\rm max}=1 \) and \( N_{\rm max}=2 \), and using only the first five diagrams
of Figure <a href="#fig-ccd">11</a> for the CCD calculation, yields the correlation
energies per particle of \( E_{c}/N =-0.2118 \) MeV and \( E_{c}/N =-0.6923 \)
MeV, respectively.

<p>

<center><h1 id="___sec59">From Structure to Reactions </h1></center> <hr>

<p>
Nuclear coupled-cluster theory has also been used to describe aspects
of nuclear reactions, namely photo reactions and computations of
optical potentials. In what follows, we want to discuss these approaches.

<h1 id="___sec60">Electroweak reactions </h1>

<p>
Let us assume we probe a nucleus with an electroweak probe (e.g. via
photon or \( Z \)-boson exchange). The corresponding operator
\( \hat{\Theta} \) introduces transitions in the nucleus. For photo
reactions, the relevant operator is the dipole operator

<p>&nbsp;<br>
$$
\begin{align}
\hat{\Theta} = \sum_{1=1}^A q_i (\vec{r}_i - \vec{R}_{CoM}) .
\tag{70}
\end{align}
$$
<p>&nbsp;<br>

<p>
Here \( q_i \) is the charge of nucleon \( i \), and \( \vec{R}_{CoM} \) is the
position of the center of mass. The structure function or response
function describing the reaction is

<p>&nbsp;<br>
$$
\begin{align}
S(\omega) \equiv \sum_f \langle\psi_0|\hat{\Theta}^\dagger|\psi_f\rangle\langle \psi_f |\hat{\Theta}|\psi_0\rangle \delta(E_f-E_0-\omega).
\tag{71}
\end{align}
$$
<p>&nbsp;<br>

<p>
Here, the sum is over all final states. The structure function is
difficult to compute because the sum is over (infinitely many)
continuum states, and we seek a simpler formulation. The key idea is
that the Lorentz integral transform (LIT) of the structure function

<p>&nbsp;<br>
$$
\begin{align}
\tag{72}
L(\omega_0,\Gamma) &\equiv {\Gamma\over\pi} \int d\omega \frac{S(\omega)}{(\omega-\omega_0)^2+\Gamma^2} \\
&= {\Gamma\over\pi}\langle\psi_0|\hat{\Theta}^\dagger {1\over H-E_0-\omega_0+i\Gamma} {1\over H-E_0-\omega_0-i\Gamma}\hat{\Theta}|\psi_0\rangle \nonumber.
\end{align}
$$
<p>&nbsp;<br>

<p>
We note that the LIT \( L(\omega_0,\Gamma) \) of the structure function is
a ground-state expectation value and thus much easier to compute than
the structure function itself. We also note that the LIT is not
invertible (mathematically speaking), but making some assumptions
about the structure function, and imposing a finite resolution
\( \Gamma \) alleviates this problem in practical computation.

<p>
We next rewrite the LIT for coupled cluster using the shorthand
\( z\equiv E_0+\omega_0+i\Gamma \) as

<p>&nbsp;<br>
$$
\begin{align}
L(\omega_0,\Gamma) &\equiv {\Gamma\over\pi} \langle\tilde{\psi}_L(z^*) \vert \tilde{\psi}_R(z)\rangle , 
\tag{73}
\end{align}
$$
<p>&nbsp;<br>

<p>
with \( \vert\tilde{\psi}_R(z)\rangle \) and \( \langle\tilde{\psi}_L(z^*)\vert \) fulfilling
<p>&nbsp;<br>
$$
\begin{align}
\tag{74}
\left(\overline{H}-z\right) \vert\tilde{\psi}_R(z)\rangle &= \overline{\Theta} \vert\phi_0\rangle , \\
\langle\tilde{\psi}_L(z^*)\vert \left(\overline{H}-z^*\right) &= \langle \phi_L\vert .
\tag{75}
\end{align}
$$
<p>&nbsp;<br>

<p>
Here, \( \langle \phi_L\vert \) is the left ground state, i.e. the left
eigenstate of the similarity-transformed Hamiltonian. Note that in the
coupled-cluster formulation we have distinguished between left and
right states (as these are not adjoints of each other), and replaced
all operators by their similarity transformations. Making the ansatz

<p>&nbsp;<br>
$$
\begin{align}
\tag{76}
\vert\tilde{\psi}_R(z)\rangle &= \hat{R}\vert\phi_0\rangle \\
&= \left( r_0(z) + \sum_{ia} r_i^a(z) a_a^\dagger a_i + {1\over 4} \sum_{ijab} r_{ij}^{ab}(z) a_a^\dagger a^\dagger_b a_j a_i +\cdots\right)\vert\phi_0\rangle  \nonumber
\end{align}
$$
<p>&nbsp;<br>

<p>
for the right state, and

<p>&nbsp;<br>
$$
\begin{align}
\tag{77}
\langle\tilde{\psi}_L(z^*)\vert&= \langle\phi_L\vert \hat{L} \\
&= \langle \phi_L\vert \left( l_0(z) +  \sum_{ia} l^i_a(z) a_i^\dagger a_a + {1\over 4} \sum_{ijab} l^{ij}_{ab}(z) a_i^\dagger a^\dagger_j a_b a_a +\cdots\right)  \nonumber
\end{align}
$$
<p>&nbsp;<br>

<p>
for the left state, make the Eq. <a href="#mjx-eqn-74">(74)</a> linear systems of
equations that can be solved for the parameters \( r_0, r_i^a,
r_{ij}^{ab} \) and \( l_0, l_a^i, l_{ab}^{ij} \) for each value of \( z \). The LIT then becomes

<p>&nbsp;<br>
$$
\begin{align}
L(z) = l_0(z) r_0(z) + \sum_{ia} l_a^i(z) r_i^a(z) +{1\over 4} l_{ab}^{ij}(z) r_{ij}^{ab}(z) 
\tag{78}
\end{align}
$$
<p>&nbsp;<br>

in the CCSD approximation. For details, please see [&quot;Giant and pigmy dipole resonances in 4He, 16,22O, and 40Ca from chiral nucleon-nucleon interactions,&quot; S. Bacca, N. Barnea, G. Hagen, M. Miorelli, G. Orlandini, and T. Papenbrock,
Phys. Rev. C 90, 064619 (2014)].

<h1 id="___sec61">Computing optical potentials from microscopic input </h1>

<p>
The single-particle Green's function

<p>&nbsp;<br>
$$
\begin{align}
\tag{79}
G(\alpha, \beta, E) &\equiv \langle\psi_0\vert a_\alpha {1\over E-(H-E_0)+i\eta}a^\dagger_\beta\vert\psi_0\rangle
+ \langle\psi_0\vert a_\beta^\dagger {1\over E-(H-E_0)-i\eta}a_\alpha\vert\psi_0\rangle  
\end{align}
$$
<p>&nbsp;<br>

<p>
describes the propagation of particles and holes in the nucleus with a
ground state \( \vert\psi_0\rangle \) and energy \( E_0 \). The Green's function fulfills the Dyson equation

<p>&nbsp;<br>
$$
\begin{align}
\tag{80}
G = G^{(0)} +G^{(0)} \Sigma^* G , 
\end{align}
$$
<p>&nbsp;<br>

<p>
where \( \Sigma^* \) is the self energy and \( G^{(0)} \) is the Hartree-Fock Green's function

<p>&nbsp;<br>
$$
\begin{align}
\tag{81}
G^{(0)}(\alpha, \beta, E) &\equiv \langle\phi_0\vert a_\alpha {1\over E-(H_{HF}-E_{HF})+i\eta}a^\dagger_\beta\vert\phi_0\rangle
+ \langle\phi_0\vert a_\beta^\dagger {1\over E-(H_{HF}-E_{HF})-i\eta}a_\alpha\vert\phi_0\rangle \\
&= \delta_\alpha^\beta \left({\Theta(\alpha-F) \over E-\varepsilon_\alpha +i\eta} + {\Theta(F-\alpha) \over E-\varepsilon_\alpha -i\eta} \right) \nonumber. 
\end{align}
$$
<p>&nbsp;<br>

<p>
Here, \( \Theta() \) denotes the unit step function and \( F \) labels the
index of the Fermi surface. The key point is now that the optical
potential \( \Sigma' \) (which describes the reaction of a single nucleon with the
nucleus) is related to the self energy and the Hartree-Fock potential
\( U_{HF} \) by [F. Capuzzi and C. Mahaux, &quot;Projection operator approach to the
self-energy,&quot; Ann. Phys. (NY) 245, 147 (1996)]

<p>&nbsp;<br>
$$
\begin{align}
\Sigma' \equiv \Sigma^* +U_{HF} .
\tag{82}
\end{align}
$$
<p>&nbsp;<br>

<p>
The idea is thus as follows. Starting from a Hartree-Fock calculations
enables us to compute the Hartree-Fock potential \( U_{HF} \) and the
Hartree-Fock Green's function <a href="#mjx-eqn-81">(81)</a>. Computing the Green's
function <a href="#mjx-eqn-79">(79)</a> in coupled clusters, and inverting the Dyson
equation <a href="#mjx-eqn-80">(80)</a> using

<p>&nbsp;<br>
$$
\begin{align}
\Sigma^* = \left(G^{(0)}\right)^{-1} - G^{-1}
\tag{83}
\end{align}
$$
<p>&nbsp;<br>

<p>
thus allows us to compute the optical potential. We note that the
Green's function <a href="#mjx-eqn-79">(79)</a> resembles in its structure the LIT
<a href="#mjx-eqn-72">(72)</a>, and we will indeed use a similar approach to compute this
object with the coupled-cluster method. Indeed, we compute

<p>&nbsp;<br>
$$
\begin{align}
\left(E-(\overline{H}-E_0)+ i\eta\right) \vert\tilde{\psi}_R\rangle &= \overline{a^\dagger_\beta} \vert\phi_0\rangle , 
\tag{84}\\
\langle\tilde{\psi}_L\vert \left(E-(E_0-\overline{H})-i\eta\right) &= \langle \phi_L\vert \overline{a_\beta^\dagger} , 
\tag{85}
\end{align}
$$
<p>&nbsp;<br>

<p>
by making the ansatz <a href="#mjx-eqn-76">(76)</a> and <a href="#mjx-eqn-77">(77)</a> for the right
and left states, respectively, solve the resulting linear systems, and
then compute \( G(\alpha,\beta,E) = \langle\phi_L\vert
\overline{a_\alpha} \vert\tilde{\psi}_R\rangle + \langle
\tilde{\psi}_L\vert \overline{a_\alpha}\vert\phi_0\rangle \).

<p>
We note that a high quality optical potential can only be obtained if
the structure of the nucleus is computed with a good accuracy, i.e. in
good agreement to data on binding and separation energies, and charge
and matter radii. For details, please see [&quot;Optical potential from
first principles,&quot; J. Rotureau, P. Danielewicz, G. Hagen, F. Nunes,
and T. Papenbrock, Phys. Rev. C 95, 024315 (2017); arXiv:1611.04554].
We also note that this procedure must be repeated for any nucleus of
interest, because the optical potential depends on the nucleus under
consideration. Once the optical potential \( \Sigma' \) is computed, the
single-particle Schroedinger equation

<p>&nbsp;<br>
$$
\begin{align}
\left( -{\hbar^2\Delta\over 2m} +\Sigma'\right)\xi = E\xi 
\tag{86}
\end{align}
$$
<p>&nbsp;<br>

<p>
describes the interaction of a single nucleon (and wave function
\( \xi \)) with the nucleus.

<p>
Finally, we note that this approach does not depend on solving the
nucleus \( A \) with the coupled-cluster method. Alternatives, such as the
IMSRG or Self-Consistent Green's Function methods could also be used.


<center style="font-size:80%">
<!-- copyright --> &copy; 2018, Thomas Papenbrock. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>
